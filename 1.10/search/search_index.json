{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Documentation for version: v1.10.23</p> <p>Data validation and settings management using Python type annotations.</p> <p>pydantic enforces type hints at runtime, and provides user friendly errors when data is invalid.</p> <p>Define how data should be in pure, canonical Python; validate it with pydantic.</p>"},{"location":"#example","title":"Example","text":"Python 3.7 and abovePython 3.9 and abovePython 3.10 and above <pre><code>from datetime import datetime\nfrom typing import List, Optional\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: int\n    name = 'John Doe'\n    signup_ts: Optional[datetime] = None\n    friends: List[int] = []\n\n\nexternal_data = {\n    'id': '123',\n    'signup_ts': '2019-06-01 12:22',\n    'friends': [1, 2, '3'],\n}\nuser = User(**external_data)\nprint(user.id)\n#&gt; 123\nprint(repr(user.signup_ts))\n#&gt; datetime.datetime(2019, 6, 1, 12, 22)\nprint(user.friends)\n#&gt; [1, 2, 3]\nprint(user.dict())\n\"\"\"\n{\n    'id': 123,\n    'signup_ts': datetime.datetime(2019, 6, 1, 12, 22),\n    'friends': [1, 2, 3],\n    'name': 'John Doe',\n}\n\"\"\"\n</code></pre> <pre><code>from datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: int\n    name = 'John Doe'\n    signup_ts: Optional[datetime] = None\n    friends: list[int] = []\n\n\nexternal_data = {\n    'id': '123',\n    'signup_ts': '2019-06-01 12:22',\n    'friends': [1, 2, '3'],\n}\nuser = User(**external_data)\nprint(user.id)\n#&gt; 123\nprint(repr(user.signup_ts))\n#&gt; datetime.datetime(2019, 6, 1, 12, 22)\nprint(user.friends)\n#&gt; [1, 2, 3]\nprint(user.dict())\n\"\"\"\n{\n    'id': 123,\n    'signup_ts': datetime.datetime(2019, 6, 1, 12, 22),\n    'friends': [1, 2, 3],\n    'name': 'John Doe',\n}\n\"\"\"\n</code></pre> <pre><code>from datetime import datetime\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: int\n    name = 'John Doe'\n    signup_ts: datetime | None = None\n    friends: list[int] = []\n\n\nexternal_data = {\n    'id': '123',\n    'signup_ts': '2019-06-01 12:22',\n    'friends': [1, 2, '3'],\n}\nuser = User(**external_data)\nprint(user.id)\n#&gt; 123\nprint(repr(user.signup_ts))\n#&gt; datetime.datetime(2019, 6, 1, 12, 22)\nprint(user.friends)\n#&gt; [1, 2, 3]\nprint(user.dict())\n\"\"\"\n{\n    'id': 123,\n    'signup_ts': datetime.datetime(2019, 6, 1, 12, 22),\n    'friends': [1, 2, 3],\n    'name': 'John Doe',\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>What's going on here:</p> <ul> <li><code>id</code> is of type int; the annotation-only declaration tells pydantic that this field is required. Strings,   bytes or floats will be coerced to ints if possible; otherwise an exception will be raised.</li> <li><code>name</code> is inferred as a string from the provided default; because it has a default, it is not required.</li> <li><code>signup_ts</code> is a datetime field which is not required (and takes the value <code>None</code> if it's not supplied).   pydantic will process either a unix timestamp int (e.g. <code>1496498400</code>) or a string representing the date &amp; time.</li> <li><code>friends</code> uses Python's typing system, and requires a list of integers. As with <code>id</code>, integer-like objects   will be converted to integers.</li> </ul> <p>If validation fails pydantic will raise an error with a breakdown of what was wrong:</p> Python 3.7 and above <pre><code>from pydantic import ValidationError\n\ntry:\n    User(signup_ts='broken', friends=[1, 2, 'not number'])\nexcept ValidationError as e:\n    print(e.json())\n</code></pre> <p>(This script requires User from previous example)</p> <p>Outputs: <pre><code>[\n  {\n    \"loc\": [\n      \"id\"\n    ],\n    \"msg\": \"field required\",\n    \"type\": \"value_error.missing\"\n  },\n  {\n    \"loc\": [\n      \"signup_ts\"\n    ],\n    \"msg\": \"invalid datetime format\",\n    \"type\": \"value_error.datetime\"\n  },\n  {\n    \"loc\": [\n      \"friends\",\n      2\n    ],\n    \"msg\": \"value is not a valid integer\",\n    \"type\": \"type_error.integer\"\n  }\n]\n</code></pre></p>"},{"location":"#rationale","title":"Rationale","text":"<p>So pydantic uses some cool new language features, but why should I actually go and use it?</p> plays nicely with your IDE/linter/brain There's no new schema definition micro-language to learn. If you know how to use Python type hints,  you know how to use pydantic. Data structures are just instances of classes you define with type annotations,  so auto-completion, linting, mypy, IDEs (especially PyCharm),  and your intuition should all work properly with your validated data. dual use pydantic's BaseSettings class allows pydantic to be used in both a \"validate this request data\" context and in a \"load my system settings\" context. The main differences are that system settings can be read from environment variables, and more complex objects like DSNs and Python objects are often required. fast pydantic has always taken performance seriously, most of the library is compiled with cython giving a ~50% speedup, it's generally as fast or faster than most similar libraries. validate complex structures use of recursive pydantic models, <code>typing</code>'s  standard types (e.g. <code>List</code>, <code>Tuple</code>, <code>Dict</code> etc.) and  validators allow complex data schemas to be clearly and easily defined, validated, and parsed. extensible pydantic allows custom data types to be defined or you can extend validation  with methods on a model decorated with the <code>validator</code> decorator. dataclasses integration As well as <code>BaseModel</code>, pydantic provides a <code>dataclass</code> decorator which creates (almost) vanilla Python dataclasses with input data parsing and validation."},{"location":"#using-pydantic","title":"Using Pydantic","text":"<p>Hundreds of organisations and packages are using pydantic, including:</p> FastAPI a high performance API framework, easy to learn, fast to code and ready for production, based on pydantic and Starlette. Project Jupyter developers of the Jupyter notebook are using pydantic for subprojects, through the FastAPI-based Jupyter server Jupyverse, and for FPS's configuration management. Microsoft are using pydantic (via FastAPI) for  numerous services, some of which are  \"getting integrated into the core Windows product and some Office products.\" Amazon Web Services are using pydantic in gluon-ts, an open-source probabilistic time series modeling library. The NSA are using pydantic in WALKOFF, an open-source automation framework. Uber are using pydantic in Ludwig, an open-source TensorFlow wrapper. Cuenca are a Mexican neobank that uses pydantic for several internal tools (including API validation) and for open source projects like stpmex, which is used to process real-time, 24/7, inter-bank transfers in Mexico. The Molecular Sciences Software Institute are using pydantic in QCFractal, a massively distributed compute framework for quantum chemistry. Reach trusts pydantic (via FastAPI) and arq (Samuel's excellent asynchronous task queue) to reliably power multiple mission-critical microservices. Robusta.dev are using pydantic to automate Kubernetes troubleshooting and maintenance. For example, their open source tools to debug and profile Python applications on Kubernetes use pydantic models. <p>For a more comprehensive list of open-source projects using pydantic see the  list of dependents on github.</p>"},{"location":"#discussion-of-pydantic","title":"Discussion of Pydantic","text":"<p>Podcasts and videos discussing pydantic.</p> Talk Python To Me Michael Kennedy and Samuel Colvin, the creator of pydantic, dive into the history of pydantic and its many uses and benefits. Podcast.__init__ Discussion about where pydantic came from and ideas for where it might go next with  Samuel Colvin the creator of pydantic. Python Bytes Podcast \"This is a sweet simple framework that solves some really nice problems... Data validations and settings management  using Python type annotations, and it's the Python type annotations that makes me really extra happy... It works  automatically with all the IDE's you already have.\" --Michael Kennedy Python pydantic Introduction \u2013 Give your data classes super powers a talk by Alexander Hultn\u00e9r originally for the Python Pizza Conference introducing new users to pydantic and walking  through the core features of pydantic."},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v11023-2025-09-13","title":"v1.10.23 (2025-09-13)","text":"<ul> <li>Fix mypy plugin for mypy 1.18 by @cdce8p in https://github.com/pydantic/pydantic/pull/12207</li> </ul>"},{"location":"changelog/#v11022-2025-04-17","title":"v1.10.22 (2025-04-17)","text":"<ul> <li>Fix compatibility with <code>typing-extensions</code> by @Viicos in https://github.com/pydantic/pydantic/pull/11764</li> </ul>"},{"location":"changelog/#v11021-2025-01-10","title":"v1.10.21 (2025-01-10)","text":"<ul> <li>Fix compatibility with ForwardRef._evaluate and Python &lt; 3.12.4 by @griels in https://github.com/pydantic/pydantic/pull/11232</li> </ul>"},{"location":"changelog/#v11020-2025-01-07","title":"v1.10.20 (2025-01-07)","text":"<p>This release provides proper support for Python 3.13, with (Cythonized) wheels published for this version. As a consequence, Cython was updated from <code>0.29.x</code> to <code>3.0.x</code>.</p> <ul> <li>General maintenance of CI and build ecosystem by @Viicos in https://github.com/pydantic/pydantic/pull/10847<ul> <li>Update Cython to <code>3.0.x</code>.</li> <li>Properly address Python 3.13 deprecation warnings.</li> <li>Migrate packaging to <code>pyproject.toml</code>, make use of PEP 517 build options.</li> <li>Use <code>build</code> instead of direct <code>setup.py</code> invocations.</li> <li>Update various Github Actions versions.</li> </ul> </li> <li>Replace outdated stpmex link in documentation by @jaredenorris in https://github.com/pydantic/pydantic/pull/10997</li> </ul>"},{"location":"changelog/#v11019-2024-11-06","title":"v1.10.19 (2024-11-06)","text":"<ul> <li>Add warning when v2 model is nested in v1 model by @sydney-runkle in https://github.com/pydantic/pydantic/pull/10432</li> <li>Fix deprecation warning in V1 <code>isinstance</code> check by @alicederyn in https://github.com/pydantic/pydantic/pull/10645</li> </ul>"},{"location":"changelog/#v11018-2024-08-22","title":"v1.10.18 (2024-08-22)","text":"<ul> <li>Eval type fix in V1 by @sydney-runkle in https://github.com/pydantic/pydantic/pull/9751</li> <li>Add <code>to_lower_camel</code> to <code>__all__</code> in <code>utils.py</code> by @sydney-runkle (direct commit)</li> <li>Fix <code>mypy</code> v1 plugin for mypy 1.11 release by @flaeppe in https://github.com/pydantic/pydantic/pull/10139</li> <li>Fix discriminator key used when discriminator has alias and <code>.schema(by_alias=False)</code> by @exs-dwoodward in https://github.com/pydantic/pydantic/pull/10146</li> </ul>"},{"location":"changelog/#v11017-2024-06-20","title":"v1.10.17 (2024-06-20)","text":"<ul> <li>Advertise Python 3.12 for 1.10.x! Part Deux by @vfazio in https://github.com/pydantic/pydantic/pull/9644</li> <li>Mirrored modules in <code>v1</code> namespace to fix typing and object resolution in python&gt;3.11 by @exs-dwoodward in https://github.com/pydantic/pydantic/pull/9660</li> <li>Setup: remove upper bound from python_requires by @vfazio in https://github.com/pydantic/pydantic/pull/9685</li> </ul>"},{"location":"changelog/#v11016-2024-06-11","title":"v1.10.16 (2024-06-11)","text":"<ul> <li>Specify recursive_guard as kwarg in FutureRef._evaluate by @vfazio in https://github.com/pydantic/pydantic/pull/9612</li> <li>Fix mypy v1 plugin for upcoming mypy release by @ cdce8p in https://github.com/pydantic/pydantic/pull/9586</li> <li>Import modules/objects directly from v1 namespace by @exs-dwoodward in https://github.com/pydantic/pydantic/pull/9162</li> </ul>"},{"location":"changelog/#v11015-2024-04-03","title":"v1.10.15 (2024-04-03)","text":"<ul> <li>Add pydantic.v1 namespace to Pydantic v1 by @exs-dmiketa in https://github.com/pydantic/pydantic/pull/9042</li> <li>Relax version of typing-extensions for V1 by @SonOfLilit in https://github.com/pydantic/pydantic/pull/8819</li> <li>patch fix for mypy by @sydney-runkle in https://github.com/pydantic/pydantic/pull/8765</li> </ul>"},{"location":"changelog/#v11014-2024-01-19","title":"v1.10.14 (2024-01-19)","text":"<ul> <li>Update install.md by @dmontagu in https://github.com/pydantic/pydantic/pull/7690</li> <li>Fixes ci to only deploy docs on release by @sydney-runkle in https://github.com/pydantic/pydantic/pull/7740</li> <li>Ubuntu fixes for V1 by @sydney-runkle in https://github.com/pydantic/pydantic/pull/8540 and https://github.com/pydantic/pydantic/pull/8587</li> <li>Fix cached_property handling in dataclasses when copied by @rdbisme in https://github.com/pydantic/pydantic/pull/8407</li> </ul>"},{"location":"changelog/#v11013-2023-09-27","title":"v1.10.13 (2023-09-27)","text":"<ul> <li>Fix: Add max length check to <code>pydantic.validate_email</code>, #7673 by @hramezani</li> <li>Docs: Fix pip commands to install v1, #6930 by @chbndrhnns</li> </ul>"},{"location":"changelog/#v11012-2023-07-24","title":"v1.10.12 (2023-07-24)","text":"<ul> <li>Fixes the <code>maxlen</code> property being dropped on <code>deque</code> validation. Happened only if the deque item has been typed. Changes the <code>_validate_sequence_like</code> func, #6581 by @maciekglowka</li> </ul>"},{"location":"changelog/#v11011-2023-07-04","title":"v1.10.11 (2023-07-04)","text":"<ul> <li>Importing create_model in tools.py through relative path instead of absolute path - so that it doesn't import V2 code when copied over to V2 branch, #6361 by @SharathHuddar</li> </ul>"},{"location":"changelog/#v20b3-2023-06-16","title":"v2.0b3 (2023-06-16)","text":"<p>Third beta pre-release of Pydantic V2</p> <p>See the full changelog here</p>"},{"location":"changelog/#v20b2-2023-06-03","title":"v2.0b2 (2023-06-03)","text":"<p>Add <code>from_attributes</code> runtime flag to <code>TypeAdapter.validate_python</code> and <code>BaseModel.model_validate</code>.</p> <p>See the full changelog here</p>"},{"location":"changelog/#v20b1-2023-06-01","title":"v2.0b1 (2023-06-01)","text":"<p>First beta pre-release of Pydantic V2</p> <p>See the full changelog here</p>"},{"location":"changelog/#v20a4-2023-05-05","title":"v2.0a4 (2023-05-05)","text":"<p>Fourth pre-release of Pydantic V2</p> <p>See the full changelog here</p>"},{"location":"changelog/#v20a3-2023-04-20","title":"v2.0a3 (2023-04-20)","text":"<p>Third pre-release of Pydantic V2</p> <p>See the full changelog here</p>"},{"location":"changelog/#v20a2-2023-04-12","title":"v2.0a2 (2023-04-12)","text":"<p>Second pre-release of Pydantic V2</p> <p>See the full changelog here</p>"},{"location":"changelog/#v20a1-2023-04-03","title":"v2.0a1 (2023-04-03)","text":"<p>First pre-release of Pydantic V2!</p> <p>See this post for more details.</p>"},{"location":"changelog/#v11010-2023-06-30","title":"v1.10.10 (2023-06-30)","text":"<ul> <li>Add Pydantic <code>Json</code> field support to settings management, #6250 by @hramezani</li> <li>Fixed literal validator errors for unhashable values, #6188 by @markus1978</li> <li>Fixed bug with generics receiving forward refs, #6130 by @mark-todd</li> <li>Update install method of FastAPI for internal tests in CI, #6117 by @Kludex</li> </ul>"},{"location":"changelog/#v1109-2023-06-07","title":"v1.10.9 (2023-06-07)","text":"<ul> <li>Fix trailing zeros not ignored in Decimal validation, #5968 by @hramezani</li> <li>Fix mypy plugin for v1.4.0, #5928 by @cdce8p</li> <li>Add future and past date hypothesis strategies, #5850 by @bschoenmaeckers</li> <li>Discourage usage of Cython 3 with Pydantic 1.x, #5845 by @lig</li> </ul>"},{"location":"changelog/#v1108-2023-05-23","title":"v1.10.8 (2023-05-23)","text":"<ul> <li>Fix a bug in <code>Literal</code> usage with <code>typing-extension==4.6.0</code>, #5826 by @hramezani</li> <li>This solves the (closed) issue #3849 where aliased fields that use discriminated union fail to validate when the data contains the non-aliased field name, #5736 by @benwah</li> <li>Update email-validator dependency to &gt;=2.0.0post2, #5627 by @adriangb</li> <li>update <code>AnyClassMethod</code> for changes in python/typeshed#9771, #5505 by @ITProKyle</li> </ul>"},{"location":"changelog/#v1107-2023-03-22","title":"v1.10.7 (2023-03-22)","text":"<ul> <li>Fix creating schema from model using <code>ConstrainedStr</code> with <code>regex</code> as dict key, #5223 by @matejetz</li> <li>Address bug in mypy plugin caused by explicit_package_bases=True, #5191 by @dmontagu</li> <li>Add implicit defaults in the mypy plugin for Field with no default argument, #5190 by @dmontagu</li> <li>Fix schema generated for Enum values used as Literals in discriminated unions, #5188 by @javibookline</li> <li>Fix mypy failures caused by the pydantic mypy plugin when users define <code>from_orm</code> in their own classes, #5187 by @dmontagu</li> <li>Fix <code>InitVar</code> usage with pydantic dataclasses, mypy version <code>1.1.1</code> and the custom mypy plugin, #5162 by @cdce8p</li> </ul>"},{"location":"changelog/#v1106-2023-03-08","title":"v1.10.6 (2023-03-08)","text":"<ul> <li>Implement logic to support creating validators from non standard callables by using defaults to identify them and unwrapping <code>functools.partial</code> and <code>functools.partialmethod</code> when checking the signature, #5126 by @JensHeinrich</li> <li>Fix mypy plugin for v1.1.1, and fix <code>dataclass_transform</code> decorator for pydantic dataclasses, #5111 by @cdce8p</li> <li>Raise <code>ValidationError</code>, not <code>ConfigError</code>, when a discriminator value is unhashable, #4773 by @kurtmckee</li> </ul>"},{"location":"changelog/#v1105-2023-02-15","title":"v1.10.5 (2023-02-15)","text":"<ul> <li>Fix broken parametrized bases handling with <code>GenericModel</code>s with complex sets of models, #5052 by @MarkusSintonen</li> <li>Invalidate mypy cache if plugin config changes, #5007 by @cdce8p</li> <li>Fix <code>RecursionError</code> when deep-copying dataclass types wrapped by pydantic, #4949 by @mbillingr</li> <li>Fix <code>X | Y</code> union syntax breaking <code>GenericModel</code>, #4146 by @thenx</li> <li>Switch coverage badge to show coverage for this branch/release, #5060 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v1104-2022-12-30","title":"v1.10.4 (2022-12-30)","text":"<ul> <li>Change dependency to <code>typing-extensions&gt;=4.2.0</code>, #4885 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v1103-2022-12-29","title":"v1.10.3 (2022-12-29)","text":"<p>NOTE: v1.10.3 was \"yanked\" from PyPI due to #4885 which is fixed in v1.10.4</p> <ul> <li>fix parsing of custom root models, #4883 by @gou177</li> <li>fix: use dataclass proxy for frozen or empty dataclasses, #4878 by @PrettyWood</li> <li>Fix <code>schema</code> and <code>schema_json</code> on models where a model instance is a one of default values, #4781 by @Bobronium</li> <li>Add Jina AI to sponsors on docs index page, #4767 by @samuelcolvin</li> <li>fix: support assignment on <code>DataclassProxy</code>, #4695 by @PrettyWood</li> <li>Add <code>postgresql+psycopg</code> as allowed scheme for <code>PostgreDsn</code> to make it usable with SQLAlchemy 2, #4689 by @morian</li> <li>Allow dict schemas to have both <code>patternProperties</code> and <code>additionalProperties</code>, #4641 by @jparise</li> <li>Fixes error passing None for optional lists with <code>unique_items</code>, #4568 by @mfulgo</li> <li>Fix <code>GenericModel</code> with <code>Callable</code> param raising a <code>TypeError</code>, #4551 by @mfulgo</li> <li>Fix field regex with <code>StrictStr</code> type annotation, #4538 by @sisp</li> <li>Correct <code>dataclass_transform</code> keyword argument name from <code>field_descriptors</code> to <code>field_specifiers</code>, #4500 by @samuelcolvin</li> <li>fix: avoid multiple calls of <code>__post_init__</code> when dataclasses are inherited, #4487 by @PrettyWood</li> <li>Reduce the size of binary wheels, #2276 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v1102-2022-09-05","title":"v1.10.2 (2022-09-05)","text":"<ul> <li>Revert Change: Revert percent encoding of URL parts which was originally added in #4224, #4470 by @samuelcolvin</li> <li>Prevent long (length &gt; <code>4_300</code>) strings/bytes as input to int fields, see    python/cpython#95778 and    CVE-2020-10735, #1477 by @samuelcolvin</li> <li>fix: dataclass wrapper was not always called, #4477 by @PrettyWood</li> <li>Use <code>tomllib</code> on Python 3.11 when parsing <code>mypy</code> configuration, #4476 by @hauntsaninja</li> <li>Basic fix of <code>GenericModel</code> cache to detect order of arguments in <code>Union</code> models, #4474 by @sveinugu</li> <li>Fix mypy plugin when using bare types like <code>list</code> and <code>dict</code> as <code>default_factory</code>, #4457 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v1101-2022-08-31","title":"v1.10.1 (2022-08-31)","text":"<ul> <li>Add <code>__hash__</code> method to <code>pydancic.color.Color</code> class, #4454 by @czaki</li> </ul>"},{"location":"changelog/#v1100-2022-08-30","title":"v1.10.0 (2022-08-30)","text":"<ul> <li>Refactor the whole pydantic <code>dataclass</code> decorator to really act like its standard lib equivalent.   It hence keeps <code>__eq__</code>, <code>__hash__</code>, ... and makes comparison with its non-validated version possible.   It also fixes usage of <code>frozen</code> dataclasses in fields and usage of <code>default_factory</code> in nested dataclasses.   The support of <code>Config.extra</code> has been added.   Finally, config customization directly via a <code>dict</code> is now possible, #2557 by @PrettyWood BREAKING CHANGES:<ul> <li>The <code>compiled</code> boolean (whether pydantic is compiled with cython) has been moved from <code>main.py</code> to <code>version.py</code></li> <li>Now that <code>Config.extra</code> is supported, <code>dataclass</code> ignores by default extra arguments (like <code>BaseModel</code>)</li> </ul> </li> <li>Fix PEP487 <code>__set_name__</code> protocol in <code>BaseModel</code> for PrivateAttrs, #4407 by @tlambert03</li> <li>Allow for custom parsing of environment variables via <code>parse_env_var</code> in <code>Config</code>, #4406 by @acmiyaguchi</li> <li>Rename <code>master</code> to <code>main</code>, #4405 by @hramezani</li> <li>Fix <code>StrictStr</code> does not raise <code>ValidationError</code> when <code>max_length</code> is present in <code>Field</code>, #4388 by @hramezani</li> <li>Make <code>SecretStr</code> and <code>SecretBytes</code> hashable, #4387 by @chbndrhnns</li> <li>Fix <code>StrictBytes</code> does not raise <code>ValidationError</code> when <code>max_length</code> is present in <code>Field</code>, #4380 by @JeanArhancet</li> <li>Add support for bare <code>type</code>, #4375 by @hramezani</li> <li>Support Python 3.11, including binaries for 3.11 in PyPI, #4374 by @samuelcolvin</li> <li>Add support for <code>re.Pattern</code>, #4366 by @hramezani</li> <li>Fix <code>__post_init_post_parse__</code> is incorrectly passed keyword arguments when no <code>__post_init__</code> is defined, #4361 by @hramezani</li> <li>Fix implicitly importing <code>ForwardRef</code> and <code>Callable</code> from <code>pydantic.typing</code> instead of <code>typing</code> and also expose <code>MappingIntStrAny</code>, #4358 by @aminalaee</li> <li>remove <code>Any</code> types from the <code>dataclass</code> decorator so it can be used with the <code>disallow_any_expr</code> mypy option, #4356 by @DetachHead</li> <li>moved repo to <code>pydantic/pydantic</code>, #4348 by @yezz123</li> <li>fix \"extra fields not permitted\" error when dataclass with <code>Extra.forbid</code> is validated multiple times, #4343 by @detachhead</li> <li>Add Python 3.9 and 3.10 examples to docs, #4339 by @Bobronium</li> <li>Discriminated union models now use <code>oneOf</code> instead of <code>anyOf</code> when generating OpenAPI schema definitions, #4335 by @MaxwellPayne</li> <li>Allow type checkers to infer inner type of <code>Json</code> type. <code>Json[list[str]]</code> will be now inferred as <code>list[str]</code>,    <code>Json[Any]</code> should be used instead of plain <code>Json</code>.   Runtime behaviour is not changed, #4332 by @Bobronium</li> <li>Allow empty string aliases by using a <code>alias is not None</code> check, rather than <code>bool(alias)</code>, #4253 by @sergeytsaplin</li> <li>Update <code>ForwardRef</code>s in <code>Field.outer_type_</code>, #4249 by @JacobHayes</li> <li>The use of <code>__dataclass_transform__</code> has been replaced by <code>typing_extensions.dataclass_transform</code>, which is the preferred way to mark pydantic models as a dataclass under PEP 681, #4241 by @multimeric</li> <li>Use parent model's <code>Config</code> when validating nested <code>NamedTuple</code> fields, #4219 by @synek</li> <li>Update <code>BaseModel.construct</code> to work with aliased Fields, #4192 by @kylebamos</li> <li>Catch certain raised errors in <code>smart_deepcopy</code> and revert to <code>deepcopy</code> if so, #4184 by @coneybeare</li> <li>Add <code>Config.anystr_upper</code> and <code>to_upper</code> kwarg to constr and conbytes, #4165 by @satheler</li> <li>Fix JSON schema for <code>set</code> and <code>frozenset</code> when they include default values, #4155 by @aminalaee</li> <li>Teach the mypy plugin that methods decorated by <code>@validator</code> are classmethods, #4102 by @DMRobertson</li> <li>Improve mypy plugin's ability to detect required fields, #4086 by @richardxia</li> <li>Support fields of type <code>Type[]</code> in schema, #4051 by @aminalaee</li> <li>Add <code>default</code> value in JSON Schema when <code>const=True</code>, #4031 by @aminalaee</li> <li>Adds reserved word check to signature generation logic, #4011 by @strue36</li> <li>Fix Json strategy failure for the complex nested field, #4005 by @sergiosim</li> <li>Add JSON-compatible float constraint <code>allow_inf_nan</code>, #3994 by @tiangolo</li> <li>Remove undefined behaviour when <code>env_prefix</code> had characters in common with <code>env_nested_delimiter</code>, #3975 by @arsenron</li> <li>Support generics model with <code>create_model</code>, #3945 by @hot123s</li> <li>allow submodels to overwrite extra field info, #3934 by @PrettyWood</li> <li>Document and test structural pattern matching (PEP 636) on <code>BaseModel</code>, #3920 by @irgolic</li> <li>Fix incorrect deserialization of python timedelta object to ISO 8601 for negative time deltas.   Minus was serialized in incorrect place (\"P-1DT23H59M59.888735S\" instead of correct \"-P1DT23H59M59.888735S\"), #3899 by @07pepa</li> <li>Fix validation of discriminated union fields with an alias when passing a model instance, #3846 by @chornsby</li> <li>Add a CockroachDsn type to validate CockroachDB connection strings. The type   supports the following schemes: <code>cockroachdb</code>, <code>cockroachdb+psycopg2</code> and <code>cockroachdb+asyncpg</code>, #3839 by @blubber</li> <li>Fix MyPy plugin to not override pre-existing <code>__init__</code> method in models, #3824 by @patrick91</li> <li>Fix mypy version checking, #3783 by @KotlinIsland</li> <li>support overwriting dunder attributes of <code>BaseModel</code> instances, #3777 by @PrettyWood</li> <li>Added <code>ConstrainedDate</code> and <code>condate</code>, #3740 by @hottwaj</li> <li>Support <code>kw_only</code> in dataclasses, #3670 by @detachhead</li> <li>Add comparison method for <code>Color</code> class, #3646 by @aminalaee</li> <li>Drop support for python3.6, associated cleanup, #3605 by @samuelcolvin</li> <li>created new function <code>to_lower_camel()</code> for \"non pascal case\" camel case, #3463 by @schlerp</li> <li>Add checks to <code>default</code> and <code>default_factory</code> arguments in Mypy plugin, #3430 by @klaa97</li> <li>fix mangling of <code>inspect.signature</code> for <code>BaseModel</code>, #3413 by @fix-inspect-signature</li> <li>Adds the <code>SecretField</code> abstract class so that all the current and future secret fields like <code>SecretStr</code> and <code>SecretBytes</code> will derive from it, #3409 by @expobrain</li> <li>Support multi hosts validation in <code>PostgresDsn</code>, #3337 by @rglsk</li> <li>Fix parsing of very small numeric timedelta values, #3315 by @samuelcolvin</li> <li>Update <code>SecretsSettingsSource</code> to respect <code>config.case_sensitive</code>, #3273 by @JeanArhancet</li> <li>Add MongoDB network data source name (DSN) schema, #3229 by @snosratiershad</li> <li>Add support for multiple dotenv files, #3222 by @rekyungmin</li> <li>Raise an explicit <code>ConfigError</code> when multiple fields are incorrectly set for a single validator, #3215 by @SunsetOrange</li> <li>Allow ellipsis on <code>Field</code>s inside <code>Annotated</code> for <code>TypedDicts</code> required, #3133 by @ezegomez</li> <li>Catch overflow errors in <code>int_validator</code>, #3112 by @ojii</li> <li>Adds a <code>__rich_repr__</code> method to <code>Representation</code> class which enables pretty printing with Rich, #3099 by @willmcgugan</li> <li>Add percent encoding in <code>AnyUrl</code> and descendent types, #3061 by @FaresAhmedb</li> <li><code>validate_arguments</code> decorator now supports <code>alias</code>, #3019 by @MAD-py</li> <li>Avoid <code>__dict__</code> and <code>__weakref__</code> attributes in <code>AnyUrl</code> and IP address fields, #2890 by @nuno-andre</li> <li>Add ability to use <code>Final</code> in a field type annotation, #2766 by @uriyyo</li> <li>Update requirement to <code>typing_extensions&gt;=4.1.0</code> to guarantee <code>dataclass_transform</code> is available, #4424 by @commonism</li> <li>Add Explosion and AWS to main sponsors, #4413 by @samuelcolvin</li> <li>Update documentation for <code>copy_on_model_validation</code> to reflect recent changes, #4369 by @samuelcolvin</li> <li>Runtime warning if <code>__slots__</code> is passed to <code>create_model</code>, <code>__slots__</code> is then ignored, #4432 by @samuelcolvin</li> <li>Add type hints to <code>BaseSettings.Config</code> to avoid mypy errors, also correct mypy version compatibility notice in docs, #4450 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v1100b1-2022-08-24","title":"v1.10.0b1 (2022-08-24)","text":"<p>Pre-release, see the GitHub release for details.</p>"},{"location":"changelog/#v1100a2-2022-08-24","title":"v1.10.0a2 (2022-08-24)","text":"<p>Pre-release, see the GitHub release for details.</p>"},{"location":"changelog/#v1100a1-2022-08-22","title":"v1.10.0a1 (2022-08-22)","text":"<p>Pre-release, see the GitHub release for details.</p>"},{"location":"changelog/#v192-2022-08-11","title":"v1.9.2 (2022-08-11)","text":"<p>Revert Breaking Change: v1.9.1 introduced a breaking change where model fields were deep copied by default, this release reverts the default behaviour to match v1.9.0 and before,  while also allow deep-copy behaviour via <code>copy_on_model_validation = 'deep'</code>. See #4092 for more information.</p> <ul> <li>Allow for shallow copies of model fields, <code>Config.copy_on_model_validation</code> is now a str which must be   <code>'none'</code>, <code>'deep'</code>, or <code>'shallow'</code> corresponding to not copying, deep copy &amp; shallow copy; default <code>'shallow'</code>,    #4093 by @timkpaine</li> </ul>"},{"location":"changelog/#v191-2022-05-19","title":"v1.9.1 (2022-05-19)","text":"<p>Thank you to pydantic's sponsors: @tiangolo, @stellargraph, @JonasKs, @grillazz, @Mazyod, @kevinalh, @chdsbd, @povilasb, @povilasb, @jina-ai,  @mainframeindustries, @robusta-dev, @SendCloud, @rszamszur, @jodal, @hardbyte, @corleyma, @daddycocoaman,  @Rehket, @jokull, @reillysiemens, @westonsteimel, @primer-io, @koxudaxi, @browniebroke, @stradivari96,  @adriangb, @kamalgill, @jqueguiner, @dev-zero, @datarootsio, @RedCarpetUp for their kind support.</p> <ul> <li>Limit the size of <code>generics._generic_types_cache</code> and <code>generics._assigned_parameters</code>    to avoid unlimited increase in memory usage, #4083 by @samuelcolvin</li> <li>Add Jupyverse and FPS as Jupyter projects using pydantic, #4082 by @davidbrochart</li> <li>Speedup <code>__isinstancecheck__</code> on pydantic models when the type is not a model, may also avoid memory \"leaks\", #4081 by @samuelcolvin</li> <li>Fix in-place modification of <code>FieldInfo</code> that caused problems with PEP 593 type aliases, #4067 by @adriangb</li> <li>Add support for autocomplete in VS Code via <code>__dataclass_transform__</code> when using <code>pydantic.dataclasses.dataclass</code>, #4006 by @giuliano-oliveira</li> <li>Remove benchmarks from codebase and docs, #3973 by @samuelcolvin</li> <li>Typing checking with pyright in CI, improve docs on vscode/pylance/pyright, #3972 by @samuelcolvin</li> <li>Fix nested Python dataclass schema regression, #3819 by @himbeles</li> <li>Update documentation about lazy evaluation of sources for Settings, #3806 by @garyd203</li> <li>Prevent subclasses of bytes being converted to bytes, #3706 by @samuelcolvin</li> <li>Fixed \"error checking inheritance of\" when using PEP585 and PEP604 type hints, #3681 by @aleksul</li> <li>Allow self referencing <code>ClassVar</code>s in models, #3679 by @samuelcolvin</li> <li>Breaking Change, see #4106: Fix issue with self-referencing dataclass, #3675 by @uriyyo</li> <li>Include non-standard port numbers in rendered URLs, #3652 by @dolfinus</li> <li><code>Config.copy_on_model_validation</code> does a deep copy and not a shallow one, #3641 by @PrettyWood</li> <li>fix: clarify that discriminated unions do not support singletons, #3636 by @tommilligan</li> <li>Add <code>read_text(encoding='utf-8')</code> for <code>setup.py</code>, #3625 by @hswong3i</li> <li>Fix JSON Schema generation for Discriminated Unions within lists, #3608 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v190-2021-12-31","title":"v1.9.0 (2021-12-31)","text":"<p>Thank you to pydantic's sponsors: @sthagen, @timdrijvers, @toinbis, @koxudaxi, @ginomempin, @primer-io, @and-semakin, @westonsteimel, @reillysiemens, @es3n1n, @jokull, @JonasKs, @Rehket, @corleyma, @daddycocoaman, @hardbyte, @datarootsio, @jodal, @aminalaee, @rafsaf,  @jqueguiner, @chdsbd, @kevinalh, @Mazyod, @grillazz, @JonasKs, @simw, @leynier, @xfenix for their kind support.</p>"},{"location":"changelog/#highlights","title":"Highlights","text":"<ul> <li>add Python 3.10 support, #2885 by @PrettyWood</li> <li>Discriminated unions, #619 by @PrettyWood</li> <li><code>Config.smart_union</code> for better union logic, #2092 by @PrettyWood</li> <li>Binaries for Macos M1 CPUs, #3498 by @samuelcolvin</li> <li>Complex types can be set via nested environment variables, e.g. <code>foo___bar</code>, #3159 by @Air-Mark</li> <li>add a dark mode to pydantic documentation, #2913 by @gbdlin</li> <li>Add support for autocomplete in VS Code via <code>__dataclass_transform__</code>, #2721 by @tiangolo</li> <li>Add \"exclude\" as a field parameter so that it can be configured using model config, #660 by @daviskirk</li> </ul>"},{"location":"changelog/#v190-2021-12-31-changes","title":"v1.9.0 (2021-12-31) Changes","text":"<ul> <li>Apply <code>update_forward_refs</code> to <code>Config.json_encodes</code> prevent name clashes in types defined via strings, #3583 by @samuelcolvin</li> <li>Extend pydantic's mypy plugin to support mypy versions <code>0.910</code>, <code>0.920</code>, <code>0.921</code> &amp; <code>0.930</code>, #3573 &amp; #3594 by @PrettyWood, @christianbundy, @samuelcolvin</li> </ul>"},{"location":"changelog/#v190a2-2021-12-24-changes","title":"v1.9.0a2 (2021-12-24) Changes","text":"<ul> <li>support generic models with discriminated union, #3551 by @PrettyWood</li> <li>keep old behaviour of <code>json()</code> by default, #3542 by @PrettyWood</li> <li>Removed typing-only <code>__root__</code> attribute from <code>BaseModel</code>, #3540 by @layday</li> <li>Build Python 3.10 wheels, #3539 by @mbachry</li> <li>Fix display of <code>extra</code> fields with model <code>__repr__</code>, #3234 by @cocolman</li> <li>models copied via <code>Config.copy_on_model_validation</code> always have all fields, #3201 by @PrettyWood</li> <li>nested ORM from nested dictionaries, #3182 by @PrettyWood</li> <li>fix link to discriminated union section by @PrettyWood</li> </ul>"},{"location":"changelog/#v190a1-2021-12-18-changes","title":"v1.9.0a1 (2021-12-18) Changes","text":"<ul> <li>Add support for <code>Decimal</code>-specific validation configurations in <code>Field()</code>, additionally to using <code>condecimal()</code>,    to allow better support from editors and tooling, #3507 by @tiangolo</li> <li>Add <code>arm64</code> binaries suitable for MacOS with an M1 CPU to PyPI, #3498 by @samuelcolvin</li> <li>Fix issue where <code>None</code> was considered invalid when using a <code>Union</code> type containing <code>Any</code> or <code>object</code>, #3444 by @tharradine</li> <li>When generating field schema, pass optional <code>field</code> argument (of type   <code>pydantic.fields.ModelField</code>) to <code>__modify_schema__()</code> if present, #3434 by @jasujm</li> <li>Fix issue when pydantic fail to parse <code>typing.ClassVar</code> string type annotation, #3401 by @uriyyo</li> <li>Mention Python &gt;= 3.9.2 as an alternative to <code>typing_extensions.TypedDict</code>, #3374 by @BvB93</li> <li>Changed the validator method name in the Custom Errors example    to more accurately describe what the validator is doing; changed from <code>name_must_contain_space</code> to <code>value_must_equal_bar</code>, #3327 by @michaelrios28</li> <li>Add <code>AmqpDsn</code> class, #3254 by @kludex</li> <li>Always use <code>Enum</code> value as default in generated JSON schema, #3190 by @joaommartins</li> <li>Add support for Mypy 0.920, #3175 by @christianbundy</li> <li><code>validate_arguments</code> now supports <code>extra</code> customization (used to always be <code>Extra.forbid</code>), #3161 by @PrettyWood</li> <li>Complex types can be set by nested environment variables, #3159 by @Air-Mark</li> <li>Fix mypy plugin to collect fields based on <code>pydantic.utils.is_valid_field</code> so that it ignores untyped private variables, #3146 by @hi-ogawa</li> <li>fix <code>validate_arguments</code> issue with <code>Config.validate_all</code>, #3135 by @PrettyWood</li> <li>avoid dict coercion when using dict subclasses as field type, #3122 by @PrettyWood</li> <li>add support for <code>object</code> type, #3062 by @PrettyWood</li> <li>Updates pydantic dataclasses to keep <code>_special</code> properties on parent classes, #3043 by @zulrang</li> <li>Add a <code>TypedDict</code> class for error objects, #3038 by @matthewhughes934</li> <li>Fix support for using a subclass of an annotation as a default, #3018 by @JacobHayes</li> <li>make <code>create_model_from_typeddict</code> mypy compliant, #3008 by @PrettyWood</li> <li>Make multiple inheritance work when using <code>PrivateAttr</code>, #2989 by @hmvp</li> <li>Parse environment variables as JSON, if they have a <code>Union</code> type with a complex subfield, #2936 by @cbartz</li> <li>Prevent <code>StrictStr</code> permitting <code>Enum</code> values where the enum inherits from <code>str</code>, #2929 by @samuelcolvin</li> <li>Make <code>SecretsSettingsSource</code> parse values being assigned to fields of complex types when sourced from a secrets file,    just as when sourced from environment variables, #2917 by @davidmreed</li> <li>add a dark mode to pydantic documentation, #2913 by @gbdlin</li> <li>Make <code>pydantic-mypy</code> plugin compatible with <code>pyproject.toml</code> configuration, consistent with <code>mypy</code> changes.    See the doc for more information, #2908 by @jrwalk</li> <li>add Python 3.10 support, #2885 by @PrettyWood</li> <li>Correctly parse generic models with <code>Json[T]</code>, #2860 by @geekingfrog</li> <li>Update contrib docs re: Python version to use for building docs, #2856 by @paxcodes</li> <li>Clarify documentation about pydantic's support for custom validation and strict type checking,    despite pydantic being primarily a parsing library, #2855 by @paxcodes</li> <li>Fix schema generation for <code>Deque</code> fields, #2810 by @sergejkozin</li> <li>fix an edge case when mixing constraints and <code>Literal</code>, #2794 by @PrettyWood</li> <li>Fix postponed annotation resolution for <code>NamedTuple</code> and <code>TypedDict</code> when they're used directly as the type of fields    within Pydantic models, #2760 by @jameysharp</li> <li>Fix bug when <code>mypy</code> plugin fails on <code>construct</code> method call for <code>BaseSettings</code> derived classes, #2753 by @uriyyo</li> <li>Add function overloading for a <code>pydantic.create_model</code> function, #2748 by @uriyyo</li> <li>Fix mypy plugin issue with self field declaration, #2743 by @uriyyo</li> <li>The colon at the end of the line \"The fields which were supplied when user was initialised:\" suggests that the code following it is related.   Changed it to a period, #2733 by @krisaoe</li> <li>Renamed variable <code>schema</code> to <code>schema_</code> to avoid shadowing of global variable name, #2724 by @shahriyarr</li> <li>Add support for autocomplete in VS Code via <code>__dataclass_transform__</code>, #2721 by @tiangolo</li> <li>add missing type annotations in <code>BaseConfig</code> and handle <code>max_length = 0</code>, #2719 by @PrettyWood</li> <li>Change <code>orm_mode</code> checking to allow recursive ORM mode parsing with dicts, #2718 by @nuno-andre</li> <li>Add episode 313 of the Talk Python To Me podcast, where Michael Kennedy and Samuel Colvin discuss pydantic, to the docs, #2712 by @RatulMaharaj</li> <li>fix JSON schema generation when a field is of type <code>NamedTuple</code> and has a default value, #2707 by @PrettyWood</li> <li><code>Enum</code> fields now properly support extra kwargs in schema generation, #2697 by @sammchardy</li> <li>Breaking Change, see #3780: Make serialization of referenced pydantic models possible, #2650 by @PrettyWood</li> <li>Add <code>uniqueItems</code> option to <code>ConstrainedList</code>, #2618 by @nuno-andre</li> <li>Try to evaluate forward refs automatically at model creation, #2588 by @uriyyo</li> <li>Switch docs preview and coverage display to use smokeshow, #2580 by @samuelcolvin</li> <li>Add <code>__version__</code> attribute to pydantic module, #2572 by @paxcodes</li> <li>Add <code>postgresql+asyncpg</code>, <code>postgresql+pg8000</code>, <code>postgresql+psycopg2</code>, <code>postgresql+psycopg2cffi</code>, <code>postgresql+py-postgresql</code>   and <code>postgresql+pygresql</code> schemes for <code>PostgresDsn</code>, #2567 by @postgres-asyncpg</li> <li>Enable the Hypothesis plugin to generate a constrained decimal when the <code>decimal_places</code> argument is specified, #2524 by @cwe5590</li> <li>Allow <code>collections.abc.Callable</code> to be used as type in Python 3.9, #2519 by @daviskirk</li> <li>Documentation update how to custom compile pydantic when using pip install, small change in <code>setup.py</code>    to allow for custom CFLAGS when compiling, #2517 by @peterroelants</li> <li>remove side effect of <code>default_factory</code> to run it only once even if <code>Config.validate_all</code> is set, #2515 by @PrettyWood</li> <li>Add lookahead to ip regexes for <code>AnyUrl</code> hosts. This allows urls with DNS labels   looking like IPs to validate as they are perfectly valid host names, #2512 by @sbv-csis</li> <li>Set <code>minItems</code> and <code>maxItems</code> in generated JSON schema for fixed-length tuples, #2497 by @PrettyWood</li> <li>Add <code>strict</code> argument to <code>conbytes</code>, #2489 by @koxudaxi</li> <li>Support user defined generic field types in generic models, #2465 by @daviskirk</li> <li>Add an example and a short explanation of subclassing <code>GetterDict</code> to docs, #2463 by @nuno-andre</li> <li>add <code>KafkaDsn</code> type, <code>HttpUrl</code> now has default port 80 for http and 443 for https, #2447 by @MihanixA</li> <li>Add <code>PastDate</code> and <code>FutureDate</code> types, #2425 by @Kludex</li> <li>Support generating schema for <code>Generic</code> fields with subtypes, #2375 by @maximberg</li> <li>fix(encoder): serialize <code>NameEmail</code> to str, #2341 by @alecgerona</li> <li>add <code>Config.smart_union</code> to prevent coercion in <code>Union</code> if possible, see   the doc for more information, #2092 by @PrettyWood</li> <li>Add ability to use <code>typing.Counter</code> as a model field type, #2060 by @uriyyo</li> <li>Add parameterised subclasses to <code>__bases__</code> when constructing new parameterised classes, so that <code>A &lt;: B =&gt; A[int] &lt;: B[int]</code>, #2007 by @diabolo-dan</li> <li>Create <code>FileUrl</code> type that allows URLs that conform to RFC 8089.   Add <code>host_required</code> parameter, which is <code>True</code> by default (<code>AnyUrl</code> and subclasses), <code>False</code> in <code>RedisDsn</code>, <code>FileUrl</code>, #1983 by @vgerak</li> <li>add <code>confrozenset()</code>, analogous to <code>conset()</code> and <code>conlist()</code>, #1897 by @PrettyWood</li> <li>stop calling parent class <code>root_validator</code> if overridden, #1895 by @PrettyWood</li> <li>Add <code>repr</code> (defaults to <code>True</code>) parameter to <code>Field</code>, to hide it from the default representation of the <code>BaseModel</code>, #1831 by @fnep</li> <li>Accept empty query/fragment URL parts, #1807 by @xavier</li> </ul>"},{"location":"changelog/#v182-2021-05-11","title":"v1.8.2 (2021-05-11)","text":"<p>Warning</p> <p>A security vulnerability, level \"moderate\" is fixed in v1.8.2. Please upgrade ASAP. See security advisory CVE-2021-29510</p> <ul> <li>Security fix: Fix <code>date</code> and <code>datetime</code> parsing so passing either <code>'infinity'</code> or <code>float('inf')</code>    (or their negative values) does not cause an infinite loop,    see security advisory CVE-2021-29510</li> <li>fix schema generation with Enum by generating a valid name, #2575 by @PrettyWood</li> <li>fix JSON schema generation with a <code>Literal</code> of an enum member, #2536 by @PrettyWood</li> <li>Fix bug with configurations declarations that are passed as   keyword arguments during class creation, #2532 by @uriyyo</li> <li>Allow passing <code>json_encoders</code> in class kwargs, #2521 by @layday</li> <li>support arbitrary types with custom <code>__eq__</code>, #2483 by @PrettyWood</li> <li>support <code>Annotated</code> in <code>validate_arguments</code> and in generic models with Python 3.9, #2483 by @PrettyWood</li> </ul>"},{"location":"changelog/#v181-2021-03-03","title":"v1.8.1 (2021-03-03)","text":"<p>Bug fixes for regressions and new features from <code>v1.8</code> </p> <ul> <li>allow elements of <code>Config.field</code> to update elements of a <code>Field</code>, #2461 by @samuelcolvin</li> <li>fix validation with a <code>BaseModel</code> field and a custom root type, #2449 by @PrettyWood</li> <li>expose <code>Pattern</code> encoder to <code>fastapi</code>, #2444 by @PrettyWood</li> <li>enable the Hypothesis plugin to generate a constrained float when the <code>multiple_of</code> argument is specified, #2442 by @tobi-lipede-oodle</li> <li>Avoid <code>RecursionError</code> when using some types like <code>Enum</code> or <code>Literal</code> with generic models, #2436 by @PrettyWood</li> <li>do not overwrite declared <code>__hash__</code> in subclasses of a model, #2422 by @PrettyWood</li> <li>fix <code>mypy</code> complaints on <code>Path</code> and <code>UUID</code> related custom types, #2418 by @PrettyWood</li> <li>Support properly variable length tuples of compound types, #2416 by @PrettyWood</li> </ul>"},{"location":"changelog/#v18-2021-02-26","title":"v1.8 (2021-02-26)","text":"<p>Thank you to pydantic's sponsors: @jorgecarleitao, @BCarley, @chdsbd, @tiangolo, @matin, @linusg, @kevinalh, @koxudaxi, @timdrijvers, @mkeen, @meadsteve,  @ginomempin, @primer-io, @and-semakin, @tomthorogood, @AjitZK, @westonsteimel, @Mazyod, @christippett, @CarlosDomingues,  @Kludex, @r-m-n for their kind support.</p>"},{"location":"changelog/#highlights_1","title":"Highlights","text":"<ul> <li>Hypothesis plugin for testing, #2097 by @Zac-HD</li> <li>support for <code>NamedTuple</code> and <code>TypedDict</code>, #2216 by @PrettyWood</li> <li>Support <code>Annotated</code> hints on model fields, #2147 by @JacobHayes</li> <li><code>frozen</code> parameter on <code>Config</code> to allow models to be hashed, #1880 by @rhuille</li> </ul>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Breaking Change, remove old deprecation aliases from v1, #2415 by @samuelcolvin:<ul> <li>remove notes on migrating to v1 in docs</li> <li>remove <code>Schema</code> which was replaced by <code>Field</code></li> <li>remove <code>Config.case_insensitive</code> which was replaced by <code>Config.case_sensitive</code> (default <code>False</code>)</li> <li>remove <code>Config.allow_population_by_alias</code> which was replaced by <code>Config.allow_population_by_field_name</code></li> <li>remove <code>model.fields</code> which was replaced by <code>model.__fields__</code></li> <li>remove <code>model.to_string()</code> which was replaced by <code>str(model)</code></li> <li>remove <code>model.__values__</code> which was replaced by <code>model.__dict__</code></li> </ul> </li> <li>Breaking Change: always validate only first sublevel items with <code>each_item</code>.   There were indeed some edge cases with some compound types where the validated items were the last sublevel ones, #1933 by @PrettyWood</li> <li>Update docs extensions to fix local syntax highlighting, #2400 by @daviskirk</li> <li>fix: allow <code>utils.lenient_issubclass</code> to handle <code>typing.GenericAlias</code> objects like <code>list[str]</code> in Python &gt;= 3.9, #2399 by @daviskirk</li> <li>Improve field declaration for pydantic <code>dataclass</code> by allowing the usage of pydantic <code>Field</code> or <code>'metadata'</code> kwarg of <code>dataclasses.field</code>, #2384 by @PrettyWood</li> <li>Making <code>typing-extensions</code> a required dependency, #2368 by @samuelcolvin</li> <li>Make <code>resolve_annotations</code> more lenient, allowing for missing modules, #2363 by @samuelcolvin</li> <li>Allow configuring models through class kwargs, #2356 by @Bobronium</li> <li>Prevent <code>Mapping</code> subclasses from always being coerced to <code>dict</code>, #2325 by @ofek</li> <li>fix: allow <code>None</code> for type <code>Optional[conset / conlist]</code>, #2320 by @PrettyWood</li> <li>Support empty tuple type, #2318 by @PrettyWood</li> <li>fix: <code>python_requires</code> metadata to require &gt;=3.6.1, #2306 by @hukkinj1</li> <li>Properly encode <code>Decimal</code> with, or without any decimal places, #2293 by @hultner</li> <li>fix: update <code>__fields_set__</code> in <code>BaseModel.copy(update=\u2026)</code>, #2290 by @PrettyWood</li> <li>fix: keep order of fields with <code>BaseModel.construct()</code>, #2281 by @PrettyWood</li> <li>Support generating schema for Generic fields, #2262 by @maximberg</li> <li>Fix <code>validate_decorator</code> so <code>**kwargs</code> doesn't exclude values when the keyword   has the same name as the <code>*args</code> or <code>**kwargs</code> names, #2251 by @cybojenix</li> <li>Prevent overriding positional arguments with keyword arguments in   <code>validate_arguments</code>, as per behaviour with native functions, #2249 by @cybojenix</li> <li>add documentation for <code>con*</code> type functions, #2242 by @tayoogunbiyi</li> <li>Support custom root type (aka <code>__root__</code>) when using <code>parse_obj()</code> with nested models, #2238 by @PrettyWood</li> <li>Support custom root type (aka <code>__root__</code>) with <code>from_orm()</code>, #2237 by @PrettyWood</li> <li>ensure cythonized functions are left untouched when creating models, based on #1944 by @kollmats, #2228 by @samuelcolvin</li> <li>Resolve forward refs for stdlib dataclasses converted into pydantic ones, #2220 by @PrettyWood</li> <li>Add support for <code>NamedTuple</code> and <code>TypedDict</code> types.   Those two types are now handled and validated when used inside <code>BaseModel</code> or pydantic <code>dataclass</code>.   Two utils are also added <code>create_model_from_namedtuple</code> and <code>create_model_from_typeddict</code>, #2216 by @PrettyWood</li> <li>Do not ignore annotated fields when type is <code>Union[Type[...], ...]</code>, #2213 by @PrettyWood</li> <li>Raise a user-friendly <code>TypeError</code> when a <code>root_validator</code> does not return a <code>dict</code> (e.g. <code>None</code>), #2209 by @masalim2</li> <li>Add a <code>FrozenSet[str]</code> type annotation to the <code>allowed_schemes</code> argument on the <code>strict_url</code> field type, #2198 by @Midnighter</li> <li>add <code>allow_mutation</code> constraint to <code>Field</code>, #2195 by @sblack-usu</li> <li>Allow <code>Field</code> with a <code>default_factory</code> to be used as an argument to a function   decorated with <code>validate_arguments</code>, #2176 by @thomascobb</li> <li>Allow non-existent secrets directory by only issuing a warning, #2175 by @davidolrik</li> <li>fix URL regex to parse fragment without query string, #2168 by @andrewmwhite</li> <li>fix: ensure to always return one of the values in <code>Literal</code> field type, #2166 by @PrettyWood</li> <li>Support <code>typing.Annotated</code> hints on model fields. A <code>Field</code> may now be set in the type hint with <code>Annotated[..., Field(...)</code>; all other annotations are ignored but still visible with <code>get_type_hints(..., include_extras=True)</code>, #2147 by @JacobHayes</li> <li>Added <code>StrictBytes</code> type as well as <code>strict=False</code> option to <code>ConstrainedBytes</code>, #2136 by @rlizzo</li> <li>added <code>Config.anystr_lower</code> and <code>to_lower</code> kwarg to <code>constr</code> and <code>conbytes</code>, #2134 by @tayoogunbiyi</li> <li>Support plain <code>typing.Tuple</code> type, #2132 by @PrettyWood</li> <li>Add a bound method <code>validate</code> to functions decorated with <code>validate_arguments</code>   to validate parameters without actually calling the function, #2127 by @PrettyWood</li> <li>Add the ability to customize settings sources (add / disable / change priority order), #2107 by @kozlek</li> <li>Fix mypy complaints about most custom pydantic types, #2098 by @PrettyWood</li> <li>Add a Hypothesis plugin for easier property-based testing with Pydantic's custom types - usage details here, #2097 by @Zac-HD</li> <li>add validator for <code>None</code>, <code>NoneType</code> or <code>Literal[None]</code>, #2095 by @PrettyWood</li> <li>Handle properly fields of type <code>Callable</code> with a default value, #2094 by @PrettyWood</li> <li>Updated <code>create_model</code> return type annotation to return type which inherits from <code>__base__</code> argument, #2071 by @uriyyo</li> <li>Add merged <code>json_encoders</code> inheritance, #2064 by @art049</li> <li>allow overwriting <code>ClassVar</code>s in sub-models without having to re-annotate them, #2061 by @layday</li> <li>add default encoder for <code>Pattern</code> type, #2045 by @PrettyWood</li> <li>Add <code>NonNegativeInt</code>, <code>NonPositiveInt</code>, <code>NonNegativeFloat</code>, <code>NonPositiveFloat</code>, #1975 by @mdavis-xyz</li> <li>Use % for percentage in string format of colors, #1960 by @EdwardBetts</li> <li>Fixed issue causing <code>KeyError</code> to be raised when building schema from multiple <code>BaseModel</code> with the same names declared in separate classes, #1912 by @JSextonn</li> <li>Add <code>rediss</code> (Redis over SSL) protocol to <code>RedisDsn</code>   Allow URLs without <code>user</code> part (e.g., <code>rediss://:pass@localhost</code>), #1911 by @TrDex</li> <li>Add a new <code>frozen</code> boolean parameter to <code>Config</code> (default: <code>False</code>).   Setting <code>frozen=True</code> does everything that <code>allow_mutation=False</code> does, and also generates a <code>__hash__()</code> method for the model. This makes instances of the model potentially hashable if all the attributes are hashable, #1880 by @rhuille</li> <li>fix schema generation with multiple Enums having the same name, #1857 by @PrettyWood</li> <li>Added support for 13/19 digits VISA credit cards in <code>PaymentCardNumber</code> type, #1416 by @AlexanderSov</li> <li>fix: prevent <code>RecursionError</code> while using recursive <code>GenericModel</code>s, #1370 by @xppt</li> <li>use <code>enum</code> for <code>typing.Literal</code> in JSON schema, #1350 by @PrettyWood</li> <li>Fix: some recursive models did not require <code>update_forward_refs</code> and silently behaved incorrectly, #1201 by @PrettyWood</li> <li>Fix bug where generic models with fields where the typevar is nested in another type <code>a: List[T]</code> are considered to be concrete. This allows these models to be subclassed and composed as expected, #947 by @daviskirk</li> <li>Add <code>Config.copy_on_model_validation</code> flag. When set to <code>False</code>, pydantic will keep models used as fields   untouched on validation instead of reconstructing (copying) them, #265 by @PrettyWood</li> </ul>"},{"location":"changelog/#v174-2021-05-11","title":"v1.7.4 (2021-05-11)","text":"<ul> <li>Security fix: Fix <code>date</code> and <code>datetime</code> parsing so passing either <code>'infinity'</code> or <code>float('inf')</code>    (or their negative values) does not cause an infinite loop,   See security advisory CVE-2021-29510</li> </ul>"},{"location":"changelog/#v173-2020-11-30","title":"v1.7.3 (2020-11-30)","text":"<p>Thank you to pydantic's sponsors: @timdrijvers, @BCarley, @chdsbd, @tiangolo, @matin, @linusg, @kevinalh, @jorgecarleitao, @koxudaxi, @primer-api, @mkeen, @meadsteve for their kind support.</p> <ul> <li>fix: set right default value for required (optional) fields, #2142 by @PrettyWood</li> <li>fix: support <code>underscore_attrs_are_private</code> with generic models, #2138 by @PrettyWood</li> <li>fix: update all modified field values in <code>root_validator</code> when <code>validate_assignment</code> is on, #2116 by @PrettyWood</li> <li>Allow pickling of <code>pydantic.dataclasses.dataclass</code> dynamically created from a built-in <code>dataclasses.dataclass</code>, #2111 by @aimestereo</li> <li>Fix a regression where Enum fields would not propagate keyword arguments to the schema, #2109 by @bm424</li> <li>Ignore <code>__doc__</code> as private attribute when <code>Config.underscore_attrs_are_private</code> is set, #2090 by @PrettyWood</li> </ul>"},{"location":"changelog/#v172-2020-11-01","title":"v1.7.2 (2020-11-01)","text":"<ul> <li>fix slow <code>GenericModel</code> concrete model creation, allow <code>GenericModel</code> concrete name reusing in module, #2078 by @Bobronium</li> <li>keep the order of the fields when <code>validate_assignment</code> is set, #2073 by @PrettyWood</li> <li>forward all the params of the stdlib <code>dataclass</code> when converted into pydantic <code>dataclass</code>, #2065 by @PrettyWood</li> </ul>"},{"location":"changelog/#v171-2020-10-28","title":"v1.7.1 (2020-10-28)","text":"<p>Thank you to pydantic's sponsors: @timdrijvers, @BCarley, @chdsbd, @tiangolo, @matin, @linusg, @kevinalh, @jorgecarleitao, @koxudaxi, @primer-api, @mkeen for their kind support.</p> <ul> <li>fix annotation of <code>validate_arguments</code> when passing configuration as argument, #2055 by @layday</li> <li>Fix mypy assignment error when using <code>PrivateAttr</code>, #2048 by @aphedges</li> <li>fix <code>underscore_attrs_are_private</code> causing <code>TypeError</code> when overriding <code>__init__</code>, #2047 by @samuelcolvin</li> <li>Fixed regression introduced in v1.7 involving exception handling in field validators when <code>validate_assignment=True</code>, #2044 by @johnsabath</li> <li>fix: pydantic <code>dataclass</code> can inherit from stdlib <code>dataclass</code>   and <code>Config.arbitrary_types_allowed</code> is supported, #2042 by @PrettyWood</li> </ul>"},{"location":"changelog/#v17-2020-10-26","title":"v1.7 (2020-10-26)","text":"<p>Thank you to pydantic's sponsors: @timdrijvers, @BCarley, @chdsbd, @tiangolo, @matin, @linusg, @kevinalh, @jorgecarleitao, @koxudaxi, @primer-api  for their kind support.</p>"},{"location":"changelog/#highlights_2","title":"Highlights","text":"<ul> <li>Python 3.9 support, thanks @PrettyWood</li> <li>Private model attributes, thanks @Bobronium</li> <li>\"secrets files\" support in <code>BaseSettings</code>, thanks @mdgilene</li> <li>convert stdlib dataclasses to pydantic dataclasses and use stdlib dataclasses in models, thanks @PrettyWood</li> </ul>"},{"location":"changelog/#changes_1","title":"Changes","text":"<ul> <li>Breaking Change: remove <code>__field_defaults__</code>, add <code>default_factory</code> support with <code>BaseModel.construct</code>.   Use <code>.get_default()</code> method on fields in <code>__fields__</code> attribute instead, #1732 by @PrettyWood</li> <li>Rearrange CI to run linting as a separate job, split install recipes for different tasks, #2020 by @samuelcolvin</li> <li>Allows subclasses of generic models to make some, or all, of the superclass's type parameters concrete, while    also defining new type parameters in the subclass, #2005 by @choogeboom</li> <li>Call validator with the correct <code>values</code> parameter type in <code>BaseModel.__setattr__</code>,   when <code>validate_assignment = True</code> in model config, #1999 by @me-ransh</li> <li>Force <code>fields.Undefined</code> to be a singleton object, fixing inherited generic model schemas, #1981 by @daviskirk</li> <li>Include tests in source distributions, #1976 by @sbraz</li> <li>Add ability to use <code>min_length/max_length</code> constraints with secret types, #1974 by @uriyyo</li> <li>Also check <code>root_validators</code> when <code>validate_assignment</code> is on, #1971 by @PrettyWood</li> <li>Fix const validators not running when custom validators are present, #1957 by @hmvp</li> <li>add <code>deque</code> to field types, #1935 by @wozniakty</li> <li>add basic support for Python 3.9, #1832 by @PrettyWood</li> <li>Fix typo in the anchor of exporting_models.md#modelcopy and incorrect description, #1821 by @KimMachineGun</li> <li>Added ability for <code>BaseSettings</code> to read \"secret files\", #1820 by @mdgilene</li> <li>add <code>parse_raw_as</code> utility function, #1812 by @PrettyWood</li> <li>Support home directory relative paths for <code>dotenv</code> files (e.g. <code>~/.env</code>), #1803 by @PrettyWood</li> <li>Clarify documentation for <code>parse_file</code> to show that the argument   should be a file path not a file-like object, #1794 by @mdavis-xyz</li> <li>Fix false positive from mypy plugin when a class nested within a <code>BaseModel</code> is named <code>Model</code>, #1770 by @selimb</li> <li>add basic support of Pattern type in schema generation, #1767 by @PrettyWood</li> <li>Support custom title, description and default in schema of enums, #1748 by @PrettyWood</li> <li>Properly represent <code>Literal</code> Enums when <code>use_enum_values</code> is True, #1747 by @noelevans</li> <li>Allows timezone information to be added to strings to be formatted as time objects. Permitted formats are <code>Z</code> for UTC    or an offset for absolute positive or negative time shifts. Or the timezone data can be omitted, #1744 by @noelevans</li> <li>Add stub <code>__init__</code> with Python 3.6 signature for <code>ForwardRef</code>, #1738 by @sirtelemak</li> <li>Fix behaviour with forward refs and optional fields in nested models, #1736 by @PrettyWood</li> <li>add <code>Enum</code> and <code>IntEnum</code> as valid types for fields, #1735 by @PrettyWood</li> <li>Change default value of <code>__module__</code> argument of <code>create_model</code> from <code>None</code> to <code>'pydantic.main'</code>.    Set reference of created concrete model to it's module to allow pickling (not applied to models created in    functions), #1686 by @Bobronium</li> <li>Add private attributes support, #1679 by @Bobronium</li> <li>add <code>config</code> to <code>@validate_arguments</code>, #1663 by @samuelcolvin</li> <li>Allow descendant Settings models to override env variable names for the fields defined in parent Settings models with    <code>env</code> in their <code>Config</code>. Previously only <code>env_prefix</code> configuration option was applicable, #1561 by @ojomio</li> <li>Support <code>ref_template</code> when creating schema <code>$ref</code>s, #1479 by @kilo59</li> <li>Add a <code>__call__</code> stub to <code>PyObject</code> so that mypy will know that it is callable, #1352 by @brianmaissy</li> <li><code>pydantic.dataclasses.dataclass</code> decorator now supports built-in <code>dataclasses.dataclass</code>.   It is hence possible to convert an existing <code>dataclass</code> easily to add pydantic validation.   Moreover nested dataclasses are also supported, #744 by @PrettyWood</li> </ul>"},{"location":"changelog/#v162-2021-05-11","title":"v1.6.2 (2021-05-11)","text":"<ul> <li>Security fix: Fix <code>date</code> and <code>datetime</code> parsing so passing either <code>'infinity'</code> or <code>float('inf')</code>    (or their negative values) does not cause an infinite loop,   See security advisory CVE-2021-29510</li> </ul>"},{"location":"changelog/#v161-2020-07-15","title":"v1.6.1 (2020-07-15)","text":"<ul> <li>fix validation and parsing of nested models with <code>default_factory</code>, #1710 by @PrettyWood</li> </ul>"},{"location":"changelog/#v16-2020-07-11","title":"v1.6 (2020-07-11)","text":"<p>Thank you to pydantic's sponsors: @matin, @tiangolo, @chdsbd, @jorgecarleitao, and 1 anonymous sponsor for their kind support.</p> <ul> <li>Modify validators for <code>conlist</code> and <code>conset</code> to not have <code>always=True</code>, #1682 by @samuelcolvin</li> <li>add port check to <code>AnyUrl</code> (can't exceed 65536) ports are 16 insigned bits: <code>0 &lt;= port &lt;= 2**16-1</code> src: rfc793 header format, #1654 by @flapili</li> <li>Document default <code>regex</code> anchoring semantics, #1648 by @yurikhan</li> <li>Use <code>chain.from_iterable</code> in class_validators.py. This is a faster and more idiomatic way of using <code>itertools.chain</code>.   Instead of computing all the items in the iterable and storing them in memory, they are computed one-by-one and never   stored as a huge list. This can save on both runtime and memory space, #1642 by @cool-RR</li> <li>Add <code>conset()</code>, analogous to <code>conlist()</code>, #1623 by @patrickkwang</li> <li>make pydantic errors (un)pickable, #1616 by @PrettyWood</li> <li>Allow custom encoding for <code>dotenv</code> files, #1615 by @PrettyWood</li> <li>Ensure <code>SchemaExtraCallable</code> is always defined to get type hints on BaseConfig, #1614 by @PrettyWood</li> <li>Update datetime parser to support negative timestamps, #1600 by @mlbiche</li> <li>Update mypy, remove <code>AnyType</code> alias for <code>Type[Any]</code>, #1598 by @samuelcolvin</li> <li>Adjust handling of root validators so that errors are aggregated from all failing root validators, instead of reporting on only the first root validator to fail, #1586 by @beezee</li> <li>Make <code>__modify_schema__</code> on Enums apply to the enum schema rather than fields that use the enum, #1581 by @therefromhere</li> <li>Fix behavior of <code>__all__</code> key when used in conjunction with index keys in advanced include/exclude of fields that are sequences, #1579 by @xspirus</li> <li>Subclass validators do not run when referencing a <code>List</code> field defined in a parent class when <code>each_item=True</code>. Added an example to the docs illustrating this, #1566 by @samueldeklund</li> <li>change <code>schema.field_class_to_schema</code> to support <code>frozenset</code> in schema, #1557 by @wangpeibao</li> <li>Call <code>__modify_schema__</code> only for the field schema, #1552 by @PrettyWood</li> <li>Move the assignment of <code>field.validate_always</code> in <code>fields.py</code> so the <code>always</code> parameter of validators work on inheritance, #1545 by @dcHHH</li> <li>Added support for UUID instantiation through 16 byte strings such as <code>b'\\x12\\x34\\x56\\x78' * 4</code>. This was done to support <code>BINARY(16)</code> columns in sqlalchemy, #1541 by @shawnwall</li> <li>Add a test assertion that <code>default_factory</code> can return a singleton, #1523 by @therefromhere</li> <li>Add <code>NameEmail.__eq__</code> so duplicate <code>NameEmail</code> instances are evaluated as equal, #1514 by @stephen-bunn</li> <li>Add datamodel-code-generator link in pydantic document site, #1500 by @koxudaxi</li> <li>Added a \"Discussion of Pydantic\" section to the documentation, with a link to \"Pydantic Introduction\" video by Alexander Hultn\u00e9r, #1499 by @hultner</li> <li>Avoid some side effects of <code>default_factory</code> by calling it only once   if possible and by not setting a default value in the schema, #1491 by @PrettyWood</li> <li>Added docs about dumping dataclasses to JSON, #1487 by @mikegrima</li> <li>Make <code>BaseModel.__signature__</code> class-only, so getting <code>__signature__</code> from model instance will raise <code>AttributeError</code>, #1466 by @Bobronium</li> <li>include <code>'format': 'password'</code> in the schema for secret types, #1424 by @atheuz</li> <li>Modify schema constraints on <code>ConstrainedFloat</code> so that <code>exclusiveMinimum</code> and   minimum are not included in the schema if they are equal to <code>-math.inf</code> and   <code>exclusiveMaximum</code> and <code>maximum</code> are not included if they are equal to <code>math.inf</code>, #1417 by @vdwees</li> <li>Squash internal <code>__root__</code> dicts in <code>.dict()</code> (and, by extension, in <code>.json()</code>), #1414 by @patrickkwang</li> <li>Move <code>const</code> validator to post-validators so it validates the parsed value, #1410 by @selimb</li> <li>Fix model validation to handle nested literals, e.g. <code>Literal['foo', Literal['bar']]</code>, #1364 by @DBCerigo</li> <li>Remove <code>user_required = True</code> from <code>RedisDsn</code>, neither user nor password are required, #1275 by @samuelcolvin</li> <li>Remove extra <code>allOf</code> from schema for fields with <code>Union</code> and custom <code>Field</code>, #1209 by @mostaphaRoudsari</li> <li>Updates OpenAPI schema generation to output all enums as separate models.   Instead of inlining the enum values in the model schema, models now use a <code>$ref</code>   property to point to the enum definition, #1173 by @calvinwyoung</li> </ul>"},{"location":"changelog/#v151-2020-04-23","title":"v1.5.1 (2020-04-23)","text":"<ul> <li>Signature generation with <code>extra: allow</code> never uses a field name, #1418 by @prettywood</li> <li>Avoid mutating <code>Field</code> default value, #1412 by @prettywood</li> </ul>"},{"location":"changelog/#v15-2020-04-18","title":"v1.5 (2020-04-18)","text":"<ul> <li>Make includes/excludes arguments for <code>.dict()</code>, <code>._iter()</code>, ..., immutable, #1404 by @AlexECX</li> <li>Always use a field's real name with includes/excludes in <code>model._iter()</code>, regardless of <code>by_alias</code>, #1397 by @AlexECX</li> <li>Update constr regex example to include start and end lines, #1396 by @lmcnearney</li> <li>Confirm that shallow <code>model.copy()</code> does make a shallow copy of attributes, #1383 by @samuelcolvin</li> <li>Renaming <code>model_name</code> argument of <code>main.create_model()</code> to <code>__model_name</code> to allow using <code>model_name</code> as a field name, #1367 by @kittipatv</li> <li>Replace raising of exception to silent passing  for non-Var attributes in mypy plugin, #1345 by @b0g3r</li> <li>Remove <code>typing_extensions</code> dependency for Python 3.8, #1342 by @prettywood</li> <li>Make <code>SecretStr</code> and <code>SecretBytes</code> initialization idempotent, #1330 by @atheuz</li> <li>document making secret types dumpable using the json method, #1328 by @atheuz</li> <li>Move all testing and build to github actions, add windows and macos binaries,    thank you @StephenBrown2 for much help, #1326 by @samuelcolvin</li> <li>fix card number length check in <code>PaymentCardNumber</code>, <code>PaymentCardBrand</code> now inherits from <code>str</code>, #1317 by @samuelcolvin</li> <li>Have <code>BaseModel</code> inherit from <code>Representation</code> to make mypy happy when overriding <code>__str__</code>, #1310 by @FuegoFro</li> <li>Allow <code>None</code> as input to all optional list fields, #1307 by @prettywood</li> <li>Add <code>datetime</code> field to <code>default_factory</code> example, #1301 by @StephenBrown2</li> <li>Allow subclasses of known types to be encoded with superclass encoder, #1291 by @StephenBrown2</li> <li>Exclude exported fields from all elements of a list/tuple of submodels/dicts with <code>'__all__'</code>, #1286 by @masalim2</li> <li>Add pydantic.color.Color objects as available input for Color fields, #1258 by @leosussan</li> <li>In examples, type nullable fields as <code>Optional</code>, so that these are valid mypy annotations, #1248 by @kokes</li> <li>Make <code>pattern_validator()</code> accept pre-compiled <code>Pattern</code> objects. Fix <code>str_validator()</code> return type to <code>str</code>, #1237 by @adamgreg</li> <li>Document how to manage Generics and inheritance, #1229 by @esadruhn</li> <li><code>update_forward_refs()</code> method of BaseModel now copies <code>__dict__</code> of class module instead of modyfying it, #1228 by @paul-ilyin</li> <li>Support instance methods and class methods with <code>@validate_arguments</code>, #1222 by @samuelcolvin</li> <li>Add <code>default_factory</code> argument to <code>Field</code> to create a dynamic default value by passing a zero-argument callable, #1210 by @prettywood</li> <li>add support for <code>NewType</code> of <code>List</code>, <code>Optional</code>, etc, #1207 by @Kazy</li> <li>fix mypy signature for <code>root_validator</code>, #1192 by @samuelcolvin</li> <li>Fixed parsing of nested 'custom root type' models, #1190 by @Shados</li> <li>Add <code>validate_arguments</code> function decorator which checks the arguments to a function matches type annotations, #1179 by @samuelcolvin</li> <li>Add <code>__signature__</code> to models, #1034 by @Bobronium</li> <li>Refactor <code>._iter()</code> method, 10x speed boost for <code>dict(model)</code>, #1017 by @Bobronium</li> </ul>"},{"location":"changelog/#v14-2020-01-24","title":"v1.4 (2020-01-24)","text":"<ul> <li>Breaking Change: alias precedence logic changed so aliases on a field always take priority over   an alias from <code>alias_generator</code> to avoid buggy/unexpected behaviour,   see here for details, #1178 by @samuelcolvin</li> <li>Add support for unicode and punycode in TLDs, #1182 by @jamescurtin</li> <li>Fix <code>cls</code> argument in validators during assignment, #1172 by @samuelcolvin</li> <li>completing Luhn algorithm for <code>PaymentCardNumber</code>, #1166 by @cuencandres</li> <li>add support for generics that implement <code>__get_validators__</code> like a custom data type, #1159 by @tiangolo</li> <li>add support for infinite generators with <code>Iterable</code>, #1152 by @tiangolo</li> <li>fix <code>url_regex</code> to accept schemas with <code>+</code>, <code>-</code> and <code>.</code> after the first character, #1142 by @samuelcolvin</li> <li>move <code>version_info()</code> to <code>version.py</code>, suggest its use in issues, #1138 by @samuelcolvin</li> <li>Improve pydantic import time by roughly 50% by deferring some module loading and regex compilation, #1127 by @samuelcolvin</li> <li>Fix <code>EmailStr</code> and <code>NameEmail</code> to accept instances of themselves in cython, #1126 by @koxudaxi</li> <li>Pass model class to the <code>Config.schema_extra</code> callable, #1125 by @therefromhere</li> <li>Fix regex for username and password in URLs, #1115 by @samuelcolvin</li> <li>Add support for nested generic models, #1104 by @dmontagu</li> <li>add <code>__all__</code> to <code>__init__.py</code> to prevent \"implicit reexport\" errors from mypy, #1072 by @samuelcolvin</li> <li>Add support for using \"dotenv\" files with <code>BaseSettings</code>, #1011 by @acnebs</li> </ul>"},{"location":"changelog/#v13-2019-12-21","title":"v1.3 (2019-12-21)","text":"<ul> <li>Change <code>schema</code> and <code>schema_model</code> to handle dataclasses by using their <code>__pydantic_model__</code> feature, #792 by @aviramha</li> <li>Added option for <code>root_validator</code> to be skipped if values validation fails using keyword <code>skip_on_failure=True</code>, #1049 by @aviramha</li> <li>Allow <code>Config.schema_extra</code> to be a callable so that the generated schema can be post-processed, #1054 by @selimb</li> <li>Update mypy to version 0.750, #1057 by @dmontagu</li> <li>Trick Cython into allowing str subclassing, #1061 by @skewty</li> <li>Prevent type attributes being added to schema unless the attribute <code>__schema_attributes__</code> is <code>True</code>, #1064 by @samuelcolvin</li> <li>Change <code>BaseModel.parse_file</code> to use <code>Config.json_loads</code>, #1067 by @kierandarcy</li> <li>Fix for optional <code>Json</code> fields, #1073 by @volker48</li> <li>Change the default number of threads used when compiling with cython to one,   allow override via the <code>CYTHON_NTHREADS</code> environment variable, #1074 by @samuelcolvin</li> <li>Run FastAPI tests during Pydantic's CI tests, #1075 by @tiangolo</li> <li>My mypy strictness constraints, and associated tweaks to type annotations, #1077 by @samuelcolvin</li> <li>Add <code>__eq__</code> to SecretStr and SecretBytes to allow \"value equals\", #1079 by @sbv-trueenergy</li> <li>Fix schema generation for nested None case, #1088 by @lutostag</li> <li>Consistent checks for sequence like objects, #1090 by @samuelcolvin</li> <li>Fix <code>Config</code> inheritance on <code>BaseSettings</code> when used with <code>env_prefix</code>, #1091 by @samuelcolvin</li> <li>Fix for <code>__modify_schema__</code> when it conflicted with <code>field_class_to_schema*</code>, #1102 by @samuelcolvin</li> <li>docs: Fix explanation of case sensitive environment variable names when populating <code>BaseSettings</code> subclass attributes, #1105 by @tribals</li> <li>Rename django-rest-framework benchmark in documentation, #1119 by @frankie567</li> </ul>"},{"location":"changelog/#v12-2019-11-28","title":"v1.2 (2019-11-28)","text":"<ul> <li>Possible Breaking Change: Add support for required <code>Optional</code> with <code>name: Optional[AnyType] = Field(...)</code>   and refactor <code>ModelField</code> creation to preserve <code>required</code> parameter value, #1031 by @tiangolo;   see here for details</li> <li>Add benchmarks for <code>cattrs</code>, #513 by @sebastianmika</li> <li>Add <code>exclude_none</code> option to <code>dict()</code> and friends, #587 by @niknetniko</li> <li>Add benchmarks for <code>valideer</code>, #670 by @gsakkis</li> <li>Add <code>parse_obj_as</code> and <code>parse_file_as</code> functions for ad-hoc parsing of data into arbitrary pydantic-compatible types, #934 by @dmontagu</li> <li>Add <code>allow_reuse</code> argument to validators, thus allowing validator reuse, #940 by @dmontagu</li> <li>Add support for mapping types for custom root models, #958 by @dmontagu</li> <li>Mypy plugin support for dataclasses, #966 by @koxudaxi</li> <li>Add support for dataclasses default factory, #968 by @ahirner</li> <li>Add a <code>ByteSize</code> type for converting byte string (<code>1GB</code>) to plain bytes, #977 by @dgasmith</li> <li>Fix mypy complaint about <code>@root_validator(pre=True)</code>, #984 by @samuelcolvin</li> <li>Add manylinux binaries for Python 3.8 to pypi, also support manylinux2010, #994 by @samuelcolvin</li> <li>Adds ByteSize conversion to another unit, #995 by @dgasmith</li> <li>Fix <code>__str__</code> and <code>__repr__</code> inheritance for models, #1022 by @samuelcolvin</li> <li>add testimonials section to docs, #1025 by @sullivancolin</li> <li>Add support for <code>typing.Literal</code> for Python 3.8, #1026 by @dmontagu</li> </ul>"},{"location":"changelog/#v111-2019-11-20","title":"v1.1.1 (2019-11-20)","text":"<ul> <li>Fix bug where use of complex fields on sub-models could cause fields to be incorrectly configured, #1015 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v11-2019-11-07","title":"v1.1 (2019-11-07)","text":"<ul> <li>Add a mypy plugin for type checking <code>BaseModel.__init__</code> and more, #722 by @dmontagu</li> <li>Change return type typehint for <code>GenericModel.__class_getitem__</code> to prevent PyCharm warnings, #936 by @dmontagu</li> <li>Fix usage of <code>Any</code> to allow <code>None</code>, also support <code>TypeVar</code> thus allowing use of un-parameterised collection types   e.g. <code>Dict</code> and <code>List</code>, #962 by @samuelcolvin</li> <li>Set <code>FieldInfo</code> on subfields to fix schema generation for complex nested types, #965 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v10-2019-10-23","title":"v1.0 (2019-10-23)","text":"<ul> <li>Breaking Change: deprecate the <code>Model.fields</code> property, use <code>Model.__fields__</code> instead, #883 by @samuelcolvin</li> <li>Breaking Change: Change the precedence of aliases so child model aliases override parent aliases,   including using <code>alias_generator</code>, #904 by @samuelcolvin</li> <li>Breaking change: Rename <code>skip_defaults</code> to <code>exclude_unset</code>, and add ability to exclude actual defaults, #915 by @dmontagu</li> <li>Add <code>**kwargs</code> to <code>pydantic.main.ModelMetaclass.__new__</code> so <code>__init_subclass__</code> can take custom parameters on extended   <code>BaseModel</code> classes, #867 by @retnikt</li> <li>Fix field of a type that has a default value, #880 by @koxudaxi</li> <li>Use <code>FutureWarning</code> instead of <code>DeprecationWarning</code> when <code>alias</code> instead of <code>env</code> is used for settings models, #881 by @samuelcolvin</li> <li>Fix issue with <code>BaseSettings</code> inheritance and <code>alias</code> getting set to <code>None</code>, #882 by @samuelcolvin</li> <li>Modify <code>__repr__</code> and <code>__str__</code> methods to be consistent across all public classes, add <code>__pretty__</code> to support   python-devtools, #884 by @samuelcolvin</li> <li>deprecation warning for <code>case_insensitive</code> on <code>BaseSettings</code> config, #885 by @samuelcolvin</li> <li>For <code>BaseSettings</code> merge environment variables and in-code values recursively, as long as they create a valid object   when merged together, to allow splitting init arguments, #888 by @idmitrievsky</li> <li>change secret types example, #890 by @ashears</li> <li>Change the signature of <code>Model.construct()</code> to be more user-friendly, document <code>construct()</code> usage, #898 by @samuelcolvin</li> <li>Add example for the <code>construct()</code> method, #907 by @ashears</li> <li>Improve use of <code>Field</code> constraints on complex types, raise an error if constraints are not enforceable,   also support tuples with an ellipsis <code>Tuple[X, ...]</code>, <code>Sequence</code> and <code>FrozenSet</code> in schema, #909 by @samuelcolvin</li> <li>update docs for bool missing valid value, #911 by @trim21</li> <li>Better <code>str</code>/<code>repr</code> logic for <code>ModelField</code>, #912 by @samuelcolvin</li> <li>Fix <code>ConstrainedList</code>, update schema generation to reflect <code>min_items</code> and <code>max_items</code> <code>Field()</code> arguments, #917 by @samuelcolvin</li> <li>Allow abstracts sets (eg. dict keys) in the <code>include</code> and <code>exclude</code> arguments of <code>dict()</code>, #921 by @samuelcolvin</li> <li>Fix JSON serialization errors on <code>ValidationError.json()</code> by using <code>pydantic_encoder</code>, #922 by @samuelcolvin</li> <li>Clarify usage of <code>remove_untouched</code>, improve error message for types with no validators, #926 by @retnikt</li> </ul>"},{"location":"changelog/#v10b2-2019-10-07","title":"v1.0b2 (2019-10-07)","text":"<ul> <li>Mark <code>StrictBool</code> typecheck as <code>bool</code> to allow for default values without mypy errors, #690 by @dmontagu</li> <li>Transfer the documentation build from sphinx to mkdocs, re-write much of the documentation, #856 by @samuelcolvin</li> <li>Add support for custom naming schemes for <code>GenericModel</code> subclasses, #859 by @dmontagu</li> <li>Add <code>if TYPE_CHECKING:</code> to the excluded lines for test coverage, #874 by @dmontagu</li> <li>Rename <code>allow_population_by_alias</code> to <code>allow_population_by_field_name</code>, remove unnecessary warning about it, #875 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v10b1-2019-10-01","title":"v1.0b1 (2019-10-01)","text":"<ul> <li>Breaking Change: rename <code>Schema</code> to <code>Field</code>, make it a function to placate mypy, #577 by @samuelcolvin</li> <li>Breaking Change: modify parsing behavior for <code>bool</code>, #617 by @dmontagu</li> <li>Breaking Change: <code>get_validators</code> is no longer recognised, use <code>__get_validators__</code>.   <code>Config.ignore_extra</code> and <code>Config.allow_extra</code> are no longer recognised, use <code>Config.extra</code>, #720 by @samuelcolvin</li> <li>Breaking Change: modify default config settings for <code>BaseSettings</code>; <code>case_insensitive</code> renamed to <code>case_sensitive</code>,   default changed to <code>case_sensitive = False</code>, <code>env_prefix</code> default changed to <code>''</code> - e.g. no prefix, #721 by @dmontagu</li> <li>Breaking change: Implement <code>root_validator</code> and rename root errors from <code>__obj__</code> to <code>__root__</code>, #729 by @samuelcolvin</li> <li>Breaking Change: alter the behaviour of <code>dict(model)</code> so that sub-models are nolonger   converted to dictionaries, #733 by @samuelcolvin</li> <li>Breaking change: Added <code>initvars</code> support to <code>post_init_post_parse</code>, #748 by @Raphael-C-Almeida</li> <li>Breaking Change: Make <code>BaseModel.json()</code> only serialize the <code>__root__</code> key for models with custom root, #752 by @dmontagu</li> <li>Breaking Change: complete rewrite of <code>URL</code> parsing logic, #755 by @samuelcolvin</li> <li>Breaking Change: preserve superclass annotations for field-determination when not provided in subclass, #757 by @dmontagu</li> <li>Breaking Change: <code>BaseSettings</code> now uses the special <code>env</code> settings to define which environment variables to   read, not aliases, #847 by @samuelcolvin</li> <li>add support for <code>assert</code> statements inside validators, #653 by @abdusco</li> <li>Update documentation to specify the use of <code>pydantic.dataclasses.dataclass</code> and subclassing <code>pydantic.BaseModel</code>, #710 by @maddosaurus</li> <li>Allow custom JSON decoding and encoding via <code>json_loads</code> and <code>json_dumps</code> <code>Config</code> properties, #714 by @samuelcolvin</li> <li>make all annotated fields occur in the order declared, #715 by @dmontagu</li> <li>use pytest to test <code>mypy</code> integration, #735 by @dmontagu</li> <li>add <code>__repr__</code> method to <code>ErrorWrapper</code>, #738 by @samuelcolvin</li> <li>Added support for <code>FrozenSet</code> members in dataclasses, and a better error when attempting to use types from the <code>typing</code> module that are not supported by Pydantic, #745 by @djpetti</li> <li>add documentation for Pycharm Plugin, #750 by @koxudaxi</li> <li>fix broken examples in the docs, #753 by @dmontagu</li> <li>moving typing related objects into <code>pydantic.typing</code>, #761 by @samuelcolvin</li> <li>Minor performance improvements to <code>ErrorWrapper</code>, <code>ValidationError</code> and datetime parsing, #763 by @samuelcolvin</li> <li>Improvements to <code>datetime</code>/<code>date</code>/<code>time</code>/<code>timedelta</code> types: more descriptive errors,   change errors to <code>value_error</code> not <code>type_error</code>, support bytes, #766 by @samuelcolvin</li> <li>fix error messages for <code>Literal</code> types with multiple allowed values, #770 by @dmontagu</li> <li>Improved auto-generated <code>title</code> field in JSON schema by converting underscore to space, #772 by @skewty</li> <li>support <code>mypy --no-implicit-reexport</code> for dataclasses, also respect <code>--no-implicit-reexport</code> in pydantic itself, #783 by @samuelcolvin</li> <li>add the <code>PaymentCardNumber</code> type, #790 by @matin</li> <li>Fix const validations for lists, #794 by @hmvp</li> <li>Set <code>additionalProperties</code> to false in schema for models with extra fields disallowed, #796 by @Code0x58</li> <li><code>EmailStr</code> validation method now returns local part case-sensitive per RFC 5321, #798 by @henriklindgren</li> <li>Added ability to validate strictness to <code>ConstrainedFloat</code>, <code>ConstrainedInt</code> and <code>ConstrainedStr</code> and added   <code>StrictFloat</code> and <code>StrictInt</code> classes, #799 by @DerRidda</li> <li>Improve handling of <code>None</code> and <code>Optional</code>, replace <code>whole</code> with <code>each_item</code> (inverse meaning, default <code>False</code>)   on validators, #803 by @samuelcolvin</li> <li>add support for <code>Type[T]</code> type hints, #807 by @timonbimon</li> <li>Performance improvements from removing <code>change_exceptions</code>, change how pydantic error are constructed, #819 by @samuelcolvin</li> <li>Fix the error message arising when a <code>BaseModel</code>-type model field causes a <code>ValidationError</code> during parsing, #820 by @dmontagu</li> <li>allow <code>getter_dict</code> on <code>Config</code>, modify <code>GetterDict</code> to be more like a <code>Mapping</code> object and thus easier to work with, #821 by @samuelcolvin</li> <li>Only check <code>TypeVar</code> param on base <code>GenericModel</code> class, #842 by @zpencerq</li> <li>rename <code>Model._schema_cache</code> -&gt; <code>Model.__schema_cache__</code>, <code>Model._json_encoder</code> -&gt; <code>Model.__json_encoder__</code>,   <code>Model._custom_root_type</code> -&gt; <code>Model.__custom_root_type__</code>, #851 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v0322-2019-08-17","title":"v0.32.2 (2019-08-17)","text":"<p>(Docs are available here)</p> <ul> <li>fix <code>__post_init__</code> usage with dataclass inheritance, fix #739 by @samuelcolvin</li> <li>fix required fields validation on GenericModels classes, #742 by @amitbl</li> <li>fix defining custom <code>Schema</code> on <code>GenericModel</code> fields, #754 by @amitbl</li> </ul>"},{"location":"changelog/#v0321-2019-08-08","title":"v0.32.1 (2019-08-08)","text":"<ul> <li>do not validate extra fields when <code>validate_assignment</code> is on, #724 by @YaraslauZhylko</li> </ul>"},{"location":"changelog/#v032-2019-08-06","title":"v0.32 (2019-08-06)","text":"<ul> <li>add model name to <code>ValidationError</code> error message, #676 by @dmontagu</li> <li>breaking change: remove <code>__getattr__</code> and rename <code>__values__</code> to <code>__dict__</code> on <code>BaseModel</code>,   deprecation warning on use <code>__values__</code> attr, attributes access speed increased up to 14 times, #712 by @Bobronium</li> <li>support <code>ForwardRef</code> (without self-referencing annotations) in Python 3.6, #706 by @koxudaxi</li> <li>implement <code>schema_extra</code> in <code>Config</code> sub-class, #663 by @tiangolo</li> </ul>"},{"location":"changelog/#v0311-2019-07-31","title":"v0.31.1 (2019-07-31)","text":"<ul> <li>fix json generation for <code>EnumError</code>, #697 by @dmontagu</li> <li>update numerous dependencies</li> </ul>"},{"location":"changelog/#v031-2019-07-24","title":"v0.31 (2019-07-24)","text":"<ul> <li>better support for floating point <code>multiple_of</code> values, #652 by @justindujardin</li> <li>fix schema generation for <code>NewType</code> and <code>Literal</code>, #649 by @dmontagu</li> <li>fix <code>alias_generator</code> and field config conflict, #645 by @gmetzker and #658 by @Bobronium</li> <li>more detailed message for <code>EnumError</code>, #673 by @dmontagu</li> <li>add advanced exclude support for <code>dict</code>, <code>json</code> and <code>copy</code>, #648 by @Bobronium</li> <li>fix bug in <code>GenericModel</code> for models with concrete parameterized fields, #672 by @dmontagu</li> <li>add documentation for <code>Literal</code> type, #651 by @dmontagu</li> <li>add <code>Config.keep_untouched</code> for custom descriptors support, #679 by @Bobronium</li> <li>use <code>inspect.cleandoc</code> internally to get model description, #657 by @tiangolo</li> <li>add <code>Color</code> to schema generation, by @euri10</li> <li>add documentation for Literal type, #651 by @dmontagu</li> </ul>"},{"location":"changelog/#v0301-2019-07-15","title":"v0.30.1 (2019-07-15)","text":"<ul> <li>fix so nested classes which inherit and change <code>__init__</code> are correctly processed while still allowing <code>self</code> as a   parameter, #644 by @lnaden and @dgasmith</li> </ul>"},{"location":"changelog/#v030-2019-07-07","title":"v0.30 (2019-07-07)","text":"<ul> <li>enforce single quotes in code, #612 by @samuelcolvin</li> <li>fix infinite recursion with dataclass inheritance and <code>__post_init__</code>, #606 by @Hanaasagi</li> <li>fix default values for <code>GenericModel</code>, #610 by @dmontagu</li> <li>clarify that self-referencing models require Python 3.7+, #616 by @vlcinsky</li> <li>fix truncate for types, #611 by @dmontagu</li> <li>add <code>alias_generator</code> support, #622 by @Bobronium</li> <li>fix unparameterized generic type schema generation, #625 by @dmontagu</li> <li>fix schema generation with multiple/circular references to the same model, #621 by @tiangolo and @wongpat</li> <li>support custom root types, #628 by @koxudaxi</li> <li>support <code>self</code> as a field name in <code>parse_obj</code>, #632 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v029-2019-06-19","title":"v0.29 (2019-06-19)","text":"<ul> <li>support dataclasses.InitVar, #592 by @pfrederiks</li> <li>Updated documentation to elucidate the usage of <code>Union</code> when defining multiple types under an attribute's   annotation and showcase how the type-order can affect marshalling of provided values, #594 by @somada141</li> <li>add <code>conlist</code> type, #583 by @hmvp</li> <li>add support for generics, #595 by @dmontagu</li> </ul>"},{"location":"changelog/#v028-2019-06-06","title":"v0.28 (2019-06-06)","text":"<ul> <li>fix support for JSON Schema generation when using models with circular references in Python 3.7, #572 by @tiangolo</li> <li>support <code>__post_init_post_parse__</code> on dataclasses, #567 by @sevaho</li> <li>allow dumping dataclasses to JSON, #575 by @samuelcolvin and @DanielOberg</li> <li>ORM mode, #562 by @samuelcolvin</li> <li>fix <code>pydantic.compiled</code> on ipython, #573 by @dmontagu and @samuelcolvin</li> <li>add <code>StrictBool</code> type, #579 by @cazgp</li> </ul>"},{"location":"changelog/#v027-2019-05-30","title":"v0.27 (2019-05-30)","text":"<ul> <li>breaking change <code>_pydantic_post_init</code> to execute dataclass' original <code>__post_init__</code> before   validation, #560 by @HeavenVolkoff</li> <li>fix handling of generic types without specified parameters, #550 by @dmontagu</li> <li>breaking change (maybe): this is the first release compiled with cython, see the docs and please   submit an issue if you run into problems</li> </ul>"},{"location":"changelog/#v0270a1-2019-05-26","title":"v0.27.0a1 (2019-05-26)","text":"<ul> <li>fix JSON Schema for <code>list</code>, <code>tuple</code>, and <code>set</code>, #540 by @tiangolo</li> <li>compiling with cython, <code>manylinux</code> binaries, some other performance improvements, #548 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v026-2019-05-22","title":"v0.26 (2019-05-22)","text":"<ul> <li>fix to schema generation for <code>IPvAnyAddress</code>, <code>IPvAnyInterface</code>, <code>IPvAnyNetwork</code> #498 by @pilosus</li> <li>fix variable length tuples support, #495 by @pilosus</li> <li>fix return type hint for <code>create_model</code>, #526 by @dmontagu</li> <li>Breaking Change: fix <code>.dict(skip_keys=True)</code> skipping values set via alias (this involves changing   <code>validate_model()</code> to always returns <code>Tuple[Dict[str, Any], Set[str], Optional[ValidationError]]</code>), #517 by @sommd</li> <li>fix to schema generation for <code>IPv4Address</code>, <code>IPv6Address</code>, <code>IPv4Interface</code>,   <code>IPv6Interface</code>, <code>IPv4Network</code>, <code>IPv6Network</code> #532 by @euri10</li> <li>add <code>Color</code> type, #504 by @pilosus and @samuelcolvin</li> </ul>"},{"location":"changelog/#v025-2019-05-05","title":"v0.25 (2019-05-05)","text":"<ul> <li>Improve documentation on self-referencing models and annotations, #487 by @theenglishway</li> <li>fix <code>.dict()</code> with extra keys, #490 by @JaewonKim</li> <li>support <code>const</code> keyword in <code>Schema</code>, #434 by @Sean1708</li> </ul>"},{"location":"changelog/#v024-2019-04-23","title":"v0.24 (2019-04-23)","text":"<ul> <li>fix handling <code>ForwardRef</code> in sub-types, like <code>Union</code>, #464 by @tiangolo</li> <li>fix secret serialization, #465 by @atheuz</li> <li>Support custom validators for dataclasses, #454 by @primal100</li> <li>fix <code>parse_obj</code> to cope with dict-like objects, #472 by @samuelcolvin</li> <li>fix to schema generation in nested dataclass-based models, #474 by @NoAnyLove</li> <li>fix <code>json</code> for <code>Path</code>, <code>FilePath</code>, and <code>DirectoryPath</code> objects, #473 by @mikegoodspeed</li> </ul>"},{"location":"changelog/#v023-2019-04-04","title":"v0.23 (2019-04-04)","text":"<ul> <li>improve documentation for contributing section, #441 by @pilosus</li> <li>improve README.rst to include essential information about the package, #446 by @pilosus</li> <li><code>IntEnum</code> support, #444 by @potykion</li> <li>fix PyObject callable value, #409 by @pilosus</li> <li>fix <code>black</code> deprecation warnings after update, #451 by @pilosus</li> <li>fix <code>ForwardRef</code> collection bug, #450 by @tigerwings</li> <li>Support specialized <code>ClassVars</code>, #455 by @tyrylu</li> <li>fix JSON serialization for <code>ipaddress</code> types, #333 by @pilosus</li> <li>add <code>SecretStr</code> and <code>SecretBytes</code> types, #452 by @atheuz</li> </ul>"},{"location":"changelog/#v022-2019-03-29","title":"v0.22 (2019-03-29)","text":"<ul> <li>add <code>IPv{4,6,Any}Network</code> and <code>IPv{4,6,Any}Interface</code> types from <code>ipaddress</code> stdlib, #333 by @pilosus</li> <li>add docs for <code>datetime</code> types, #386 by @pilosus</li> <li>fix to schema generation in dataclass-based models, #408 by @pilosus</li> <li>fix path in nested models, #437 by @kataev</li> <li>add <code>Sequence</code> support, #304 by @pilosus</li> </ul>"},{"location":"changelog/#v0210-2019-03-15","title":"v0.21.0 (2019-03-15)","text":"<ul> <li>fix typo in <code>NoneIsNotAllowedError</code> message, #414 by @YaraslauZhylko</li> <li>add <code>IPvAnyAddress</code>, <code>IPv4Address</code> and <code>IPv6Address</code> types, #333 by @pilosus</li> </ul>"},{"location":"changelog/#v0201-2019-02-26","title":"v0.20.1 (2019-02-26)","text":"<ul> <li>fix type hints of <code>parse_obj</code> and similar methods, #405 by @erosennin</li> <li>fix submodel validation, #403 by @samuelcolvin</li> <li>correct type hints for <code>ValidationError.json</code>, #406 by @layday</li> </ul>"},{"location":"changelog/#v0200-2019-02-18","title":"v0.20.0 (2019-02-18)","text":"<ul> <li>fix tests for Python 3.8, #396 by @samuelcolvin</li> <li>Adds fields to the <code>dir</code> method for autocompletion in interactive sessions, #398 by @dgasmith</li> <li>support <code>ForwardRef</code> (and therefore <code>from __future__ import annotations</code>) with dataclasses, #397 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v0200a1-2019-02-13","title":"v0.20.0a1 (2019-02-13)","text":"<ul> <li>breaking change (maybe): more sophisticated argument parsing for validators, any subset of   <code>values</code>, <code>config</code> and <code>field</code> is now permitted, eg. <code>(cls, value, field)</code>,   however the variadic key word argument (\"<code>**kwargs</code>\") must be called <code>kwargs</code>, #388 by @samuelcolvin</li> <li>breaking change: Adds <code>skip_defaults</code> argument to <code>BaseModel.dict()</code> to allow skipping of fields that   were not explicitly set, signature of <code>Model.construct()</code> changed, #389 by @dgasmith</li> <li>add <code>py.typed</code> marker file for PEP-561 support, #391 by @je-l</li> <li>Fix <code>extra</code> behaviour for multiple inheritance/mix-ins, #394 by @YaraslauZhylko</li> </ul>"},{"location":"changelog/#v0190-2019-02-04","title":"v0.19.0 (2019-02-04)","text":"<ul> <li>Support <code>Callable</code> type hint, fix #279 by @proofit404</li> <li>Fix schema for fields with <code>validator</code> decorator, fix #375 by @tiangolo</li> <li>Add <code>multiple_of</code> constraint to <code>ConstrainedDecimal</code>, <code>ConstrainedFloat</code>, <code>ConstrainedInt</code>   and their related types <code>condecimal</code>, <code>confloat</code>, and <code>conint</code> #371, thanks @StephenBrown2</li> <li>Deprecated <code>ignore_extra</code> and <code>allow_extra</code> Config fields in favor of <code>extra</code>, #352 by @liiight</li> <li>Add type annotations to all functions, test fully with mypy, #373 by @samuelcolvin</li> <li>fix for 'missing' error with <code>validate_all</code> or <code>validate_always</code>, #381 by @samuelcolvin</li> <li>Change the second/millisecond watershed for date/datetime parsing to <code>2e10</code>, #385 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v0182-2019-01-22","title":"v0.18.2 (2019-01-22)","text":"<ul> <li>Fix to schema generation with <code>Optional</code> fields, fix #361 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v0181-2019-01-17","title":"v0.18.1 (2019-01-17)","text":"<ul> <li>add <code>ConstrainedBytes</code> and <code>conbytes</code> types, #315 @Gr1N</li> <li>adding <code>MANIFEST.in</code> to include license in package <code>.tar.gz</code>, #358 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v0180-2019-01-13","title":"v0.18.0 (2019-01-13)","text":"<ul> <li>breaking change: don't call validators on keys of dictionaries, #254 by @samuelcolvin</li> <li>Fix validators with <code>always=True</code> when the default is <code>None</code> or the type is optional, also prevent   <code>whole</code> validators being called for sub-fields, fix #132 by @samuelcolvin</li> <li>improve documentation for settings priority and allow it to be easily changed, #343 by @samuelcolvin</li> <li>fix <code>ignore_extra=False</code> and <code>allow_population_by_alias=True</code>, fix #257 by @samuelcolvin</li> <li>breaking change: Set <code>BaseConfig</code> attributes <code>min_anystr_length</code> and <code>max_anystr_length</code> to   <code>None</code> by default, fix #349 in #350 by @tiangolo</li> <li>add support for postponed annotations, #348 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v0170-2018-12-27","title":"v0.17.0 (2018-12-27)","text":"<ul> <li>fix schema for <code>timedelta</code> as number, #325 by @tiangolo</li> <li>prevent validators being called repeatedly after inheritance, #327 by @samuelcolvin</li> <li>prevent duplicate validator check in ipython, fix #312 by @samuelcolvin</li> <li>add \"Using Pydantic\" section to docs, #323 by @tiangolo &amp; #326 by @samuelcolvin</li> <li>fix schema generation for fields annotated as <code>: dict</code>, <code>: list</code>,   <code>: tuple</code> and <code>: set</code>, #330 &amp; #335 by @nkonin</li> <li>add support for constrained strings as dict keys in schema, #332 by @tiangolo</li> <li>support for passing Config class in dataclasses decorator, #276 by @jarekkar   (breaking change: this supersedes the <code>validate_assignment</code> argument with <code>config</code>)</li> <li>support for nested dataclasses, #334 by @samuelcolvin</li> <li>better errors when getting an <code>ImportError</code> with <code>PyObject</code>, #309 by @samuelcolvin</li> <li>rename <code>get_validators</code> to <code>__get_validators__</code>, deprecation warning on use of old name, #338 by @samuelcolvin</li> <li>support <code>ClassVar</code> by excluding such attributes from fields, #184 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v0161-2018-12-10","title":"v0.16.1 (2018-12-10)","text":"<ul> <li>fix <code>create_model</code> to correctly use the passed <code>__config__</code>, #320 by @hugoduncan</li> </ul>"},{"location":"changelog/#v0160-2018-12-03","title":"v0.16.0 (2018-12-03)","text":"<ul> <li>breaking change: refactor schema generation to be compatible with JSON Schema and OpenAPI specs, #308 by @tiangolo</li> <li>add <code>schema</code> to <code>schema</code> module to generate top-level schemas from base models, #308 by @tiangolo</li> <li>add additional fields to <code>Schema</code> class to declare validation for <code>str</code> and numeric values, #311 by @tiangolo</li> <li>rename <code>_schema</code> to <code>schema</code> on fields, #318 by @samuelcolvin</li> <li>add <code>case_insensitive</code> option to <code>BaseSettings</code> <code>Config</code>, #277 by @jasonkuhrt</li> </ul>"},{"location":"changelog/#v0150-2018-11-18","title":"v0.15.0 (2018-11-18)","text":"<ul> <li>move codebase to use black, #287 by @samuelcolvin</li> <li>fix alias use in settings, #286 by @jasonkuhrt and @samuelcolvin</li> <li>fix datetime parsing in <code>parse_date</code>, #298 by @samuelcolvin</li> <li>allow dataclass inheritance, fix #293 by @samuelcolvin</li> <li>fix <code>PyObject = None</code>, fix #305 by @samuelcolvin</li> <li>allow <code>Pattern</code> type, fix #303 by @samuelcolvin</li> </ul>"},{"location":"changelog/#v0140-2018-10-02","title":"v0.14.0 (2018-10-02)","text":"<ul> <li>dataclasses decorator, #269 by @Gaunt and @samuelcolvin</li> </ul>"},{"location":"changelog/#v0131-2018-09-21","title":"v0.13.1 (2018-09-21)","text":"<ul> <li>fix issue where int_validator doesn't cast a <code>bool</code> to an <code>int</code> #264 by @nphyatt</li> <li>add deep copy support for <code>BaseModel.copy()</code> #249, @gangefors</li> </ul>"},{"location":"changelog/#v0130-2018-08-25","title":"v0.13.0 (2018-08-25)","text":"<ul> <li>raise an exception if a field's name shadows an existing <code>BaseModel</code> attribute #242</li> <li>add <code>UrlStr</code> and <code>urlstr</code> types #236</li> <li>timedelta json encoding ISO8601 and total seconds, custom json encoders #247, by @cfkanesan and @samuelcolvin</li> <li>allow <code>timedelta</code> objects as values for properties of type <code>timedelta</code> (matches <code>datetime</code> etc. behavior) #247</li> </ul>"},{"location":"changelog/#v0121-2018-07-31","title":"v0.12.1 (2018-07-31)","text":"<ul> <li>fix schema generation for fields defined using <code>typing.Any</code> #237</li> </ul>"},{"location":"changelog/#v0120-2018-07-31","title":"v0.12.0 (2018-07-31)","text":"<ul> <li>add <code>by_alias</code> argument in <code>.dict()</code> and <code>.json()</code> model methods #205</li> <li>add Json type support #214</li> <li>support tuples #227</li> <li>major improvements and changes to schema #213</li> </ul>"},{"location":"changelog/#v0112-2018-07-05","title":"v0.11.2 (2018-07-05)","text":"<ul> <li>add <code>NewType</code> support #115</li> <li>fix <code>list</code>, <code>set</code> &amp; <code>tuple</code> validation #225</li> <li>separate out <code>validate_model</code> method, allow errors to be returned along with valid values #221</li> </ul>"},{"location":"changelog/#v0111-2018-07-02","title":"v0.11.1 (2018-07-02)","text":"<ul> <li>support Python 3.7 #216, thanks @layday</li> <li>Allow arbitrary types in model #209, thanks @oldPadavan</li> </ul>"},{"location":"changelog/#v0110-2018-06-28","title":"v0.11.0 (2018-06-28)","text":"<ul> <li>make <code>list</code>, <code>tuple</code> and <code>set</code> types stricter #86</li> <li>breaking change: remove msgpack parsing #201</li> <li>add <code>FilePath</code> and <code>DirectoryPath</code> types #10</li> <li>model schema generation #190</li> <li>JSON serialisation of models and schemas #133</li> </ul>"},{"location":"changelog/#v0100-2018-06-11","title":"v0.10.0 (2018-06-11)","text":"<ul> <li>add <code>Config.allow_population_by_alias</code> #160, thanks @bendemaree</li> <li>breaking change: new errors format #179, thanks @Gr1N</li> <li>breaking change: removed <code>Config.min_number_size</code> and <code>Config.max_number_size</code> #183, thanks @Gr1N</li> <li>breaking change: correct behaviour of <code>lt</code> and <code>gt</code> arguments to <code>conint</code> etc. #188   for the old behaviour use <code>le</code> and <code>ge</code> #194, thanks @jaheba</li> <li>added error context and ability to redefine error message templates using <code>Config.error_msg_templates</code> #183,   thanks @Gr1N</li> <li>fix typo in validator exception #150</li> <li>copy defaults to model values, so different models don't share objects #154</li> </ul>"},{"location":"changelog/#v091-2018-05-10","title":"v0.9.1 (2018-05-10)","text":"<ul> <li>allow custom <code>get_field_config</code> on config classes #159</li> <li>add <code>UUID1</code>, <code>UUID3</code>, <code>UUID4</code> and <code>UUID5</code> types #167, thanks @Gr1N</li> <li>modify some inconsistent docstrings and annotations #173, thanks @YannLuo</li> <li>fix type annotations for exotic types #171, thanks @Gr1N</li> <li>re-use type validators in exotic types #171</li> <li>scheduled monthly requirements updates #168</li> <li>add <code>Decimal</code>, <code>ConstrainedDecimal</code> and <code>condecimal</code> types #170, thanks @Gr1N</li> </ul>"},{"location":"changelog/#v090-2018-04-28","title":"v0.9.0 (2018-04-28)","text":"<ul> <li>tweak email-validator import error message #145</li> <li>fix parse error of <code>parse_date()</code> and <code>parse_datetime()</code> when input is 0 #144, thanks @YannLuo</li> <li>add <code>Config.anystr_strip_whitespace</code> and <code>strip_whitespace</code> kwarg to <code>constr</code>,   by default values is <code>False</code> #163, thanks @Gr1N</li> <li>add <code>ConstrainedFloat</code>, <code>confloat</code>, <code>PositiveFloat</code> and <code>NegativeFloat</code> types #166, thanks @Gr1N</li> </ul>"},{"location":"changelog/#v080-2018-03-25","title":"v0.8.0 (2018-03-25)","text":"<ul> <li>fix type annotation for <code>inherit_config</code> #139</li> <li>breaking change: check for invalid field names in validators #140</li> <li>validate attributes of parent models #141</li> <li>breaking change: email validation now uses   email-validator #142</li> </ul>"},{"location":"changelog/#v071-2018-02-07","title":"v0.7.1 (2018-02-07)","text":"<ul> <li>fix bug with <code>create_model</code> modifying the base class</li> </ul>"},{"location":"changelog/#v070-2018-02-06","title":"v0.7.0 (2018-02-06)","text":"<ul> <li>added compatibility with abstract base classes (ABCs) #123</li> <li>add <code>create_model</code> method #113 #125</li> <li>breaking change: rename <code>.config</code> to <code>.__config__</code> on a model</li> <li>breaking change: remove deprecated <code>.values()</code> on a model, use <code>.dict()</code> instead</li> <li>remove use of <code>OrderedDict</code> and use simple dict #126</li> <li>add <code>Config.use_enum_values</code> #127</li> <li>add wildcard validators of the form <code>@validate('*')</code> #128</li> </ul>"},{"location":"changelog/#v064-2018-02-01","title":"v0.6.4 (2018-02-01)","text":"<ul> <li>allow Python date and times objects #122</li> </ul>"},{"location":"changelog/#v063-2017-11-26","title":"v0.6.3 (2017-11-26)","text":"<ul> <li>fix direct install without <code>README.rst</code> present</li> </ul>"},{"location":"changelog/#v062-2017-11-13","title":"v0.6.2 (2017-11-13)","text":"<ul> <li>errors for invalid validator use</li> <li>safer check for complex models in <code>Settings</code></li> </ul>"},{"location":"changelog/#v061-2017-11-08","title":"v0.6.1 (2017-11-08)","text":"<ul> <li>prevent duplicate validators, #101</li> <li>add <code>always</code> kwarg to validators, #102</li> </ul>"},{"location":"changelog/#v060-2017-11-07","title":"v0.6.0 (2017-11-07)","text":"<ul> <li>assignment validation #94, thanks petroswork!</li> <li>JSON in environment variables for complex types, #96</li> <li>add <code>validator</code> decorators for complex validation, #97</li> <li>depreciate <code>values(...)</code> and replace with <code>.dict(...)</code>, #99</li> </ul>"},{"location":"changelog/#v050-2017-10-23","title":"v0.5.0 (2017-10-23)","text":"<ul> <li>add <code>UUID</code> validation #89</li> <li>remove <code>index</code> and <code>track</code> from error object (json) if they're null #90</li> <li>improve the error text when a list is provided rather than a dict #90</li> <li>add benchmarks table to docs #91</li> </ul>"},{"location":"changelog/#v040-2017-07-08","title":"v0.4.0 (2017-07-08)","text":"<ul> <li>show length in string validation error</li> <li>fix aliases in config during inheritance #55</li> <li>simplify error display</li> <li>use unicode ellipsis in <code>truncate</code></li> <li>add <code>parse_obj</code>, <code>parse_raw</code> and <code>parse_file</code> helper functions #58</li> <li>switch annotation only fields to come first in fields list not last</li> </ul>"},{"location":"changelog/#v030-2017-06-21","title":"v0.3.0 (2017-06-21)","text":"<ul> <li>immutable models via <code>config.allow_mutation = False</code>, associated cleanup and performance improvement #44</li> <li>immutable helper methods <code>construct()</code> and <code>copy()</code> #53</li> <li>allow pickling of models #53</li> <li><code>setattr</code> is removed as <code>__setattr__</code> is now intelligent #44</li> <li><code>raise_exception</code> removed, Models now always raise exceptions #44</li> <li>instance method validators removed</li> <li>django-restful-framework benchmarks added #47</li> <li>fix inheritance bug #49</li> <li>make str type stricter so list, dict etc are not coerced to strings. #52</li> <li>add <code>StrictStr</code> which only always strings as input #52</li> </ul>"},{"location":"changelog/#v021-2017-06-07","title":"v0.2.1 (2017-06-07)","text":"<ul> <li>pypi and travis together messed up the deploy of <code>v0.2</code> this should fix it</li> </ul>"},{"location":"changelog/#v020-2017-06-07","title":"v0.2.0 (2017-06-07)","text":"<ul> <li>breaking change: <code>values()</code> on a model is now a method not a property,   takes <code>include</code> and <code>exclude</code> arguments</li> <li>allow annotation only fields to support mypy</li> <li>add pretty <code>to_string(pretty=True)</code> method for models</li> </ul>"},{"location":"changelog/#v010-2017-06-03","title":"v0.1.0 (2017-06-03)","text":"<ul> <li>add docs</li> <li>add history</li> </ul>"},{"location":"contributing/","title":"Contributing to pydantic","text":"<p>We'd love you to contribute to pydantic!</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as discussions or issues. However, to report a security vulnerability, please see our security policy.</p> <p>To make it as simple as possible for us to help you, please include the output of the following call in your issue:</p> <p><pre><code>python -c \"import pydantic.utils; print(pydantic.utils.version_info())\"\n</code></pre> If you're using pydantic prior to v1.3 (when <code>version_info()</code> was added), please manually include OS, Python version and pydantic version.</p> <p>Please try to always include the above unless you're unable to install pydantic or know it's not relevant to your question or feature request.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>It should be extremely simple to get started and create a Pull Request. pydantic is released regularly so you should see your improvements release in a matter of days or weeks.</p> <p>Note</p> <p>Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request.</p> <p>If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.</p> <p>To make contributing as easy and fast as possible, you'll want to run tests and linting locally. Luckily, pydantic has few dependencies, doesn't require compiling and tests don't need access to databases, etc. Because of this, setting up and running the tests should be very simple.</p> <p>You'll need to have a version between Python 3.7 and 3.11, virtualenv, git, pdm and make installed.</p> <pre><code># 1. clone your fork and cd into the repo directory\ngit clone git@github.com:&lt;your username&gt;/pydantic.git\ncd pydantic\n\n# 2. Set up a virtualenv for running tests\nvirtualenv -p `which python3.8` env\nsource env/bin/activate\n# Building docs requires 3.8. If you don't need to build docs you can use\n# whichever version; 3.7 will work too.\n\n# 3. Install pydantic, dependencies, test dependencies and doc dependencies\nmake install\n\n# 4. Checkout a new branch and make your changes\ngit checkout -b my-new-feature-branch\n# make your changes...\n\n# 5. Fix formatting and imports\nmake format\n# Pydantic uses black to enforce formatting and isort to fix imports\n# (https://github.com/ambv/black, https://github.com/timothycrosley/isort)\n\n# 6. Run tests and linting\nmake\n# there are a few sub-commands in Makefile like `test`, `testcov` and `lint`\n# which you might want to use, but generally just `make` should be all you need\n\n# 7. Build documentation\nmake docs\n# if you have changed the documentation make sure it builds successfully\n# you can also use `make docs-serve` to serve the documentation at localhost:8000\n\n# ... commit, push, and create your pull request\n</code></pre> <p>tl;dr: use <code>make format</code> to fix formatting, <code>make</code> to run tests and linting &amp; <code>make docs</code> to build the docs.</p>"},{"location":"datamodel_code_generator/","title":"Code Generation","text":"<p>The datamodel-code-generator project is a library and command-line utility to generate pydantic models from just about any data source, including:</p> <ul> <li>OpenAPI 3 (YAML/JSON)</li> <li>JSON Schema</li> <li>JSON/YAML Data (which will converted to JSON Schema)</li> </ul> <p>Whenever you find yourself with any data convertible JSON but without pydantic models, this tool will allow you to generate type-safe model hierarchies on demand.</p>"},{"location":"datamodel_code_generator/#installation","title":"Installation","text":"<pre><code>pip install datamodel-code-generator\n</code></pre>"},{"location":"datamodel_code_generator/#example","title":"Example","text":"<p>In this case, datamodel-code-generator creates pydantic models from a JSON Schema file. <pre><code>datamodel-codegen  --input person.json --input-file-type jsonschema --output model.py\n</code></pre></p> <p>person.json: <pre><code>{\n  \"$id\": \"person.json\",\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"first_name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"last_name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"pets\": {\n      \"type\": \"array\",\n      \"items\": [\n        {\n          \"$ref\": \"#/definitions/Pet\"\n        }\n      ]\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  },\n  \"required\": [\n      \"first_name\",\n      \"last_name\"\n  ],\n  \"definitions\": {\n    \"Pet\": {\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"age\": {\n          \"type\": \"integer\"\n        }\n      }\n    }\n  }\n}\n</code></pre></p> <p>model.py:</p> Python 3.7 and above <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2020-05-19T15:07:31+00:00\nfrom __future__ import annotations\nfrom typing import Any, List, Optional\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Pet(BaseModel):\n    name: Optional[str] = None\n    age: Optional[int] = None\n\n\nclass Person(BaseModel):\n    first_name: str = Field(..., description=\"The person's first name.\")\n    last_name: str = Field(..., description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(None, description='Age in years.')\n    pets: Optional[List[Pet]] = None\n    comment: Optional[Any] = None\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>More information can be found on the official documentation</p>"},{"location":"hypothesis_plugin/","title":"Hypothesis plugin","text":"<p>Hypothesis is the Python library for property-based testing. Hypothesis can infer how to construct type-annotated classes, and supports builtin types, many standard library types, and generic types from the <code>typing</code> and <code>typing_extensions</code> modules by default.</p> <p>From Pydantic v1.8 and Hypothesis v5.29.0, Hypothesis will automatically load support for custom types like <code>PaymentCardNumber</code> and <code>PositiveFloat</code>, so that the <code>st.builds()</code> and <code>st.from_type()</code> strategies support them without any user configuration.</p> <p>Warning</p> <p>Please note, while the plugin supports these types, hypothesis will(currently) generate values outside  of given args for the constrained function types.</p>"},{"location":"hypothesis_plugin/#example-tests","title":"Example tests","text":"Python 3.7 and abovePython 3.9 and above <pre><code>import typing\nfrom hypothesis import given, strategies as st\nfrom pydantic import BaseModel, EmailStr, PaymentCardNumber, PositiveFloat\n\n\nclass Model(BaseModel):\n    card: PaymentCardNumber\n    price: PositiveFloat\n    users: typing.List[EmailStr]\n\n\n@given(st.builds(Model))\ndef test_property(instance):\n    # Hypothesis calls this test function many times with varied Models,\n    # so you can write a test that should pass given *any* instance.\n    assert 0 &lt; instance.price\n    assert all('@' in email for email in instance.users)\n\n\n@given(st.builds(Model, price=st.floats(100, 200)))\ndef test_with_discount(instance):\n    # This test shows how you can override specific fields,\n    # and let Hypothesis fill in any you don't care about.\n    assert 100 &lt;= instance.price &lt;= 200\n</code></pre> <pre><code>from hypothesis import given, strategies as st\nfrom pydantic import BaseModel, EmailStr, PaymentCardNumber, PositiveFloat\n\n\nclass Model(BaseModel):\n    card: PaymentCardNumber\n    price: PositiveFloat\n    users: list[EmailStr]\n\n\n@given(st.builds(Model))\ndef test_property(instance):\n    # Hypothesis calls this test function many times with varied Models,\n    # so you can write a test that should pass given *any* instance.\n    assert 0 &lt; instance.price\n    assert all('@' in email for email in instance.users)\n\n\n@given(st.builds(Model, price=st.floats(100, 200)))\ndef test_with_discount(instance):\n    # This test shows how you can override specific fields,\n    # and let Hypothesis fill in any you don't care about.\n    assert 100 &lt;= instance.price &lt;= 200\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"hypothesis_plugin/#use-with-json-schemas","title":"Use with JSON Schemas","text":"<p>To test client-side code, you can use <code>Model.schema()</code> with the <code>hypothesis-jsonschema</code> package to generate arbitrary JSON instances matching the schema. For web API testing, Schemathesis provides a higher-level wrapper and can detect both errors and security vulnerabilities.</p>"},{"location":"install/","title":"Install","text":"<p>Installation is as simple as:</p> <pre><code>pip install 'pydantic&lt;2'\n</code></pre> <p>pydantic has no required dependencies except Python 3.7, 3.8, 3.9, 3.10 or 3.11 and <code>typing-extensions</code>. If you've got Python 3.7+ and <code>pip</code> installed, you're good to go.</p> <p>Pydantic is also available on conda under the conda-forge channel:</p> <pre><code>conda install 'pydantic&lt;2' -c conda-forge\n</code></pre>"},{"location":"install/#compiled-with-cython","title":"Compiled with Cython","text":"<p>pydantic can optionally be compiled with cython which should give a 30-50% performance improvement. </p> <p>By default <code>pip install</code> provides optimized binaries via PyPI for Linux, MacOS and 64bit Windows.</p> <p>If you're installing manually, install <code>cython&lt;3</code> (Pydantic 1.x is incompatible with Cython v3 and above) before installing pydantic and compilation should happen automatically.</p> <p>To test if pydantic is compiled run:</p> <pre><code>import pydantic\nprint('compiled:', pydantic.compiled)\n</code></pre>"},{"location":"install/#performance-vs-package-size-trade-off","title":"Performance vs package size trade-off","text":"<p>Compiled binaries can increase the size of your Python environment. If for some reason you want to reduce the size of your pydantic installation you can avoid installing any binaries using the <code>pip --no-binary</code> option. Make sure <code>Cython</code> is not in your environment, or that you have the <code>SKIP_CYTHON</code> environment variable set to avoid re-compiling pydantic libraries:</p> <pre><code>SKIP_CYTHON=1 pip install --no-binary pydantic pydantic&lt;2\n</code></pre> <p>Note</p> <p><code>pydantic</code> is repeated here intentionally, <code>--no-binary pydantic</code> tells <code>pip</code> you want no binaries for pydantic, the next <code>pydantic</code> tells <code>pip</code> which package to install.</p> <p>Alternatively, you can re-compile pydantic with custom build options, this would require having the <code>Cython</code> package installed before re-compiling pydantic with: <pre><code>CFLAGS=\"-Os -g0 -s\" pip install \\\n  --no-binary pydantic \\\n  --global-option=build_ext \\\n  pydantic&lt;2\n</code></pre></p>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<p>pydantic has two optional dependencies:</p> <ul> <li>If you require email validation you can add email-validator</li> <li>dotenv file support with <code>Settings</code> requires   python-dotenv</li> </ul> <p>To install these along with pydantic: <pre><code>pip install 'pydantic[email]&lt;2'\n# or\npip install 'pydantic[dotenv]&lt;2'\n# or just\npip install 'pydantic[email,dotenv]&lt;2'\n</code></pre></p> <p>Of course, you can also install these requirements manually with <code>pip install email-validator</code> and/or <code>pip install python-dotenv</code>.</p>"},{"location":"install/#install-from-repository","title":"Install from repository","text":"<p>And if you prefer to install pydantic directly from the repository: <pre><code>pip install git+https://github.com/pydantic/pydantic@1.10.X-fixes#egg=pydantic\n# or with extras\npip install git+https://github.com/pydantic/pydantic@1.10.X-fixes#egg=pydantic[email,dotenv]\n</code></pre></p>"},{"location":"mypy_plugin/","title":"Mypy plugin","text":"<p>Pydantic works well with mypy right out of the box.</p> <p>However, Pydantic also ships with a mypy plugin that adds a number of important pydantic-specific features to mypy that improve its ability to type-check your code.</p> <p>For example, consider the following script:</p> Python 3.7 and abovePython 3.9 and abovePython 3.10 and above <pre><code>from datetime import datetime\nfrom typing import List, Optional\nfrom pydantic import BaseModel, NoneStr\n\n\nclass Model(BaseModel):\n    age: int\n    first_name = 'John'\n    last_name: NoneStr = None\n    signup_ts: Optional[datetime] = None\n    list_of_ints: List[int]\n\n\nm = Model(age=42, list_of_ints=[1, '2', b'3'])\nprint(m.middle_name)  # not a model field!\nModel()  # will raise a validation error for age and list_of_ints\n</code></pre> <pre><code>from datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, NoneStr\n\n\nclass Model(BaseModel):\n    age: int\n    first_name = 'John'\n    last_name: NoneStr = None\n    signup_ts: Optional[datetime] = None\n    list_of_ints: list[int]\n\n\nm = Model(age=42, list_of_ints=[1, '2', b'3'])\nprint(m.middle_name)  # not a model field!\nModel()  # will raise a validation error for age and list_of_ints\n</code></pre> <pre><code>from datetime import datetime\nfrom pydantic import BaseModel, NoneStr\n\n\nclass Model(BaseModel):\n    age: int\n    first_name = 'John'\n    last_name: NoneStr = None\n    signup_ts: datetime | None = None\n    list_of_ints: list[int]\n\n\nm = Model(age=42, list_of_ints=[1, '2', b'3'])\nprint(m.middle_name)  # not a model field!\nModel()  # will raise a validation error for age and list_of_ints\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Without any special configuration, mypy catches one of the errors (see here for usage instructions): <pre><code>13: error: \"Model\" has no attribute \"middle_name\"\n</code></pre></p> <p>But with the plugin enabled, it catches both: <pre><code>13: error: \"Model\" has no attribute \"middle_name\"\n16: error: Missing named argument \"age\" for \"Model\"\n16: error: Missing named argument \"list_of_ints\" for \"Model\"\n</code></pre></p> <p>With the pydantic mypy plugin, you can fearlessly refactor your models knowing mypy will catch any mistakes if your field names or types change.</p> <p>There are other benefits too! See below for more details.</p>"},{"location":"mypy_plugin/#plugin-capabilities","title":"Plugin Capabilities","text":""},{"location":"mypy_plugin/#generate-a-signature-for-model__init__","title":"Generate a signature for <code>Model.__init__</code>","text":"<ul> <li>Any required fields that don't have dynamically-determined aliases will be included as required   keyword arguments.</li> <li>If <code>Config.allow_population_by_field_name=True</code>, the generated signature will use the field names,   rather than aliases.</li> <li>For subclasses of <code>BaseSettings</code>, all fields are treated as optional since they may be   read from the environment.</li> <li>If <code>Config.extra=\"forbid\"</code> and you don't make use of dynamically-determined aliases, the generated signature   will not allow unexpected inputs.</li> <li>Optional: If the <code>init_forbid_extra</code> plugin setting is set to <code>True</code>, unexpected inputs to   <code>__init__</code> will raise errors even if <code>Config.extra</code> is not <code>\"forbid\"</code>.</li> <li>Optional: If the <code>init_typed</code> plugin setting is set to <code>True</code>, the generated signature   will use the types of the model fields (otherwise they will be annotated as <code>Any</code> to allow parsing).</li> </ul>"},{"location":"mypy_plugin/#generate-a-typed-signature-for-modelconstruct","title":"Generate a typed signature for <code>Model.construct</code>","text":"<ul> <li>The <code>construct</code> method is a faster alternative to <code>__init__</code>   when input data is known to be valid and does not need to be parsed. But because this method performs no runtime   validation, static checking is important to detect errors.</li> </ul>"},{"location":"mypy_plugin/#respect-configallow_mutation","title":"Respect <code>Config.allow_mutation</code>","text":"<ul> <li>If <code>Config.allow_mutation</code> is <code>False</code>, you'll get a mypy error if you try to change   the value of a model field; cf. faux immutability.</li> </ul>"},{"location":"mypy_plugin/#respect-configorm_mode","title":"Respect <code>Config.orm_mode</code>","text":"<ul> <li>If <code>Config.orm_mode</code> is <code>False</code>, you'll get a mypy error if you try to call <code>.from_orm()</code>;   cf. ORM mode</li> </ul>"},{"location":"mypy_plugin/#generate-a-signature-for-dataclasses","title":"Generate a signature for <code>dataclasses</code>","text":"<ul> <li>classes decorated with <code>@pydantic.dataclasses.dataclass</code> are type checked the same as standard Python dataclasses</li> <li>The <code>@pydantic.dataclasses.dataclass</code> decorator accepts a <code>config</code> keyword argument which has the same meaning as the <code>Config</code> sub-class.</li> </ul>"},{"location":"mypy_plugin/#respect-the-type-of-the-fields-default-and-default_factory","title":"Respect the type of the <code>Field</code>'s <code>default</code> and <code>default_factory</code>","text":"<ul> <li>Field with both a <code>default</code> and a <code>default_factory</code> will result in an error during static checking.</li> <li>The type of the <code>default</code> and <code>default_factory</code> value must be compatible with the one of the field.</li> </ul>"},{"location":"mypy_plugin/#optional-capabilities","title":"Optional Capabilities:","text":""},{"location":"mypy_plugin/#prevent-the-use-of-required-dynamic-aliases","title":"Prevent the use of required dynamic aliases","text":"<ul> <li>If the <code>warn_required_dynamic_aliases</code> plugin setting is set to <code>True</code>, you'll get a mypy   error any time you use a dynamically-determined alias or alias generator on a model with   <code>Config.allow_population_by_field_name=False</code>.</li> <li>This is important because if such aliases are present, mypy cannot properly type check calls to <code>__init__</code>.   In this case, it will default to treating all arguments as optional.</li> </ul>"},{"location":"mypy_plugin/#prevent-the-use-of-untyped-fields","title":"Prevent the use of untyped fields","text":"<ul> <li>If the <code>warn_untyped_fields</code> plugin setting is set to <code>True</code>, you'll get a mypy error   any time you create a field on a model without annotating its type.</li> <li>This is important because non-annotated fields may result in   validators being applied in a surprising order.</li> <li>In addition, mypy may not be able to correctly infer the type of the field, and may miss   checks or raise spurious errors.</li> </ul>"},{"location":"mypy_plugin/#enabling-the-plugin","title":"Enabling the Plugin","text":"<p>To enable the plugin, just add <code>pydantic.mypy</code> to the list of plugins in your mypy config file (this could be <code>mypy.ini</code> or <code>setup.cfg</code>).</p> <p>To get started, all you need to do is create a <code>mypy.ini</code> file with following contents: <pre><code>[mypy]\nplugins = pydantic.mypy\n</code></pre></p> <p>The plugin is compatible with mypy versions <code>&gt;=0.910</code>.</p> <p>See the mypy usage and plugin configuration docs for more details.</p>"},{"location":"mypy_plugin/#plugin-settings","title":"Plugin Settings","text":"<p>The plugin offers a few optional strictness flags if you want even stronger checks:</p> <ul> <li><code>init_forbid_extra</code><p>If enabled, disallow extra arguments to the <code>__init__</code> call even when <code>Config.extra</code> is not <code>\"forbid\"</code>.</p> </li> </ul> <ul> <li><code>init_typed</code><p>If enabled, include the field types as type hints in the generated signature for the <code>__init__</code> method.   This means that you'll get mypy errors if you pass an argument that is not already the right type to   <code>__init__</code>, even if parsing could safely convert the type.</p> </li> </ul> <ul> <li><code>warn_required_dynamic_aliases</code><p>If enabled, raise a mypy error whenever a model is created for which   calls to its <code>__init__</code> or <code>construct</code> methods require the use of aliases that cannot be statically determined.   This is the case, for example, if <code>allow_population_by_field_name=False</code> and the model uses an alias generator.</p> </li> </ul> <ul> <li><code>warn_untyped_fields</code><p>If enabled, raise a mypy error whenever a field is declared on a model without explicitly specifying its type.</p> </li> </ul>"},{"location":"mypy_plugin/#configuring-the-plugin","title":"Configuring the Plugin","text":"<p>To change the values of the plugin settings, create a section in your mypy config file called <code>[pydantic-mypy]</code>, and add any key-value pairs for settings you want to override.</p> <p>A <code>mypy.ini</code> file with all plugin strictness flags enabled (and some other mypy strictness flags, too) might look like: <pre><code>[mypy]\nplugins = pydantic.mypy\n\nfollow_imports = silent\nwarn_redundant_casts = True\nwarn_unused_ignores = True\ndisallow_any_generics = True\ncheck_untyped_defs = True\nno_implicit_reexport = True\n\n# for strict mypy: (this is the tricky one :-))\ndisallow_untyped_defs = True\n\n[pydantic-mypy]\ninit_forbid_extra = True\ninit_typed = True\nwarn_required_dynamic_aliases = True\nwarn_untyped_fields = True\n</code></pre></p> <p>As of <code>mypy&gt;=0.900</code>, mypy config may also be included in the <code>pyproject.toml</code> file rather than <code>mypy.ini</code>. The same configuration as above would be: <pre><code>[tool.mypy]\nplugins = [\n  \"pydantic.mypy\"\n]\n\nfollow_imports = \"silent\"\nwarn_redundant_casts = true\nwarn_unused_ignores = true\ndisallow_any_generics = true\ncheck_untyped_defs = true\nno_implicit_reexport = true\n\n# for strict mypy: (this is the tricky one :-))\ndisallow_untyped_defs = true\n\n[tool.pydantic-mypy]\ninit_forbid_extra = true\ninit_typed = true\nwarn_required_dynamic_aliases = true\nwarn_untyped_fields = true\n</code></pre></p>"},{"location":"pycharm_plugin/","title":"PyCharm plugin","text":"<p>While pydantic will work well with any IDE out of the box, a  PyCharm plugin offering improved pydantic integration is available on the JetBrains Plugins Repository for PyCharm. You can install the plugin for free from the plugin marketplace (PyCharm's Preferences -&gt; Plugin -&gt; Marketplace -&gt; search \"pydantic\").</p> <p>The plugin currently supports the following features:</p> <ul> <li>For <code>pydantic.BaseModel.__init__</code>:<ul> <li>Inspection</li> <li>Autocompletion</li> <li>Type-checking</li> </ul> </li> </ul> <ul> <li>For fields of <code>pydantic.BaseModel</code>:<ul> <li>Refactor-renaming fields updates <code>__init__</code> calls, and affects sub- and super-classes</li> <li>Refactor-renaming <code>__init__</code> keyword arguments updates field names, and affects sub- and super-classes</li> </ul> </li> </ul> <p>More information can be found on the official plugin page and Github repository.</p>"},{"location":"visual_studio_code/","title":"Visual Studio Code","text":"<p>pydantic works well with any editor or IDE out of the box because it's made on top of standard Python type annotations.</p> <p>When using Visual Studio Code (VS Code), there are some additional editor features supported, comparable to the ones provided by the PyCharm plugin.</p> <p>This means that you will have autocompletion (or \"IntelliSense\") and error checks for types and required arguments even while creating new pydantic model instances.</p> <p></p>"},{"location":"visual_studio_code/#configure-vs-code","title":"Configure VS Code","text":"<p>To take advantage of these features, you need to make sure you configure VS Code correctly, using the recommended settings.</p> <p>In case you have a different configuration, here's a short overview of the steps.</p>"},{"location":"visual_studio_code/#install-pylance","title":"Install Pylance","text":"<p>You should use the Pylance extension for VS Code. It is the recommended, next-generation, official VS Code plug-in for Python.</p> <p>Pylance is installed as part of the Python Extension for VS Code by default, so it should probably just work. Otherwise, you can double check it's installed and enabled in your editor.</p>"},{"location":"visual_studio_code/#configure-your-environment","title":"Configure your environment","text":"<p>Then you need to make sure your editor knows the Python environment (probably a virtual environment) for your Python project.</p> <p>This would be the environment in where you installed pydantic.</p>"},{"location":"visual_studio_code/#configure-pylance","title":"Configure Pylance","text":"<p>With the default configurations, you will get support for autocompletion, but Pylance might not check for type errors.</p> <p>You can enable type error checks from Pylance with these steps:</p> <ul> <li>Open the \"User Settings\"</li> <li>Search for <code>Type Checking Mode</code></li> <li>You will find an option under <code>Python \u203a Analysis: Type Checking Mode</code></li> <li>Set it to <code>basic</code> or <code>strict</code> (by default it's <code>off</code>)</li> </ul> <p></p> <p>Now you will not only get autocompletion when creating new pydantic model instances but also error checks for required arguments.</p> <p></p> <p>And you will also get error checks for invalid data types.</p> <p></p> <p>Technical Details</p> <p>Pylance is the VS Code extension, it's closed source, but free to use. Underneath, Pylance uses an open source tool (also from Microsoft) called Pyright that does all the heavy lifting.</p> <p>You can read more about it in the Pylance Frequently Asked Questions.</p>"},{"location":"visual_studio_code/#configure-mypy","title":"Configure mypy","text":"<p>You might also want to configure mypy in VS Code to get mypy error checks inline in your editor (alternatively/additionally to Pylance).</p> <p>This would include the errors detected by the pydantic mypy plugin, if you configured it.</p> <p>To enable mypy in VS Code, do the following:</p> <ul> <li>Open the \"User Settings\"</li> <li>Search for <code>Mypy Enabled</code></li> <li>You will find an option under <code>Python \u203a Linting: Mypy Enabled</code></li> <li>Check the box (by default it's unchecked)</li> </ul> <p></p>"},{"location":"visual_studio_code/#tips-and-tricks","title":"Tips and tricks","text":"<p>Here are some additional tips and tricks to improve your developer experience when using VS Code with pydantic.</p>"},{"location":"visual_studio_code/#strict-errors","title":"Strict errors","text":"<p>The way this additional editor support works is that Pylance will treat your pydantic models as if they were Python's pure <code>dataclasses</code>.</p> <p>And it will show strict type error checks about the data types passed in arguments when creating a new pydantic model instance.</p> <p>In this example you can see that it shows that a <code>str</code> of <code>'23'</code> is not a valid <code>int</code> for the argument <code>age</code>.</p> <p></p> <p>It would expect <code>age=23</code> instead of <code>age='23'</code>.</p> <p>Nevertheless, the design, and one of the main features of pydantic, is that it is very lenient with data types.</p> <p>It will actually accept the <code>str</code> with value <code>'23'</code> and will convert it to an <code>int</code> with value <code>23</code>.</p> <p>These strict error checks are very useful most of the time and can help you detect many bugs early. But there are cases, like with <code>age='23'</code>, where they could be inconvenient by reporting a \"false positive\" error.</p> <p>This example above with <code>age='23'</code> is intentionally simple, to show the error and the differences in types.</p> <p>But more common cases where these strict errors would be inconvenient would be when using more sophisticated data types, like <code>int</code> values for <code>datetime</code> fields, or <code>dict</code> values for pydantic sub-models.</p> <p>For example, this is valid for pydantic:</p> <pre><code>from pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nclass Quest(BaseModel):\n    title: str\n    knight: Knight\n\n\nquest = Quest(\n    title='To seek the Holy Grail',\n    knight={'title': 'Sir Lancelot', 'age': 23}\n)\n</code></pre> <p>The type of the field <code>knight</code> is declared with the class <code>Knight</code> (a pydantic model) and the code is passing a literal <code>dict</code> instead. This is still valid for pydantic, and the <code>dict</code> would be automatically converted to a <code>Knight</code> instance.</p> <p>Nevertheless, it would be detected as a type error:</p> <p></p> <p>In those cases, there are several ways to disable or ignore strict errors in very specific places, while still preserving them in the rest of the code.</p> <p>Below are several techniques to achieve it.</p>"},{"location":"visual_studio_code/#disable-type-checks-in-a-line","title":"Disable type checks in a line","text":"<p>You can disable the errors for a specific line using a comment of:</p> <pre><code># type: ignore\n</code></pre> <p>or (to be specific to pylance/pyright):</p> <pre><code># pyright: ignore\n</code></pre> <p>(pyright is the language server used by Pylance.).</p> <p>coming back to the example with <code>age='23'</code>, it would be:</p> <pre><code>from pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nlancelot = Knight(title='Sir Lancelot', age='23')  # pyright: ignore\n</code></pre> <p>that way Pylance and mypy will ignore errors in that line.</p> <p>Pros: it's a simple change in that line to remove errors there.</p> <p>Cons: any other error in that line will also be omitted, including type checks, misspelled arguments, required arguments not provided, etc.</p>"},{"location":"visual_studio_code/#override-the-type-of-a-variable","title":"Override the type of a variable","text":"<p>You can also create a variable with the value you want to use and declare it's type explicitly with <code>Any</code>.</p> <pre><code>from typing import Any\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nage_str: Any = '23'\nlancelot = Knight(title='Sir Lancelot', age=age_str)\n</code></pre> <p>that way Pylance and mypy will interpret the variable <code>age_str</code> as if they didn't know its type, instead of knowing it has a type of <code>str</code> when an <code>int</code> was expected (and then showing the corresponding error).</p> <p>Pros: errors will be ignored only for a specific value, and you will still see any additional errors for the other arguments.</p> <p>Cons: it requires importing <code>Any</code> and a new variable in a new line for each argument that needs ignoring errors.</p>"},{"location":"visual_studio_code/#override-the-type-of-a-value-with-cast","title":"Override the type of a value with <code>cast</code>","text":"<p>The same idea from the previous example can be put on the same line with the help of <code>cast()</code>.</p> <p>This way, the type declaration of the value is overridden inline, without requiring another variable.</p> <pre><code>from typing import Any, cast\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nlancelot = Knight(title='Sir Lancelot', age=cast(Any, '23'))\n</code></pre> <p><code>cast(Any, '23')</code> doesn't affect the value, it's still just <code>'23'</code>, but now Pylance and mypy will assume it is of type <code>Any</code>, which means, they will act as if they didn't know the type of the value.</p> <p>So, this is the equivalent of the previous example, without the additional variable.</p> <p>Pros: errors will be ignored only for a specific value, and you will still see any additional errors for the other arguments. There's no need for additional variables.</p> <p>Cons: it requires importing <code>Any</code> and <code>cast</code>, and if you are not used to using <code>cast()</code>, it could seem strange at first.</p>"},{"location":"visual_studio_code/#config-in-class-arguments","title":"Config in class arguments","text":"<p>pydantic has a rich set of Model Configurations available.</p> <p>These configurations can be set in an internal <code>class Config</code> on each model:</p> <pre><code>from pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n    class Config:\n        frozen = True\n</code></pre> <p>or passed as keyword arguments when defining the model class:</p> <pre><code>from pydantic import BaseModel\n\n\nclass Knight(BaseModel, frozen=True):\n    title: str\n    age: int\n    color: str = 'blue'\n</code></pre> <p>The specific configuration <code>frozen</code> (in beta) has a special meaning.</p> <p>It prevents other code from changing a model instance once it's created, keeping it \"frozen\".</p> <p>When using the second version to declare <code>frozen=True</code> (with keyword arguments in the class definition),  Pylance can use it to help you check in your code and detect errors when something is trying to set values  in a model that is \"frozen\".</p> <p></p>"},{"location":"visual_studio_code/#basesettings-and-ignoring-pylancepyright-errors","title":"BaseSettings and ignoring Pylance/pyright errors","text":"<p>Pylance/pyright does not work well with <code>BaseSettings</code> - fields in settings classes can be  configured via environment variables and therefore \"required\" fields do not have to be explicitly set when initialising a settings instance. However, pyright considers these fields as \"required\" and will therefore show an error when they're not set.</p> <p>See #3753 for an explanation of the reasons behind this, and why we can't avoid the problem.</p> <p>There are two potential workarounds:</p> <ul> <li>use an ignore comment (<code># pyright: ignore</code>) when initialising <code>settings</code></li> <li>or, use <code>settings.parse_obj({})</code> to avoid the warning</li> </ul>"},{"location":"visual_studio_code/#adding-a-default-with-field","title":"Adding a default with <code>Field</code>","text":"<p>Pylance/pyright requires <code>default</code> to be a keyword argument to <code>Field</code> in order to infer that the field is optional.</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Knight(BaseModel):\n    title: str = Field(default='Sir Lancelot')  # this is okay\n    age: int = Field(23)  # this works fine at runtime but will case an error for pyright\n\nlance = Knight()  # error: Argument missing for parameter \"age\" \n</code></pre> <p>Like the issue with <code>BaseSettings</code>, this is a limitation of dataclass transforms and cannot be fixed in pydantic.</p>"},{"location":"visual_studio_code/#technical-details","title":"Technical Details","text":"<p>Warning</p> <p>As a pydantic user, you don't need the details below. Feel free to skip the rest of this section.</p> <p>These details are only useful for other library authors, etc.</p> <p>This additional editor support works by implementing the proposed draft standard for Dataclass Transform.</p> <p>The proposed draft standard is written by Eric Traut, from the Microsoft team, the same author of the open source package Pyright (used by Pylance to provide Python support in VS Code).</p> <p>The intention of the standard is to provide a way for libraries like pydantic and others to tell editors and tools that they (the editors) should treat these libraries (e.g. pydantic) as if they were <code>dataclasses</code>, providing autocompletion, type checks, etc.</p> <p>The draft standard also includes an Alternate Form for early adopters, like pydantic, to add support for it right away, even before the new draft standard is finished and approved.</p> <p>This new draft standard, with the Alternate Form, is already supported by Pyright, so it can be used via Pylance in VS Code.</p> <p>As it is being proposed as an official standard for Python, other editors can also easily add support for it.</p> <p>And authors of other libraries similar to pydantic can also easily adopt the standard right away (using the \"Alternate Form\") and get the benefits of these additional editor features.</p>"},{"location":"blog/pydantic-v2-alpha/","title":"Pydantic V2 Pre Release","text":"<p>Terrence Dorsey &amp; Samuel Colvin \u2022\u00a0    \u2022\u00a0    \u2022\u00a0    April 3, 2023 \u2022\u00a0    8 min read</p> <p>We're excited to announce the first alpha release of Pydantic V2!</p> <p>This first Pydantic V2 alpha is no April Fool's joke \u2014 for a start we missed our April 1st target date . After a year's work, we invite you to explore the improvements we've made and give us your feedback.  We look forward to hearing your thoughts and working together to improve the library.</p> <p>For many of you, Pydantic is already a key part of your Python toolkit and needs no introduction \u2014  we hope you'll find the improvements and additions in Pydantic V2 useful.</p> <p>If you're new to Pydantic: Pydantic is an open-source Python library that provides powerful data parsing and validation \u2014  including type coercion and useful error messages when typing issues arise \u2014 and settings management capabilities. See the docs for examples of Pydantic at work.</p>"},{"location":"blog/pydantic-v2-alpha/#getting-started-with-the-pydantic-v2-alpha","title":"Getting started with the Pydantic V2 alpha","text":"<p>Your feedback will be a critical part of ensuring that we have made the right tradeoffs with the API changes in V2.</p> <p>To get started with the Pydantic V2 alpha, install it from PyPI.  We recommend using a virtual environment to isolate your testing environment:</p> <pre><code>pip install --pre -U \"pydantic&gt;=2.0a1\"\n</code></pre> <p>Note that there are still some rough edges and incomplete features, and while trying out the Pydantic V2 alpha releases you may experience errors.  We encourage you to try out the alpha releases in a test environment and not in production.  Some features are still in development, and we will continue to make changes to the API.</p> <p>If you do encounter any issues, please create an issue in GitHub using the <code>bug V2</code> label.  This will help us to actively monitor and track errors, and to continue to improve the library\u2019s performance.</p> <p>This will be the first of several upcoming alpha releases. As you evaluate our changes and enhancements,  we encourage you to share your feedback with us.</p> <p>Please let us know:</p> <ul> <li>If you don't like the changes, so we can make sure Pydantic remains a library you enjoy using.</li> <li>If this breaks your usage of Pydantic so we can fix it, or at least describe a migration path.</li> </ul> <p>Thank you for your support, and we look forward to your feedback.</p>"},{"location":"blog/pydantic-v2-alpha/#headlines","title":"Headlines","text":"<p>Here are some of the most interesting new features in the current Pydantic V2 alpha release.  For background on plans behind these features, see the earlier Pydantic V2 Plan blog post.</p> <p>The biggest change to Pydantic V2 is <code>pydantic-core</code> \u2014 all validation logic has been rewritten in Rust and moved to a separate package, <code>pydantic-core</code>. This has a number of big advantages:</p> <ul> <li>Performance - Pydantic V2 is 5-50x faster than Pydantic V1.</li> <li>Safety &amp; maintainability - We've made changes to the architecture that we think will help us maintain Pydantic V2 with far fewer bugs in the long term.</li> </ul> <p>With the use of <code>pydantic-core</code>, the majority of the logic in the Pydantic library is dedicated to generating \"pydantic core schema\" \u2014 the schema used define the behaviour of the new, high-performance <code>pydantic-core</code> validators and serializers.  </p>"},{"location":"blog/pydantic-v2-alpha/#ready-for-experimentation","title":"Ready for experimentation","text":"<ul> <li>BaseModel - the core of validation in Pydantic V1 remains, albeit with new method names.</li> <li>Dataclasses - Pydantic dataclasses are improved and ready to test.</li> <li>Serialization - dumping/serialization/marshalling is significantly more flexible, and ready to test.</li> <li>Strict mode - one of the biggest additions in Pydantic V2 is strict mode, which is ready to test.</li> <li>JSON Schema - generation of JSON Schema is much improved and ready to test.</li> <li>Generic Models - are much improved and ready to test.</li> <li>Recursive Models - and validation of recursive data structures is much improved and ready to test.</li> <li>Custom Types - custom types have a new interface and are ready to test.</li> <li>Custom Field Modifiers - used via <code>Annotated[]</code> are working and in use in Pydantic itself.</li> <li>Validation without a BaseModel - the new <code>AnalyzedType</code> class allows validation without the need for a <code>BaseModel</code> class, and it's ready to test.</li> <li>TypedDict - we now have full support for <code>TypedDict</code> via <code>AnalyzedType</code>, it's ready to test.</li> </ul>"},{"location":"blog/pydantic-v2-alpha/#still-under-construction","title":"Still under construction","text":"<ul> <li>Documentation - we're working hard on full documentation for V2, but it's not ready yet.</li> <li>Conversion Table - a big addition to the documentation will be a conversion table showing how types are coerced, this is a WIP.</li> <li>BaseSettings - <code>BaseSettings</code> will move to a separate <code>pydantic-settings</code> package, it's not yet ready to test.    Notice: since <code>pydantic-settings</code> is not yet ready to release, there's no support for <code>BaseSettings</code> in the first alpha release.</li> <li>validate_arguments - the <code>validate_arguments</code> decorator remains and is working, but hasn't been updated yet.</li> <li>Hypothesis Plugin - the Hypothesis plugin is yet to be updated.</li> <li>computed fields - we know a lot of people are waiting for this, we will include it in Pydantic V2.</li> <li>Error messages - could use some love, and links to docs in error messages are still to be added.</li> <li>Migration Guide - we have some pointers below, but this needs completing.</li> </ul>"},{"location":"blog/pydantic-v2-alpha/#migration-guide","title":"Migration Guide","text":"<p>Please note: this is just the beginning of a migration guide. We'll work hard up to the final release to prepare a full migration guide, but for now the following pointers should be some help while experimenting with V2.</p>"},{"location":"blog/pydantic-v2-alpha/#changes-to-basemodel","title":"Changes to BaseModel","text":"<ul> <li>Various method names have been changed; <code>BaseModel</code> methods all start with <code>model_</code> now.    Where possible, we have retained the old method names to help ease migration, but calling them will result in <code>DeprecationWarning</code>s.<ul> <li>Some of the built-in data loading functionality has been slated for removal.    In particular, <code>parse_raw</code> and <code>parse_file</code> are now deprecated. You should load the data and then pass it to <code>model_validate</code>.</li> </ul> </li> <li>The <code>from_orm</code> method has been removed; you can now just use <code>model_validate</code> (equivalent to <code>parse_obj</code> from Pydantic V1) to achieve something similar,    as long as you've set <code>from_attributes=True</code> in the model config.</li> <li>The <code>__eq__</code> method has changed for models; models are no longer considered equal to the dicts.</li> <li>Custom <code>__init__</code> overrides won't be called. This should be replaced with a <code>@root_validator</code>.</li> <li>Due to inconsistency with the rest of the library, we have removed the special behavior of models   using the <code>__root__</code> field, and have disallowed the use of an attribute with this name to prevent confusion.   However, you can achieve equivalent behavior with a \"standard\" field name through the use of <code>@root_validator</code>,   <code>@model_serializer</code>, and <code>__pydantic_modify_json_schema__</code>. You can see an example of this   here.</li> </ul>"},{"location":"blog/pydantic-v2-alpha/#changes-to-pydantic-dataclasses","title":"Changes to Pydantic Dataclasses","text":"<ul> <li>The <code>__post_init__</code> in Pydantic dataclasses will now be called after validation, rather than before.</li> <li>We no longer support <code>extra='allow'</code> for Pydantic dataclasses, where extra attributes passed to the initializer would be    stored as extra fields on the dataclass. <code>extra='ignore'</code> is still supported for the purposes of allowing extra fields while parsing data; they just aren't stored.</li> <li><code>__post_init_post_parse__</code> has been removed.</li> <li>Nested dataclasses no longer accept tuples as input, only dict.</li> </ul>"},{"location":"blog/pydantic-v2-alpha/#changes-to-config","title":"Changes to Config","text":"<ul> <li>To specify config on a model, it is now deprecated to create a class called <code>Config</code> in the namespace of the parent <code>BaseModel</code> subclass.    Instead, you just need to set a class attribute called <code>model_config</code> to be a dict with the key/value pairs you want to be used as the config.</li> </ul> <p>The following config settings have been removed:</p> <ul> <li><code>allow_mutation</code>.</li> <li><code>error_msg_templates</code>.</li> <li><code>fields</code> \u2014 this was the source of various bugs, so has been removed. You should be able to use <code>Annotated</code> on fields to modify them as desired.</li> <li><code>getter_dict</code> \u2014 <code>orm_mode</code> has been removed, and this implementation detail is no longer necessary.</li> <li><code>schema_extra</code> \u2014 you should now use the <code>json_schema_extra</code> keyword argument to <code>pydantic.Field</code>.</li> <li><code>smart_union</code>.</li> <li><code>underscore_attrs_are_private</code> \u2014 the Pydantic V2 behavior is now the same as if this was always set to <code>True</code> in Pydantic V1.</li> </ul> <p>The following config settings have been renamed:</p> <ul> <li><code>allow_population_by_field_name</code> \u2192 <code>populate_by_name</code></li> <li><code>anystr_lower</code> \u2192 <code>str_to_lower</code></li> <li><code>anystr_strip_whitespace</code> \u2192 <code>str_strip_whitespace</code></li> <li><code>anystr_upper</code> \u2192 <code>str_to_upper</code></li> <li><code>keep_untouched</code> \u2192 <code>ignored_types</code></li> <li><code>max_anystr_length</code> \u2192 <code>str_max_length</code></li> <li><code>min_anystr_length</code> \u2192 <code>str_min_length</code></li> <li><code>orm_mode</code> \u2192 <code>from_attributes</code></li> <li><code>validate_all</code> \u2192 <code>validate_default</code></li> </ul>"},{"location":"blog/pydantic-v2-alpha/#changes-to-validators","title":"Changes to Validators","text":"<ul> <li>Raising a <code>TypeError</code> inside a validator no longer produces a <code>ValidationError</code>, but just raises the <code>TypeError</code> directly.    This was necessary to prevent certain common bugs (such as calling functions with invalid signatures) from    being unintentionally converted into <code>ValidationError</code> and displayed to users.    If you really want <code>TypeError</code> to be converted to a <code>ValidationError</code> you should use a <code>try: except:</code> block that will catch it and do the conversion.</li> <li><code>each_item</code> validators are deprecated and should be replaced with a type annotation using <code>Annotated</code> to apply a validator    or with a validator that operates on all items at the top level.</li> <li>Changes to <code>@validator</code>-decorated function signatures.</li> <li>The <code>stricturl</code> type has been removed.</li> <li>Root validators can no longer be run with <code>skip_on_failure=False</code>.</li> </ul>"},{"location":"blog/pydantic-v2-alpha/#changes-to-validation-of-specific-types","title":"Changes to Validation of specific types","text":"<ul> <li>Integers outside the valid range of 64 bit integers will cause <code>ValidationError</code>s during parsing.    To work around this, use an <code>IsInstance</code> validator (more details to come).</li> <li>Subclasses of built-ins won't validate into their subclass types; you'll need to use an <code>IsInstance</code> validator to validate these types.</li> </ul>"},{"location":"blog/pydantic-v2-alpha/#changes-to-generic-models","title":"Changes to Generic models","text":"<ul> <li>While it does not raise an error at runtime yet, subclass checks for parametrized generics should no longer be used.    These will result in <code>TypeError</code>s and we can't promise they will work forever. However, it will be okay to do subclass checks against non-parametrized generic models</li> </ul>"},{"location":"blog/pydantic-v2-alpha/#other-changes","title":"Other changes","text":"<ul> <li><code>GetterDict</code> has been removed, as it was just an implementation detail for <code>orm_mode</code>, which has been removed.</li> </ul>"},{"location":"blog/pydantic-v2-alpha/#analyzedtype","title":"AnalyzedType","text":"<p>Pydantic V1 didn't have good support for validation or serializing non-<code>BaseModel</code>. To work with them you had to create a \"root\" model or use the utility functions in <code>pydantic.tools</code> (<code>parse_obj_as</code> and <code>schema_of</code>). In Pydantic V2 this is a lot easier: the <code>AnalyzedType</code> class lets you build an object that behaves almost like a <code>BaseModel</code> class which you can use for a lot of the use cases of root models and as a complete replacement for <code>parse_obj_as</code> and <code>schema_of</code>.</p> <pre><code>from typing import List\nfrom pydantic import AnalyzedType\n\nvalidator = AnalyzedType(List[int])\nassert validator.validate_python(['1', '2', '3']) == [1, 2, 3]\nprint(validator.json_schema())\n# {'type': 'array', 'items': {'type': 'integer'}}\n</code></pre> <p>Note that this API is provisional and may change before the final release of Pydantic V2.</p>"},{"location":"blog/pydantic-v2/","title":"Pydantic V2 Plan","text":"<p>Samuel Colvin \u2022\u00a0    \u2022\u00a0    \u2022\u00a0    Jul 10, 2022 \u2022\u00a0    25 min read</p> <p>Updated late 10 Jul 2022, see pydantic#4226.</p> <p>Update 30 Dec 2022: The new release deadline for Pydantic V2 is the end of Q1 2023,  see pydantic#4887 for more details, further updates will be posted on that issue.</p> <p>I've spoken to quite a few people about pydantic V2, and mention it in passing even more.</p> <p>I owe people a proper explanation of the plan for V2:</p> <ul> <li>What we will add</li> <li>What we will remove</li> <li>What we will change</li> <li>How I'm intending to go about completing it and getting it released</li> <li>Some idea of timeframe </li> </ul> <p>Here goes...</p> <p>Enormous thanks to Eric Jolibois, Laurence Watson,  Sebasti\u00e1n Ram\u00edrez, Adrian Garcia Badaracco,  Tom Hamilton Stubber, Zac Hatfield-Dodds,  Tom &amp; Hasan Ramezani for reviewing this blog post, putting up with (and correcting) my horrible typos and making great suggestions that have made this post and Pydantic V2 materially better.</p>"},{"location":"blog/pydantic-v2/#plan-timeframe","title":"Plan &amp; Timeframe","text":"<p>I'm currently taking a kind of sabbatical after leaving my last job to get pydantic V2 released. Why? I ask myself that question quite often. I'm very proud of how much pydantic is used, but I'm less proud of its internals. Since it's something people seem to care about and use quite a lot (26m downloads a month, used by 72k public repos, 10k stars). I want it to be as good as possible.</p> <p>While I'm on the subject of why, how and my odd sabbatical: if you work for a large company who use pydantic a lot, you might encourage the company to sponsor me a meaningful amount, like Salesforce did (if your organisation is not open to donations, I can also offer consulting services). This is not charity, recruitment or marketing - the argument should be about how much the company will save if pydantic is 10x faster, more stable and more powerful - it would be worth paying me 10% of that to make it happen.</p> <p>Before pydantic V2 can be released, we need to release pydantic V1.10 - there are lots of changes in the main branch of pydantic contributed by the community, it's only fair to provide a release including those changes, many of them will remain unchanged for V2, the rest will act as a requirement to make sure pydantic V2 includes the capabilities they implemented.</p> <p>The basic road map for me is as follows:</p> <ol> <li>Implement a few more features in pydantic-core, and release a first version, see below</li> <li>Work on getting pydantic V1.10 out - basically merge all open PRs that are finished</li> <li>Release pydantic V1.10</li> <li>Delete all stale PRs which didn't make it into V1.10, apologise profusely to their authors who put their valuable    time into pydantic only to have their PRs closed     (and explain when and how they can rebase and recreate the PR)</li> <li>Rename <code>master</code> to <code>main</code>, seems like a good time to do this</li> <li>Change the main branch of pydantic to target V2</li> <li>Start tearing pydantic code apart and see how many existing tests can be made to pass</li> <li>Rinse, repeat</li> <li>Release pydantic V2 </li> </ol> <p>Plan is to have all this done by the end of October, definitely by the end of the year.</p>"},{"location":"blog/pydantic-v2/#breaking-changes-compatibility","title":"Breaking Changes &amp; Compatibility","text":"<p>While we'll do our best to avoid breaking changes, some things will break.</p> <p>As per the greatest pun in modern TV history.</p> <p>You can't make a Tomelette without breaking some Greggs.</p> <p>Where possible, if breaking changes are unavoidable, we'll try to provide warnings or errors to make sure those changes are obvious to developers.</p>"},{"location":"blog/pydantic-v2/#motivation-pydantic-core","title":"Motivation &amp; <code>pydantic-core</code>","text":"<p>Since pydantic's initial release, with the help of wonderful contributors Eric Jolibois, Sebasti\u00e1n Ram\u00edrez, David Montague and many others, the package and its usage have grown enormously. The core logic however has remained mostly unchanged since the initial experiment. It's old, it smells, it needs to be rebuilt.</p> <p>The release of version 2 is an opportunity to rebuild pydantic and correct many things that don't make sense - to make pydantic amazing .</p> <p>The core validation logic of pydantic V2 will be performed by a separate package pydantic-core which I've been building over the last few months. pydantic-core is written in Rust using the excellent pyo3 library which provides rust bindings for python.</p> <p>The motivation for building pydantic-core in Rust is as follows:</p> <ol> <li>Performance, see below</li> <li>Recursion and code separation - with no stack and little-to-no overhead for extra function calls,    Rust allows pydantic-core to be implemented as a tree of small validators which call each other,    making code easier to understand and extend without harming performance</li> <li>Safety and complexity - pydantic-core is a fairly complex piece of code which has to draw distinctions    between many different errors, Rust is great in situations like this,    it should minimise bugs () and allow the codebase to be extended for a long time to come</li> </ol> <p>Note</p> <p>The python interface to pydantic shouldn't change as a result of using pydantic-core, instead pydantic will use type annotations to build a schema for pydantic-core to use.</p> <p>pydantic-core is usable now, albeit with an unintuitive API, if you're interested, please give it a try.</p> <p>pydantic-core provides validators for common data types, see a list here. Other, less commonly used data types will be supported via validator functions implemented in pydantic, in Python.</p> <p>See pydantic-core#153 for a summary of what needs to be completed before its first release.</p>"},{"location":"blog/pydantic-v2/#headlines","title":"Headlines","text":"<p>Here are some of the biggest changes expected in V2.</p>"},{"location":"blog/pydantic-v2/#performance","title":"Performance","text":"<p>As a result of the move to Rust for the validation logic (and significant improvements in how validation objects are structured) pydantic V2 will be significantly faster than pydantic V1.</p> <p>Looking at the pydantic-core benchmarks today, pydantic V2 is between 4x and 50x faster than pydantic V1.9.1.</p> <p>In general, pydantic V2 is about 17x faster than V1 when validating a model containing a range of common fields.</p>"},{"location":"blog/pydantic-v2/#strict-mode","title":"Strict Mode","text":"<p>People have long complained about pydantic for coercing data instead of throwing an error. E.g. input to an <code>int</code> field could be <code>123</code> or the string <code>\"123\"</code> which would be converted to <code>123</code> While this is very useful in many scenarios (think: URL parameters, environment variables, user input), there are some situations where it's not desirable.</p> <p>pydantic-core comes with \"strict mode\" built in. With this, only the exact data type is allowed, e.g. passing <code>\"123\"</code> to an <code>int</code> field would result in a validation error.</p> <p>This will allow pydantic V2 to offer a <code>strict</code> switch which can be set on either a model or a field.</p>"},{"location":"blog/pydantic-v2/#formalised-conversion-table","title":"Formalised Conversion Table","text":"<p>As well as complaints about coercion, another legitimate complaint was inconsistency around data conversion.</p> <p>In pydantic V2, the following principle will govern when data should be converted in \"lax mode\" (<code>strict=False</code>):</p> <p>If the input data has a SINGLE and INTUITIVE representation, in the field's type, AND no data is lost during the conversion, then the data will be converted; otherwise a validation error is raised. There is one exception to this rule: string fields - virtually all data has an intuitive representation as a string (e.g. <code>repr()</code> and <code>str()</code>), therefore a custom rule is required: only <code>str</code>, <code>bytes</code> and <code>bytearray</code> are valid as inputs to string fields.</p> <p>Some examples of what that means in practice:</p> Field Type Input Single &amp; Intuitive R. All Data Preserved Result <code>int</code> <code>\"123\"</code> Convert <code>int</code> <code>123.0</code> Convert <code>int</code> <code>123.1</code> Error <code>date</code> <code>\"2020-01-01\"</code> Convert <code>date</code> <code>\"2020-01-01T00:00:00\"</code> Convert <code>date</code> <code>\"2020-01-01T12:00:00\"</code> Error <code>int</code> <code>b\"1\"</code> Error <p>(For the last case converting <code>bytes</code> to an <code>int</code> could reasonably mean <code>int(bytes_data.decode())</code> or <code>int.from_bytes(b'1', 'big/little')</code>, hence an error)</p> <p>In addition to the general rule, we'll provide a conversion table which defines exactly what data will be allowed to which field types. See the table below for a start on this.</p>"},{"location":"blog/pydantic-v2/#built-in-json-support","title":"Built in JSON support","text":"<p>pydantic-core can parse JSON directly into a model or output type, this both improves performance and avoids issue with strictness - e.g. if you have a strict model with a <code>datetime</code> field, the input must be a <code>datetime</code> object, but clearly that makes no sense when parsing JSON which has no <code>datatime</code> type. Same with <code>bytes</code> and many other types.</p> <p>Pydantic V2 will therefore allow some conversion when validating JSON directly, even in strict mode (e.g. <code>ISO8601 string -&gt; datetime</code>, <code>str -&gt; bytes</code>) even though this would not be allowed when validating a python object.</p> <p>In future direct validation of JSON will also allow:</p> <ul> <li>parsing in a separate thread while starting validation in the main thread</li> <li>line numbers from JSON to be included in the validation errors</li> </ul> <p>(These features will not be included in V2, but instead will hopefully be added later.)</p> <p>Note</p> <p>Pydantic has always had special support for JSON, that is not going to change.</p> <p>While in theory other formats could be specifically supported, the overheads and development time are  significant and I don't think there's another format that's used widely enough to be worth specific logic. Other formats can be parsed to python then validated, similarly when serialising, data can be exported to a python object, then serialised, see below.</p>"},{"location":"blog/pydantic-v2/#validation-without-a-model","title":"Validation without a Model","text":"<p>In pydantic V1 the core of all validation was a pydantic model, this led to a significant performance penalty  and extra complexity when the output data type was not a model.</p> <p>pydantic-core operates on a tree of validators with no \"model\" type required at the base of that tree. It can therefore validate a single <code>string</code> or <code>datetime</code> value, a <code>TypedDict</code> or a <code>Model</code> equally easily.</p> <p>This feature will provide significant addition performance improvements in scenarios like:</p> <ul> <li>Adding validation to <code>dataclasses</code></li> <li>Validating URL arguments, query strings, headers, etc. in FastAPI</li> <li>Adding validation to <code>TypedDict</code></li> <li>Function argument validation</li> <li>Adding validation to your custom classes, decorators...</li> </ul> <p>In effect - anywhere where you don't care about a traditional model class instance.</p> <p>We'll need to add standalone methods for generating JSON Schema and dumping these objects to JSON, etc.</p>"},{"location":"blog/pydantic-v2/#required-vs-nullable-cleanup","title":"Required vs. Nullable Cleanup","text":"<p>Pydantic previously had a somewhat confused idea about \"required\" vs. \"nullable\". This mostly resulted from my misgivings about marking a field as <code>Optional[int]</code> but requiring a value to be provided but allowing it to be <code>None</code> - I didn't like using the word \"optional\" in relation to a field which was not optional.</p> <p>In pydantic V2, pydantic will move to match dataclasses, thus:</p> Required vs. Nullable<pre><code>from pydantic import BaseModel\n\nclass Foo(BaseModel):\n    f1: str  # required, cannot be None\n    f2: str | None  # required, can be None - same as Optional[str] / Union[str, None]\n    f3: str | None = None  # not required, can be None\n    f4: str = 'Foobar'  # not required, but cannot be None\n</code></pre>"},{"location":"blog/pydantic-v2/#validator-function-improvements","title":"Validator Function Improvements","text":"<p>This is one of the changes in pydantic V2 that I'm most excited about, I've been talking about something like this for a long time, see pydantic#1984, but couldn't find a way to do this until now.</p> <p>Fields which use a function for validation can be any of the following types:</p> <ul> <li>function before mode - where the function is called before the inner validator is called</li> <li>function after mode - where the function is called after the inner validator is called</li> <li>plain mode - where there's no inner validator</li> <li>wrap mode - where the function takes a reference to a function which calls the inner validator,   and can therefore modify the input before inner validation, modify the output after inner validation, conditionally   not call the inner validator or catch errors from the inner validator and return a default value, or change the error</li> </ul> <p>An example how a wrap validator might look:</p> Wrap mode validator function<pre><code>from datetime import datetime\nfrom pydantic import BaseModel, ValidationError, validator\n\nclass MyModel(BaseModel):\n    timestamp: datetime\n\n    @validator('timestamp', mode='wrap')\n    def validate_timestamp(cls, v, handler):\n        if v == 'now':\n            # we don't want to bother with further validation, \n            # just return the new value\n            return datetime.now()\n        try:\n            return handler(v)\n        except ValidationError:\n            # validation failed, in this case we want to \n            # return a default value\n            return datetime(2000, 1, 1)\n</code></pre> <p>As well as being powerful, this provides a great \"escape hatch\" when pydantic validation doesn't do what you need.</p>"},{"location":"blog/pydantic-v2/#more-powerful-aliases","title":"More powerful alias(es)","text":"<p>pydantic-core can support alias \"paths\" as well as simple string aliases to flatten data as it's validated.</p> <p>Best demonstrated with an example:</p> Alias paths<pre><code>from pydantic import BaseModel, Field\n\n\nclass Foo(BaseModel):\n    bar: str = Field(aliases=[['baz', 2, 'qux']])\n\n\ndata = {\n    'baz': [\n        {'qux': 'a'},\n        {'qux': 'b'},\n        {'qux': 'c'},\n        {'qux': 'd'},\n    ]\n}\n\nfoo = Foo(**data)\nassert foo.bar == 'c'\n</code></pre> <p><code>aliases</code> is a list of lists because multiple paths can be provided, if so they're tried in turn until a value is found.</p> <p>Tagged unions will use the same logic as <code>aliases</code> meaning nested attributes can be used to select a schema to validate against.</p>"},{"location":"blog/pydantic-v2/#improvements-to-dumpingserializationexport","title":"Improvements to Dumping/Serialization/Export","text":"<p>(I haven't worked on this yet, so these ideas are only provisional)</p> <p>There has long been a debate about how to handle converting data when extracting it from a model. One of the features people have long requested is the ability to convert data to JSON compliant types while converting a model to a dict.</p> <p>My plan is to move data export into pydantic-core, with that, one implementation can support all export modes without compromising (and hopefully significantly improving) performance.</p> <p>I see four different export/serialisation scenarios:</p> <ol> <li>Extracting the field values of a model with no conversion, effectively <code>model.__dict__</code> but with the current filtering    logic provided by <code>.dict()</code></li> <li>Extracting the field values of a model recursively (effectively what <code>.dict()</code> does now) - sub-models are converted to    dicts, but other fields remain unchanged.</li> <li>Extracting data and converting at the same time (e.g. to JSON compliant types)</li> <li>Serialising data straight to JSON</li> </ol> <p>I think all 4 modes can be supported in a single implementation, with a kind of \"3.5\" mode where a python function is used to convert the data as the user wishes.</p> <p>The current <code>include</code> and <code>exclude</code> logic is extremely complicated, but hopefully it won't be too hard to translate it to Rust.</p> <p>We should also add support for <code>validate_alias</code> and <code>dump_alias</code> as well as the standard <code>alias</code> to allow for customising field keys.</p>"},{"location":"blog/pydantic-v2/#validation-context","title":"Validation Context","text":"<p>Pydantic V2 will add a new optional <code>context</code> argument to <code>model_validate</code> and <code>model_validate_json</code> which will allow you to pass information not available when creating a model to validators. See pydantic#1549 for motivation.</p> <p>Here's an example of <code>context</code> might be used:</p> Context during Validation<pre><code>from pydantic import BaseModel, EmailStr, validator\n\nclass User(BaseModel):\n    email: EmailStr\n    home_country: str\n\n    @validator('home_country')\n    def check_home_country(cls, v, context):\n        if v not in context['countries']:\n            raise ValueError('invalid country choice')\n        return v\n\nasync def add_user(post_data: bytes):\n    countries = set(await db_connection.fetch_all('select code from country'))\n    user = User.model_validate_json(post_data, context={'countries': countries})\n    ...\n</code></pre> <p>Note</p> <p>We (actually mostly Sebasti\u00e1n ) will have to make some changes to FastAPI to fully leverage <code>context</code> as we'd need some kind of dependency injection to build context before validation so models can still be passed as arguments to views. I'm sure he'll be game.</p> <p>Warning</p> <p>Although this will make it slightly easier to run synchronous IO (HTTP requests, DB. queries, etc.) from within validators, I strongly advise you keep IO separate from validation - do it before and use context, do it afterwards, avoid where possible making queries inside validation.</p>"},{"location":"blog/pydantic-v2/#model-namespace-cleanup","title":"Model Namespace Cleanup","text":"<p>For years I've wanted to clean up the model namespace, see pydantic#1001. This would avoid confusing gotchas when field names clash with methods on a model, it would also make it safer to add more methods to a model without risking new clashes.</p> <p>After much deliberation (and even giving a lightning talk at the python language submit about alternatives, see this discussion). I've decided to go with the simplest and clearest approach, at the expense of a bit more typing:</p> <p>All methods on models will start with <code>model_</code>, fields' names will not be allowed to start with <code>\"model\"</code> (aliases can be used if required).</p> <p>This will mean <code>BaseModel</code> will have roughly the following signature.</p> New BaseModel methods<pre><code>class BaseModel:\n    model_fields: List[FieldInfo]\n    \"\"\"previously `__fields__`, although the format will change a lot\"\"\"\n    @classmethod\n    def model_validate(cls, data: Any, *, context=None) -&gt; Self:  # (1)\n        \"\"\"\n        previously `parse_obj()`, validate data\n        \"\"\"\n    @classmethod\n    def model_validate_json(\n        cls,\n        data: str | bytes | bytearray,\n        *,\n        context=None\n    ) -&gt; Self:\n        \"\"\"\n        previously `parse_raw(..., content_type='application/json')`\n        validate data from JSON\n        \"\"\"\n    @classmethod\n    def model_is_instance(cls, data: Any, *, context=None) -&gt; bool: # (2)\n        \"\"\"\n        new, check if data is value for the model\n        \"\"\"\n    @classmethod\n    def model_is_instance_json(\n        cls,\n        data: str | bytes | bytearray,\n        *,\n        context=None\n    ) -&gt; bool:\n        \"\"\"\n        Same as `model_is_instance`, but from JSON\n        \"\"\"\n    def model_dump(\n        self,\n        include: ... = None,\n        exclude: ... = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        mode: Literal['unchanged', 'dicts', 'json-compliant'] = 'unchanged',\n        converter: Callable[[Any], Any] | None = None\n    ) -&gt; Any:\n        \"\"\"\n        previously `dict()`, as before\n        with new `mode` argument\n        \"\"\"\n    def model_dump_json(self, ...) -&gt; str:\n        \"\"\"\n        previously `json()`, arguments as above\n        effectively equivalent to `json.dump(self.model_dump(..., mode='json'))`,\n        but more performant\n        \"\"\"\n    def model_json_schema(self, ...) -&gt; dict[str, Any]:\n        \"\"\"\n        previously `schema()`, arguments roughly as before\n        JSON schema as a dict\n        \"\"\"\n    def model_update_forward_refs(self) -&gt; None:\n        \"\"\"\n        previously `update_forward_refs()`, update forward references\n        \"\"\"\n    @classmethod\n    def model_construct(\n        self,\n        _fields_set: set[str] | None = None,\n        **values: Any\n    ) -&gt; Self:\n        \"\"\"\n        previously `construct()`, arguments roughly as before\n        construct a model with no validation\n        \"\"\"\n    @classmethod\n    def model_customize_schema(cls, schema: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"\n        new, way to customize validation,\n        e.g. if you wanted to alter how the model validates certain types,\n        or add validation for a specific type without custom types or\n        decorated validators\n        \"\"\"\n    class ModelConfig:\n        \"\"\"\n        previously `Config`, configuration class for models\n        \"\"\"\n</code></pre> <ol> <li>see Validation Context for more information on <code>context</code></li> <li>see <code>is_instance</code> checks</li> </ol> <p>The following methods will be removed:</p> <ul> <li><code>.parse_file()</code> - was a mistake, should never have been in pydantic</li> <li><code>.parse_raw()</code> - partially replaced by <code>.model_validate_json()</code>, the other functionality was a mistake</li> <li><code>.from_orm()</code> - the functionality has been moved to config, see other improvements below</li> <li><code>.schema_json()</code> - mostly since it causes confusion between pydantic validation schema and JSON schema,   and can be replaced with just <code>json.dumps(m.model_json_schema())</code></li> <li><code>.copy()</code> instead we'll implement <code>__copy__</code> and let people use the <code>copy</code> module   (this removes some functionality) from <code>copy()</code> but there are bugs and ambiguities with the functionality anyway</li> </ul>"},{"location":"blog/pydantic-v2/#strict-api-api-documentation","title":"Strict API &amp; API documentation","text":"<p>When preparing for pydantic V2, we'll make a strict distinction between the public API and private functions &amp; classes. Private objects will be clearly identified as private via a <code>_internal</code> sub package to discourage use.</p> <p>The public API will have API documentation. I've recently been working with the wonderful mkdocstrings package for both dirty-equals and watchfiles documentation. I intend to use <code>mkdocstrings</code> to generate complete API documentation for V2.</p> <p>This wouldn't replace the current example-based somewhat informal documentation style but instead will augment it.</p>"},{"location":"blog/pydantic-v2/#error-descriptions","title":"Error descriptions","text":"<p>The way line errors (the individual errors within a <code>ValidationError</code>) are built has become much more sophisticated in pydantic-core.</p> <p>There's a well-defined set of error codes and messages.</p> <p>More will be added when other types are validated via pure python validators in pydantic.</p> <p>I would like to add a dedicated section to the documentation with extra information for each type of error.</p> <p>This would be another key in a line error: <code>documentation</code>, which would link to the appropriate section in the docs.</p> <p>Thus, errors might look like:</p> Line Errors Example<pre><code>[\n    {\n        'kind': 'greater_than_equal',\n        'loc': ['age'],\n        'message': 'Value must be greater than or equal to 18',\n        'input_value': 11,\n        'context': {'ge': 18},\n        'documentation': 'https://pydantic.dev/errors/#greater_than_equal',\n    },\n    {\n        'kind': 'bool_parsing',\n        'loc': ['is_developer'],\n        'message': 'Value must be a valid boolean, unable to interpret input',\n        'input_value': 'foobar',\n        'documentation': 'https://pydantic.dev/errors/#bool_parsing',\n    },\n]\n</code></pre> <p>I own the <code>pydantic.dev</code> domain and will use it for at least these errors so that even if the docs URL changes, the error will still link to the correct documentation. If developers don't want to show these errors to users, they can always process the errors list and filter out items from each error they don't need or want.</p>"},{"location":"blog/pydantic-v2/#no-pure-python-implementation","title":"No pure python implementation","text":"<p>Since pydantic-core is written in Rust, and I have absolutely no intention of rewriting it in python, pydantic V2 will only work where a binary package can be installed.</p> <p>pydantic-core will provide binaries in PyPI for (at least):</p> <ul> <li>Linux: <code>x86_64</code>, <code>aarch64</code>, <code>i686</code>, <code>armv7l</code>, <code>musl-x86_64</code> &amp; <code>musl-aarch64</code></li> <li>MacOS: <code>x86_64</code> &amp; <code>arm64</code> (except python 3.7)</li> <li>Windows: <code>amd64</code> &amp; <code>win32</code></li> <li>Web Assembly: <code>wasm32</code>   (pydantic-core is already   compiled for wasm32 using emscripten and unit tests pass, except where cpython itself has   problems)</li> </ul> <p>Binaries for pypy are a work in progress and will be added if possible, see pydantic-core#154.</p> <p>Other binaries can be added provided they can be (cross-)compiled on github actions. If no binary is available from PyPI, pydantic-core can be compiled from source if Rust stable is available.</p> <p>The only place where I know this will cause problems is Raspberry Pi, which is a mess when it comes to packages written in Rust for Python. Effectively, until that's fixed you'll likely have to install pydantic with <code>pip install -i https://pypi.org/simple/ pydantic</code>.</p>"},{"location":"blog/pydantic-v2/#pydantic-becomes-a-pure-python-package","title":"Pydantic becomes a pure python package","text":"<p>Pydantic V1.X is a pure python code base but is compiled with cython to provide some performance improvements. Since the \"hot\" code is moved to pydantic-core, pydantic itself can go back to being a pure python package.</p> <p>This should significantly reduce the size of the pydantic package and make unit tests of pydantic much faster. In addition:</p> <ul> <li>some constraints on pydantic code can be removed once it no-longer has to be compilable with cython</li> <li>debugging will be easier as you'll be able to drop straight into the pydantic codebase as you can with other,   pure python packages</li> </ul> <p>Some pieces of edge logic could get a little slower as they're no longer compiled.</p>"},{"location":"blog/pydantic-v2/#is_instance-like-checks","title":"<code>is_instance</code> like checks","text":"<p>Strict mode also means it makes sense to provide an <code>is_instance</code> method on models which effectively run validation then throws away the result while avoiding the (admittedly small) overhead of creating and raising an error or returning the validation result.</p> <p>To be clear, this isn't a real <code>isinstance</code> call, rather it is equivalent to</p> is_instance<pre><code>class BaseModel:\n    ...\n    @classmethod\n    def model_is_instance(cls, data: Any) -&gt; bool:\n        try:\n            cls(**data)\n        except ValidationError:\n            return False\n        else:\n            return True\n</code></pre>"},{"location":"blog/pydantic-v2/#im-dropping-the-word-parse-and-just-using-validate","title":"I'm dropping the word \"parse\" and just using \"validate\"","text":"<p>Partly due to the issues with the lack of strict mode, I've gone back and forth between using the terms \"parse\" and \"validate\" for what pydantic does.</p> <p>While pydantic is not simply a validation library (and I'm sure some would argue validation is not strictly what it does), most people use the word \"validation\".</p> <p>It's time to stop fighting that, and use consistent names.</p> <p>The word \"parse\" will no longer be used except when talking about JSON parsing, see model methods above.</p>"},{"location":"blog/pydantic-v2/#changes-to-custom-field-types","title":"Changes to custom field types","text":"<p>Since the core structure of validators has changed from \"a list of validators to call one after another\" to \"a tree of validators which call each other\", the <code>__get_validators__</code> way of defining custom field types no longer makes sense.</p> <p>Instead, we'll look for the attribute <code>__pydantic_validation_schema__</code> which must be a pydantic-core compliant schema for validating data to this field type (the <code>function</code> item can be a string, if so a function of that name will be taken from the class, see <code>'validate'</code> below).</p> <p>Here's an example of how a custom field type could be defined:</p> New custom field types<pre><code>from pydantic import ValidationSchema\n\nclass Foobar:\n    def __init__(self, value: str):\n        self.value = value\n\n    __pydantic_validation_schema__: ValidationSchema = {\n        'type': 'function',\n        'mode': 'after',\n        'function': 'validate',\n        'schema': {'type': 'str'}\n    }\n\n    @classmethod\n    def validate(cls, value):\n        if 'foobar' in value:\n            return Foobar(value)\n        else:\n            raise ValueError('expected foobar')\n</code></pre> <p>What's going on here: <code>__pydantic_validation_schema__</code> defines a schema which effectively says:</p> <p>Validate input data as a string, then call the <code>validate</code> function with that string, use the returned value as the final result of validation.</p> <p><code>ValidationSchema</code> is just an alias to <code>pydantic_core.Schema</code> which is a type defining the schema for validation schemas.</p> <p>Note</p> <p>pydantic-core schema has full type definitions although since the type is recursive, mypy can't provide static type analysis, pyright however can.</p> <p>We can probably provide one or more helper functions to make <code>__pydantic_validation_schema__</code> easier to generate.</p>"},{"location":"blog/pydantic-v2/#other-improvements","title":"Other Improvements","text":"<p>Some other things which will also change, IMHO for the better:</p> <ol> <li>Recursive models with cyclic references - although recursive models were supported by pydantic V1,    data with cyclic references caused recursion errors, in pydantic-core cyclic references are correctly detected    and a validation error is raised</li> <li>The reason I've been so keen to get pydantic-core to compile and run with wasm is that I want all examples    in the docs of pydantic V2 to be editable and runnable in the browser</li> <li>Full support for <code>TypedDict</code>, including <code>total=False</code> - e.g. omitted keys,    providing validation schema to a <code>TypedDict</code> field/item will use <code>Annotated</code>, e.g. <code>Annotated[str, Field(strict=True)]</code></li> <li><code>from_orm</code> has become <code>from_attributes</code> and is now defined at schema generation time    (either via model config or field config)</li> <li><code>input_value</code> has been added to each line error in a <code>ValidationError</code>, making errors easier to understand,    and more comprehensive details of errors to be provided to end users,    pydantic#784</li> <li><code>on_error</code> logic in a schema which allows either a default value to be used in the event of an error,    or that value to be omitted (in the case of a <code>total=False</code> <code>TypedDict</code>),    pydantic-core#151</li> <li><code>datetime</code>, <code>date</code>, <code>time</code> &amp; <code>timedelta</code> validation is improved, see the    speedate Rust library I built specifically for this purpose for more details</li> <li>Powerful \"priority\" system for optionally merging or overriding config in sub-models for nested schemas</li> <li>Pydantic will support annotated-types,    so you can do stuff like <code>Annotated[set[int], Len(0, 10)]</code> or <code>Name = Annotated[str, Len(1, 1024)]</code></li> <li>A single decorator for general usage - we should add a <code>validate</code> decorator which can be used:<ul> <li>on functions (replacing <code>validate_arguments</code>)</li> <li>on dataclasses, <code>pydantic.dataclasses.dataclass</code> will become an alias of this</li> <li>on <code>TypedDict</code>s</li> <li>On any supported type, e.g. <code>Union[...]</code>, <code>Dict[str, Thing]</code></li> <li>On Custom field types - e.g. anything with a <code>__pydantic_schema__</code> attribute</li> </ul> </li> <li>Easier validation error creation, I've often found myself wanting to raise <code>ValidationError</code>s outside     models, particularly in FastAPI     (here     is one method I've used), we should provide utilities to generate these errors</li> <li>Improve the performance of <code>__eq__</code> on models</li> <li>Computed fields, these having been an idea for a long time in pydantic - we should get them right</li> <li>Model validation that avoids instances of subclasses leaking data (particularly important for FastAPI),     see pydantic-core#155</li> <li>We'll now follow semvar properly and avoid breaking changes between minor versions,     as a result, major versions will become more common</li> <li>Improve generics to use <code>M(Basemodel, Generic[T])</code> instead of <code>M(GenericModel, Generic[T])</code> - e.g. <code>GenericModel</code>     can be removed; this results from no-longer needing to compile pydantic code with cython</li> </ol>"},{"location":"blog/pydantic-v2/#removed-features-limitations","title":"Removed Features &amp; Limitations","text":"<p>The emoji here is just for variation, I'm not frowning about any of this, these changes are either good IMHO (will make pydantic cleaner, easier to learn and easier to maintain) or irrelevant to 99.9+% of users.</p> <ol> <li><code>__root__</code> custom root models are no longer necessary since validation on any supported data type is allowed    without a model</li> <li><code>.parse_file()</code> and <code>.parse_raw()</code>, partially replaced with <code>.model_validate_json()</code>,     see model methods</li> <li><code>.schema_json()</code> &amp; <code>.copy()</code>, see model methods</li> <li><code>TypeError</code> are no longer considered as validation errors, but rather as internal errors, this is to better    catch errors in argument names in function validators.</li> <li>Subclasses of builtin types like <code>str</code>, <code>bytes</code> and <code>int</code> are coerced to their parent builtin type,    this is a limitation of how pydantic-core converts these types to Rust types during validation, if you have a    specific need to keep the type, you can use wrap validators or custom type validation as described above</li> <li>integers are represented in rust code as <code>i64</code>, meaning if you want to use ints where <code>abs(v) &gt; 2^63 \u2212 1</code>    (9,223,372,036,854,775,807), you'll need to use a wrap validator and your own logic</li> <li>Settings Management ??? - I definitely don't want to    remove the functionality, but it's something of a historical curiosity that it lives within pydantic,    perhaps it should move to a separate package, perhaps installable alongside pydantic with    <code>pip install pydantic[settings]</code>?</li> <li>The following <code>Config</code> properties will be removed:<ul> <li><code>fields</code> - it's very old (it pre-dates <code>Field</code>), can be removed</li> <li><code>allow_mutation</code> will be removed, instead <code>frozen</code> will be used</li> <li><code>error_msg_templates</code>, it's not properly documented anyway, error messages can be customized with external logic if required</li> <li><code>getter_dict</code> - pydantic-core has hardcoded <code>from_attributes</code> logic</li> <li><code>json_loads</code> - again this is hard coded in pydantic-core</li> <li><code>json_dumps</code> - possibly</li> <li><code>json_encoders</code> - see the export \"mode\" discussion above</li> <li><code>underscore_attrs_are_private</code> we should just choose a sensible default</li> <li><code>smart_union</code> - all unions are now \"smart\"</li> </ul> </li> <li><code>dict(model)</code> functionality should be removed, there's a much clearer distinction now that in 2017 when I     implemented this between a model and a dict</li> </ol>"},{"location":"blog/pydantic-v2/#features-remaining","title":"Features Remaining","text":"<p>The following features will remain (mostly) unchanged:</p> <ul> <li>JSONSchema, internally this will need to change a lot, but hopefully the external interface will remain unchanged</li> <li><code>dataclass</code> support, again internals might change, but not the external interface</li> <li><code>validate_arguments</code>, might be renamed, but otherwise remain</li> <li>hypothesis plugin, might be able to improve this as part of the general cleanup</li> </ul>"},{"location":"blog/pydantic-v2/#questions","title":"Questions","text":"<p>I hope the explanation above is useful. I'm sure people will have questions and feedback; I'm aware I've skipped over some features with limited detail (this post is already fairly long ).</p> <p>To allow feedback without being overwhelmed, I've created a \"Pydantic V2\" category for discussions on github - please feel free to create a discussion if you have any questions or suggestions. We will endeavour to read and respond to everyone.</p>"},{"location":"blog/pydantic-v2/#implementation-details","title":"Implementation Details","text":"<p>(This is yet to be built, so these are nascent ideas which might change)</p> <p>At the center of pydantic v2 will be a <code>PydanticValidator</code> class which looks roughly like this (note: this is just pseudo-code, it's not even valid python and is only supposed to be used to demonstrate the idea):</p> PydanticValidator<pre><code># type identifying data which has been validated,\n# as per pydantic-core, this can include \"fields_set\" data\nValidData = ...\n\n# any type we can perform validation for\nAnyOutputType = ...\n\nclass PydanticValidator:\n    def __init__(self, output_type: AnyOutputType, config: Config):\n        ...\n    def validate(self, input_data: Any) -&gt; ValidData:\n        ...\n    def validate_json(self, input_data: str | bytes | bytearray) -&gt; ValidData:\n        ...\n    def is_instance(self, input_data: Any) -&gt; bool:\n        ...\n    def is_instance_json(self, input_data: str | bytes | bytearray) -&gt; bool:\n        ...\n    def json_schema(self) -&gt; dict:\n        ...\n    def dump(\n        self,\n        data: ValidData,\n        include: ... = None,\n        exclude: ... = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        mode: Literal['unchanged', 'dicts', 'json-compliant'] = 'unchanged',\n        converter: Callable[[Any], Any] | None = None\n    ) -&gt; Any:\n        ...\n    def dump_json(self, ...) -&gt; str:\n        ...\n</code></pre> <p>This could be used directly, but more commonly will be used by the following:</p> <ul> <li><code>BaseModel</code></li> <li>the <code>validate</code> decorator described above</li> <li><code>pydantic.dataclasses.dataclass</code> (which might be an alias of <code>validate</code>)</li> <li>generics</li> </ul> <p>The aim will be to get pydantic V2 to a place were the vast majority of tests continue to pass unchanged.</p> <p>Thereby guaranteeing (as much as possible) that the external interface to pydantic and its behaviour are unchanged.</p>"},{"location":"blog/pydantic-v2/#conversion-table","title":"Conversion Table","text":"<p>The table below provisionally defines what input value types are allowed to which field types.</p> <p>An updated and complete version of this table will be included in the docs for V2.</p> <p>Note</p> <p>Some type conversion shown here is a significant departure from existing behavior, we may have to provide a config flag for backwards compatibility for a few of them, however pydantic V2 cannot be entirely backward compatible, see pydantic-core#152.</p> Field Type Input Mode Input Source Conditions <code>str</code> <code>str</code> both python, JSON - <code>str</code> <code>bytes</code> lax python assumes UTF-8, error on unicode decoding error <code>str</code> <code>bytearray</code> lax python assumes UTF-8, error on unicode decoding error <code>bytes</code> <code>bytes</code> both python - <code>bytes</code> <code>str</code> both JSON - <code>bytes</code> <code>str</code> lax python - <code>bytes</code> <code>bytearray</code> lax python - <code>int</code> <code>int</code> strict python, JSON max abs value 2^64 - <code>i64</code> is used internally, <code>bool</code> explicitly forbidden <code>int</code> <code>int</code> lax python, JSON <code>i64</code> <code>int</code> <code>float</code> lax python, JSON <code>i64</code>, must be exact int, e.g. <code>f % 1 == 0</code>, <code>nan</code>, <code>inf</code> raise errors <code>int</code> <code>Decimal</code> lax python, JSON <code>i64</code>, must be exact int, e.g. <code>f % 1 == 0</code> <code>int</code> <code>bool</code> lax python, JSON - <code>int</code> <code>str</code> lax python, JSON <code>i64</code>, must be numeric only, e.g. <code>[0-9]+</code> <code>float</code> <code>float</code> strict python, JSON <code>bool</code> explicitly forbidden <code>float</code> <code>float</code> lax python, JSON - <code>float</code> <code>int</code> lax python, JSON - <code>float</code> <code>str</code> lax python, JSON must match <code>[0-9]+(\\.[0-9]+)?</code> <code>float</code> <code>Decimal</code> lax python - <code>float</code> <code>bool</code> lax python, JSON - <code>bool</code> <code>bool</code> both python, JSON - <code>bool</code> <code>int</code> lax python, JSON allowed: <code>0, 1</code> <code>bool</code> <code>float</code> lax python, JSON allowed: <code>0, 1</code> <code>bool</code> <code>Decimal</code> lax python, JSON allowed: <code>0, 1</code> <code>bool</code> <code>str</code> lax python, JSON allowed: <code>'f', 'n', 'no', 'off', 'false', 't', 'y', 'on', 'yes', 'true'</code> <code>None</code> <code>None</code> both python, JSON - <code>date</code> <code>date</code> both python - <code>date</code> <code>datetime</code> lax python must be exact date, eg. no H, M, S, f <code>date</code> <code>str</code> both JSON format <code>YYYY-MM-DD</code> <code>date</code> <code>str</code> lax python format <code>YYYY-MM-DD</code> <code>date</code> <code>bytes</code> lax python format <code>YYYY-MM-DD</code> (UTF-8) <code>date</code> <code>int</code> lax python, JSON interpreted as seconds or ms from epoch, see speedate, must be exact date <code>date</code> <code>float</code> lax python, JSON interpreted as seconds or ms from epoch, see speedate, must be exact date <code>datetime</code> <code>datetime</code> both python - <code>datetime</code> <code>date</code> lax python - <code>datetime</code> <code>str</code> both JSON format <code>YYYY-MM-DDTHH:MM:SS.f</code> etc. see speedate <code>datetime</code> <code>str</code> lax python format <code>YYYY-MM-DDTHH:MM:SS.f</code> etc. see speedate <code>datetime</code> <code>bytes</code> lax python format <code>YYYY-MM-DDTHH:MM:SS.f</code> etc. see speedate, (UTF-8) <code>datetime</code> <code>int</code> lax python, JSON interpreted as seconds or ms from epoch, see speedate <code>datetime</code> <code>float</code> lax python, JSON interpreted as seconds or ms from epoch, see speedate <code>time</code> <code>time</code> both python - <code>time</code> <code>str</code> both JSON format <code>HH:MM:SS.FFFFFF</code> etc. see speedate <code>time</code> <code>str</code> lax python format <code>HH:MM:SS.FFFFFF</code> etc. see speedate <code>time</code> <code>bytes</code> lax python format <code>HH:MM:SS.FFFFFF</code> etc. see speedate, (UTF-8) <code>time</code> <code>int</code> lax python, JSON interpreted as seconds, range 0 - 86399 <code>time</code> <code>float</code> lax python, JSON interpreted as seconds, range 0 - 86399.9* <code>time</code> <code>Decimal</code> lax python, JSON interpreted as seconds, range 0 - 86399.9* <code>timedelta</code> <code>timedelta</code> both python - <code>timedelta</code> <code>str</code> both JSON format ISO8601 etc. see speedate <code>timedelta</code> <code>str</code> lax python format ISO8601 etc. see speedate <code>timedelta</code> <code>bytes</code> lax python format ISO8601 etc. see speedate, (UTF-8) <code>timedelta</code> <code>int</code> lax python, JSON interpreted as seconds <code>timedelta</code> <code>float</code> lax python, JSON interpreted as seconds <code>timedelta</code> <code>Decimal</code> lax python, JSON interpreted as seconds <code>dict</code> <code>dict</code> both python - <code>dict</code> <code>Object</code> both JSON - <code>dict</code> <code>mapping</code> lax python must implement the mapping interface and have an <code>items()</code> method <code>TypedDict</code> <code>dict</code> both python - <code>TypedDict</code> <code>Object</code> both JSON - <code>TypedDict</code> <code>Any</code> both python builtins not allowed, uses <code>getattr</code>, requires <code>from_attributes=True</code> <code>TypedDict</code> <code>mapping</code> lax python must implement the mapping interface and have an <code>items()</code> method <code>list</code> <code>list</code> both python - <code>list</code> <code>Array</code> both JSON - <code>list</code> <code>tuple</code> lax python - <code>list</code> <code>set</code> lax python - <code>list</code> <code>frozenset</code> lax python - <code>list</code> <code>dict_keys</code> lax python - <code>tuple</code> <code>tuple</code> both python - <code>tuple</code> <code>Array</code> both JSON - <code>tuple</code> <code>list</code> lax python - <code>tuple</code> <code>set</code> lax python - <code>tuple</code> <code>frozenset</code> lax python - <code>tuple</code> <code>dict_keys</code> lax python - <code>set</code> <code>set</code> both python - <code>set</code> <code>Array</code> both JSON - <code>set</code> <code>list</code> lax python - <code>set</code> <code>tuple</code> lax python - <code>set</code> <code>frozenset</code> lax python - <code>set</code> <code>dict_keys</code> lax python - <code>frozenset</code> <code>frozenset</code> both python - <code>frozenset</code> <code>Array</code> both JSON - <code>frozenset</code> <code>list</code> lax python - <code>frozenset</code> <code>tuple</code> lax python - <code>frozenset</code> <code>set</code> lax python - <code>frozenset</code> <code>dict_keys</code> lax python - <code>is_instance</code> <code>Any</code> both python <code>isinstance()</code> check returns <code>True</code> <code>is_instance</code> - both JSON never valid <code>callable</code> <code>Any</code> both python <code>callable()</code> check returns <code>True</code> <code>callable</code> - both JSON never valid <p>The <code>ModelClass</code> validator (use to create instances of a class) uses the <code>TypedDict</code> validator, then creates an instance with <code>__dict__</code> and <code>__fields_set__</code> set, so same rules apply as <code>TypedDict</code>.</p>"},{"location":"usage/dataclasses/","title":"Dataclasses","text":"<p>If you don't want to use pydantic's <code>BaseModel</code> you can instead get the same data validation on standard dataclasses (introduced in Python 3.7).</p> Python 3.7 and above <pre><code>from datetime import datetime\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime = None\n\n\nuser = User(id='42', signup_ts='2032-06-21T12:00')\nprint(user)\n#&gt; User(id=42, name='John Doe', signup_ts=datetime.datetime(2032, 6, 21, 12, 0))\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>Keep in mind that <code>pydantic.dataclasses.dataclass</code> is a drop-in replacement for <code>dataclasses.dataclass</code> with validation, not a replacement for <code>pydantic.BaseModel</code> (with a small difference in how initialization hooks work). There are cases where subclassing <code>pydantic.BaseModel</code> is the better choice.</p> <p>For more information and discussion see pydantic/pydantic#710.</p> <p>You can use all the standard pydantic field types, and the resulting dataclass will be identical to the one created by the standard library <code>dataclass</code> decorator.</p> <p>The underlying model and its schema can be accessed through <code>__pydantic_model__</code>. Also, fields that require a <code>default_factory</code> can be specified by either a <code>pydantic.Field</code> or a <code>dataclasses.field</code>.</p> Python 3.7 and abovePython 3.9 and abovePython 3.10 and above <pre><code>import dataclasses\nfrom typing import List, Optional\n\nfrom pydantic import Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    friends: List[int] = dataclasses.field(default_factory=lambda: [0])\n    age: Optional[int] = dataclasses.field(\n        default=None,\n        metadata=dict(title='The age of the user', description='do not lie!')\n    )\n    height: Optional[int] = Field(None, title='The height in cm', ge=50, le=300)\n\n\nuser = User(id='42')\nprint(user.__pydantic_model__.schema())\n\"\"\"\n{\n    'title': 'User',\n    'type': 'object',\n    'properties': {\n        'id': {'title': 'Id', 'type': 'integer'},\n        'name': {\n            'title': 'Name',\n            'default': 'John Doe',\n            'type': 'string',\n        },\n        'friends': {\n            'title': 'Friends',\n            'type': 'array',\n            'items': {'type': 'integer'},\n        },\n        'age': {\n            'title': 'The age of the user',\n            'description': 'do not lie!',\n            'type': 'integer',\n        },\n        'height': {\n            'title': 'The height in cm',\n            'minimum': 50,\n            'maximum': 300,\n            'type': 'integer',\n        },\n    },\n    'required': ['id'],\n}\n\"\"\"\n</code></pre> <pre><code>import dataclasses\nfrom typing import Optional\n\nfrom pydantic import Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    friends: list[int] = dataclasses.field(default_factory=lambda: [0])\n    age: Optional[int] = dataclasses.field(\n        default=None,\n        metadata=dict(title='The age of the user', description='do not lie!')\n    )\n    height: Optional[int] = Field(None, title='The height in cm', ge=50, le=300)\n\n\nuser = User(id='42')\nprint(user.__pydantic_model__.schema())\n\"\"\"\n{\n    'title': 'User',\n    'type': 'object',\n    'properties': {\n        'id': {'title': 'Id', 'type': 'integer'},\n        'name': {\n            'title': 'Name',\n            'default': 'John Doe',\n            'type': 'string',\n        },\n        'friends': {\n            'title': 'Friends',\n            'type': 'array',\n            'items': {'type': 'integer'},\n        },\n        'age': {\n            'title': 'The age of the user',\n            'description': 'do not lie!',\n            'type': 'integer',\n        },\n        'height': {\n            'title': 'The height in cm',\n            'minimum': 50,\n            'maximum': 300,\n            'type': 'integer',\n        },\n    },\n    'required': ['id'],\n}\n\"\"\"\n</code></pre> <pre><code>import dataclasses\n\nfrom pydantic import Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    friends: list[int] = dataclasses.field(default_factory=lambda: [0])\n    age: int | None = dataclasses.field(\n        default=None,\n        metadata=dict(title='The age of the user', description='do not lie!')\n    )\n    height: int | None = Field(None, title='The height in cm', ge=50, le=300)\n\n\nuser = User(id='42')\nprint(user.__pydantic_model__.schema())\n\"\"\"\n{\n    'title': 'User',\n    'type': 'object',\n    'properties': {\n        'id': {'title': 'Id', 'type': 'integer'},\n        'name': {\n            'title': 'Name',\n            'default': 'John Doe',\n            'type': 'string',\n        },\n        'friends': {\n            'title': 'Friends',\n            'type': 'array',\n            'items': {'type': 'integer'},\n        },\n        'age': {\n            'title': 'The age of the user',\n            'description': 'do not lie!',\n            'type': 'integer',\n        },\n        'height': {\n            'title': 'The height in cm',\n            'minimum': 50,\n            'maximum': 300,\n            'type': 'integer',\n        },\n    },\n    'required': ['id'],\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p><code>pydantic.dataclasses.dataclass</code>'s arguments are the same as the standard decorator, except one extra keyword argument <code>config</code> which has the same meaning as Config.</p> <p>Warning</p> <p>After v1.2, The Mypy plugin must be installed to type check pydantic dataclasses.</p> <p>For more information about combining validators with dataclasses, see dataclass validators.</p>"},{"location":"usage/dataclasses/#dataclass-config","title":"Dataclass Config","text":"<p>If you want to modify the <code>Config</code> like you would with a <code>BaseModel</code>, you have three options:</p> Python 3.7 and above <pre><code>from pydantic import ConfigDict\nfrom pydantic.dataclasses import dataclass\n\n\n# Option 1 - use directly a dict\n# Note: `mypy` will still raise typo error\n@dataclass(config=dict(validate_assignment=True))\nclass MyDataclass1:\n    a: int\n\n\n# Option 2 - use `ConfigDict`\n# (same as before at runtime since it's a `TypedDict` but with intellisense)\n@dataclass(config=ConfigDict(validate_assignment=True))\nclass MyDataclass2:\n    a: int\n\n\n# Option 3 - use a `Config` class like for a `BaseModel`\nclass Config:\n    validate_assignment = True\n\n\n@dataclass(config=Config)\nclass MyDataclass3:\n    a: int\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Warning</p> <p>After v1.10, pydantic dataclasses support <code>Config.extra</code> but some default behaviour of stdlib dataclasses may prevail. For example, when <code>print</code>ing a pydantic dataclass with allowed extra fields, it will still use the <code>__str__</code> method of stdlib dataclass and show only the required fields. This may be improved further in the future.</p>"},{"location":"usage/dataclasses/#nested-dataclasses","title":"Nested dataclasses","text":"<p>Nested dataclasses are supported both in dataclasses and normal models.</p> Python 3.7 and above <pre><code>from pydantic import AnyUrl\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass NavbarButton:\n    href: AnyUrl\n\n\n@dataclass\nclass Navbar:\n    button: NavbarButton\n\n\nnavbar = Navbar(button=('https://example.com',))\nprint(navbar)\n#&gt; Navbar(button=NavbarButton(href=AnyUrl('https://example.com', scheme='https',\n#&gt; host='example.com', tld='com', host_type='domain')))\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Dataclasses attributes can be populated by tuples, dictionaries or instances of the dataclass itself.</p>"},{"location":"usage/dataclasses/#stdlib-dataclasses-and-pydantic-dataclasses","title":"Stdlib dataclasses and pydantic dataclasses","text":""},{"location":"usage/dataclasses/#convert-stdlib-dataclasses-into-pydantic-dataclasses","title":"Convert stdlib dataclasses into pydantic dataclasses","text":"<p>Stdlib dataclasses (nested or not) can be easily converted into pydantic dataclasses by just decorating them with <code>pydantic.dataclasses.dataclass</code>. Pydantic will enhance the given stdlib dataclass but won't alter the default behaviour (i.e. without validation). It will instead create a wrapper around it to trigger validation that will act like a plain proxy. The stdlib dataclass can still be accessed via the <code>__dataclass__</code> attribute (see example below).</p> Python 3.7 and abovePython 3.10 and above <pre><code>import dataclasses\nfrom datetime import datetime\nfrom typing import Optional\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass Meta:\n    modified_date: Optional[datetime]\n    seen_count: int\n\n\n@dataclasses.dataclass\nclass File(Meta):\n    filename: str\n\n\n# `ValidatedFile` will be a proxy around `File`\nValidatedFile = pydantic.dataclasses.dataclass(File)\n\n# the original dataclass is the `__dataclass__` attribute\nassert ValidatedFile.__dataclass__ is File\n\n\nvalidated_file = ValidatedFile(\n    filename=b'thefilename',\n    modified_date='2020-01-01T00:00',\n    seen_count='7',\n)\nprint(validated_file)\n#&gt; File(modified_date=datetime.datetime(2020, 1, 1, 0, 0), seen_count=7,\n#&gt; filename='thefilename')\n\ntry:\n    ValidatedFile(\n        filename=['not', 'a', 'string'],\n        modified_date=None,\n        seen_count=3,\n    )\nexcept pydantic.ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for File\n    filename\n      str type expected (type=type_error.str)\n    \"\"\"\n\n# `File` is not altered and still does no validation by default\nprint(File(\n#&gt; File(modified_date=None, seen_count=3, filename=['not', 'a', 'string'])\n    filename=['not', 'a', 'string'],\n    modified_date=None,\n    seen_count=3,\n))\n</code></pre> <pre><code>import dataclasses\nfrom datetime import datetime\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass Meta:\n    modified_date: datetime | None\n    seen_count: int\n\n\n@dataclasses.dataclass\nclass File(Meta):\n    filename: str\n\n\n# `ValidatedFile` will be a proxy around `File`\nValidatedFile = pydantic.dataclasses.dataclass(File)\n\n# the original dataclass is the `__dataclass__` attribute\nassert ValidatedFile.__dataclass__ is File\n\n\nvalidated_file = ValidatedFile(\n    filename=b'thefilename',\n    modified_date='2020-01-01T00:00',\n    seen_count='7',\n)\nprint(validated_file)\n#&gt; File(modified_date=datetime.datetime(2020, 1, 1, 0, 0), seen_count=7,\n#&gt; filename='thefilename')\n\ntry:\n    ValidatedFile(\n        filename=['not', 'a', 'string'],\n        modified_date=None,\n        seen_count=3,\n    )\nexcept pydantic.ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for File\n    filename\n      str type expected (type=type_error.str)\n    \"\"\"\n\n# `File` is not altered and still does no validation by default\nprint(File(\n#&gt; File(modified_date=None, seen_count=3, filename=['not', 'a', 'string'])\n    filename=['not', 'a', 'string'],\n    modified_date=None,\n    seen_count=3,\n))\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/dataclasses/#choose-when-to-trigger-validation","title":"Choose when to trigger validation","text":"<p>As soon as your stdlib dataclass has been decorated with pydantic dataclass decorator, magic methods have been added to validate input data. If you want, you can still keep using your dataclass and choose when to trigger it.</p> Python 3.7 and above <pre><code>import dataclasses\n\nfrom pydantic import ValidationError\nfrom pydantic.dataclasses import dataclass as pydantic_dataclass, set_validation\n\n\n@dataclasses.dataclass\nclass User:\n    id: int\n    name: str\n\n\n# Enhance stdlib dataclass\npydantic_dataclass(User)\n\n\nuser1 = User(id='whatever', name='I want')\n\n# validate data of `user1`\ntry:\n    user1.__pydantic_validate_values__()\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    id\n      value is not a valid integer (type=type_error.integer)\n    \"\"\"\n\n# Enforce validation\ntry:\n    with set_validation(User, True):\n        User(id='whatever', name='I want')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    id\n      value is not a valid integer (type=type_error.integer)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/dataclasses/#inherit-from-stdlib-dataclasses","title":"Inherit from stdlib dataclasses","text":"<p>Stdlib dataclasses (nested or not) can also be inherited and pydantic will automatically validate all the inherited fields.</p> Python 3.7 and above <pre><code>import dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass Z:\n    z: int\n\n\n@dataclasses.dataclass\nclass Y(Z):\n    y: int = 0\n\n\n@pydantic.dataclasses.dataclass\nclass X(Y):\n    x: int = 0\n\n\nfoo = X(x=b'1', y='2', z='3')\nprint(foo)\n#&gt; X(z=3, y=2, x=1)\n\ntry:\n    X(z='pika')\nexcept pydantic.ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for X\n    z\n      value is not a valid integer (type=type_error.integer)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/dataclasses/#use-of-stdlib-dataclasses-with-basemodel","title":"Use of stdlib dataclasses with <code>BaseModel</code>","text":"<p>Bear in mind that stdlib dataclasses (nested or not) are automatically converted into pydantic dataclasses when mixed with <code>BaseModel</code>! Furthermore the generated pydantic dataclass will have the exact same configuration (<code>order</code>, <code>frozen</code>, ...) as the original one.</p> Python 3.7 and abovePython 3.10 and above <pre><code>import dataclasses\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\n@dataclasses.dataclass(frozen=True)\nclass User:\n    name: str\n\n\n@dataclasses.dataclass\nclass File:\n    filename: str\n    last_modification_time: Optional[datetime] = None\n\n\nclass Foo(BaseModel):\n    file: File\n    user: Optional[User] = None\n\n\nfile = File(\n    filename=['not', 'a', 'string'],\n    last_modification_time='2020-01-01T00:00',\n)  # nothing is validated as expected\nprint(file)\n#&gt; File(filename=['not', 'a', 'string'],\n#&gt; last_modification_time='2020-01-01T00:00')\n\ntry:\n    Foo(file=file)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    file -&gt; filename\n      str type expected (type=type_error.str)\n    \"\"\"\n\nfoo = Foo(file=File(filename='myfile'), user=User(name='pika'))\ntry:\n    foo.user.name = 'bulbi'\nexcept dataclasses.FrozenInstanceError as e:\n    print(e)\n    #&gt; cannot assign to field 'name'\n</code></pre> <pre><code>import dataclasses\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\n@dataclasses.dataclass(frozen=True)\nclass User:\n    name: str\n\n\n@dataclasses.dataclass\nclass File:\n    filename: str\n    last_modification_time: datetime | None = None\n\n\nclass Foo(BaseModel):\n    file: File\n    user: User | None = None\n\n\nfile = File(\n    filename=['not', 'a', 'string'],\n    last_modification_time='2020-01-01T00:00',\n)  # nothing is validated as expected\nprint(file)\n#&gt; File(filename=['not', 'a', 'string'],\n#&gt; last_modification_time='2020-01-01T00:00')\n\ntry:\n    Foo(file=file)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    file -&gt; filename\n      str type expected (type=type_error.str)\n    \"\"\"\n\nfoo = Foo(file=File(filename='myfile'), user=User(name='pika'))\ntry:\n    foo.user.name = 'bulbi'\nexcept dataclasses.FrozenInstanceError as e:\n    print(e)\n    #&gt; cannot assign to field 'name'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/dataclasses/#use-custom-types","title":"Use custom types","text":"<p>Since stdlib dataclasses are automatically converted to add validation using custom types may cause some unexpected behaviour. In this case you can simply add <code>arbitrary_types_allowed</code> in the config!</p> Python 3.7 and above <pre><code>import dataclasses\n\nimport pydantic\n\n\nclass ArbitraryType:\n    def __init__(self, value):\n        self.value = value\n\n    def __repr__(self):\n        return f'ArbitraryType(value={self.value!r})'\n\n\n@dataclasses.dataclass\nclass DC:\n    a: ArbitraryType\n    b: str\n\n\n# valid as it is a builtin dataclass without validation\nmy_dc = DC(a=ArbitraryType(value=3), b='qwe')\n\ntry:\n    class Model(pydantic.BaseModel):\n        dc: DC\n        other: str\n\n    Model(dc=my_dc, other='other')\nexcept RuntimeError as e:  # invalid as it is now a pydantic dataclass\n    print(e)\n    \"\"\"\n    no validator found for &lt;class\n    'dataclasses_arbitrary_types_allowed.ArbitraryType'&gt;, see\n    `arbitrary_types_allowed` in Config\n    \"\"\"\n\n\nclass Model(pydantic.BaseModel):\n    dc: DC\n    other: str\n\n    class Config:\n        arbitrary_types_allowed = True\n\n\nm = Model(dc=my_dc, other='other')\nprint(repr(m))\n#&gt; Model(dc=DC(a=ArbitraryType(value=3), b='qwe'), other='other')\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/dataclasses/#initialize-hooks","title":"Initialize hooks","text":"<p>When you initialize a dataclass, it is possible to execute code after validation with the help of <code>__post_init_post_parse__</code>. This is not the same as <code>__post_init__</code>, which executes code before validation.</p> <p>Tip</p> <p>If you use a stdlib <code>dataclass</code>, you may only have <code>__post_init__</code> available and wish the validation to be done before. In this case you can set <code>Config.post_init_call = 'after_validation'</code></p> Python 3.7 and above <pre><code>from pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Birth:\n    year: int\n    month: int\n    day: int\n\n\n@dataclass\nclass User:\n    birth: Birth\n\n    def __post_init__(self):\n        print(self.birth)\n        #&gt; {'year': 1995, 'month': 3, 'day': 2}\n\n    def __post_init_post_parse__(self):\n        print(self.birth)\n        #&gt; Birth(year=1995, month=3, day=2)\n\n\nuser = User(**{'birth': {'year': 1995, 'month': 3, 'day': 2}})\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Since version v1.0, any fields annotated with <code>dataclasses.InitVar</code> are passed to both <code>__post_init__</code> and <code>__post_init_post_parse__</code>.</p> Python 3.7 and abovePython 3.10 and above <pre><code>from dataclasses import InitVar\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass PathData:\n    path: Path\n    base_path: InitVar[Optional[Path]]\n\n    def __post_init__(self, base_path):\n        print(f'Received path={self.path!r}, base_path={base_path!r}')\n        #&gt; Received path='world', base_path='/hello'\n\n    def __post_init_post_parse__(self, base_path):\n        if base_path is not None:\n            self.path = base_path / self.path\n\n\npath_data = PathData('world', base_path='/hello')\n# Received path='world', base_path='/hello'\nassert path_data.path == Path('/hello/world')\n</code></pre> <pre><code>from dataclasses import InitVar\nfrom pathlib import Path\n\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass PathData:\n    path: Path\n    base_path: InitVar[Path | None]\n\n    def __post_init__(self, base_path):\n        print(f'Received path={self.path!r}, base_path={base_path!r}')\n        #&gt; Received path='world', base_path='/hello'\n\n    def __post_init_post_parse__(self, base_path):\n        if base_path is not None:\n            self.path = base_path / self.path\n\n\npath_data = PathData('world', base_path='/hello')\n# Received path='world', base_path='/hello'\nassert path_data.path == Path('/hello/world')\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/dataclasses/#difference-with-stdlib-dataclasses","title":"Difference with stdlib dataclasses","text":"<p>Note that the <code>dataclasses.dataclass</code> from Python stdlib implements only the <code>__post_init__</code> method since it doesn't run a validation step.</p> <p>When substituting usage of <code>dataclasses.dataclass</code> with <code>pydantic.dataclasses.dataclass</code>, it is recommended to move the code executed in the <code>__post_init__</code> method to the <code>__post_init_post_parse__</code> method, and only leave behind part of code which needs to be executed before validation.</p>"},{"location":"usage/dataclasses/#json-dumping","title":"JSON Dumping","text":"<p>Pydantic dataclasses do not feature a <code>.json()</code> function. To dump them as JSON, you will need to make use of the <code>pydantic_encoder</code> as follows:</p> Python 3.7 and abovePython 3.9 and above <pre><code>import dataclasses\nimport json\nfrom typing import List\n\nfrom pydantic.dataclasses import dataclass\nfrom pydantic.json import pydantic_encoder\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    friends: List[int] = dataclasses.field(default_factory=lambda: [0])\n\n\nuser = User(id='42')\nprint(json.dumps(user, indent=4, default=pydantic_encoder))\n\"\"\"\n{\n    \"id\": 42,\n    \"name\": \"John Doe\",\n    \"friends\": [\n        0\n    ]\n}\n\"\"\"\n</code></pre> <pre><code>import dataclasses\nimport json\n\nfrom pydantic.dataclasses import dataclass\nfrom pydantic.json import pydantic_encoder\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    friends: list[int] = dataclasses.field(default_factory=lambda: [0])\n\n\nuser = User(id='42')\nprint(json.dumps(user, indent=4, default=pydantic_encoder))\n\"\"\"\n{\n    \"id\": 42,\n    \"name\": \"John Doe\",\n    \"friends\": [\n        0\n    ]\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/devtools/","title":"Usage with devtools","text":"<p>Note</p> <p>Admission: I (the primary developer of pydantic) also develop python-devtools.</p> <p>python-devtools (<code>pip install devtools</code>) provides a number of tools which are useful during Python development, including <code>debug()</code> an alternative to <code>print()</code> which formats output in a way which should be easier to read than <code>print</code> as well as giving information about which file/line the print statement  is on and what value was printed.</p> <p>pydantic integrates with devtools by implementing the <code>__pretty__</code> method on most public classes.</p> <p>In particular <code>debug()</code> is useful when inspecting models:</p> Python 3.7 and abovePython 3.9 and above <pre><code>from datetime import datetime\nfrom typing import List\nfrom pydantic import BaseModel\n\nfrom devtools import debug\n\n\nclass Address(BaseModel):\n    street: str\n    country: str\n    lat: float\n    lng: float\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    signup_ts: datetime\n    friends: List[int]\n    address: Address\n\n\nuser = User(\n    id='123',\n    name='John Doe',\n    signup_ts='2019-06-01 12:22',\n    friends=[1234, 4567, 7890],\n    address=dict(street='Testing', country='uk', lat=51.5, lng=0),\n)\ndebug(user)\nprint('\\nshould be much easier read than:\\n')\nprint('user:', user)\n</code></pre> <pre><code>from datetime import datetime\nfrom pydantic import BaseModel\n\nfrom devtools import debug\n\n\nclass Address(BaseModel):\n    street: str\n    country: str\n    lat: float\n    lng: float\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    signup_ts: datetime\n    friends: list[int]\n    address: Address\n\n\nuser = User(\n    id='123',\n    name='John Doe',\n    signup_ts='2019-06-01 12:22',\n    friends=[1234, 4567, 7890],\n    address=dict(street='Testing', country='uk', lat=51.5, lng=0),\n)\ndebug(user)\nprint('\\nshould be much easier read than:\\n')\nprint('user:', user)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Will output in your terminal:</p> <pre>\ndocs/examples/devtools_main.py:31 &lt;module&gt;\n    user: User(\n        id=123,\n        name='John Doe',\n        signup_ts=datetime.datetime(2019, 6, 1, 12, 22),\n        friends=[\n            1234,\n            4567,\n            7890,\n        ],\n        address=Address(\n            street='Testing',\n            country='uk',\n            lat=51.5,\n            lng=0.0,\n        ),\n    ) (User)\n\nshould be much easier read than:\n\nuser: id=123 name='John Doe' signup_ts=datetime.datetime(2019, 6, 1, 12, 22) friends=[1234, 4567, 7890] address=Address(street='Testing', country='uk', lat=51.5, lng=0.0)\n</pre>"},{"location":"usage/exporting_models/","title":"Exporting models","text":"<p>As well as accessing model attributes directly via their names (e.g. <code>model.foobar</code>), models can be converted and exported in a number of ways:</p>"},{"location":"usage/exporting_models/#modeldict","title":"<code>model.dict(...)</code>","text":"<p>This is the primary way of converting a model to a dictionary. Sub-models will be recursively converted to dictionaries.</p> <p>Arguments:</p> <ul> <li><code>include</code>: fields to include in the returned dictionary; see below</li> <li><code>exclude</code>: fields to exclude from the returned dictionary; see below</li> <li><code>by_alias</code>: whether field aliases should be used as keys in the returned dictionary; default <code>False</code></li> <li><code>exclude_unset</code>: whether fields which were not explicitly set when creating the model should   be excluded from the returned dictionary; default <code>False</code>.   Prior to v1.0, <code>exclude_unset</code> was known as <code>skip_defaults</code>; use of <code>skip_defaults</code> is now deprecated</li> <li><code>exclude_defaults</code>: whether fields which are equal to their default values (whether set or otherwise) should   be excluded from the returned dictionary; default <code>False</code></li> <li><code>exclude_none</code>: whether fields which are equal to <code>None</code> should be excluded from the returned dictionary; default   <code>False</code></li> </ul> <p>Example:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\n# returns a dictionary:\nprint(m.dict())\n\"\"\"\n{\n    'banana': 3.14,\n    'foo': 'hello',\n    'bar': {'whatever': 123},\n}\n\"\"\"\nprint(m.dict(include={'foo', 'bar'}))\n#&gt; {'foo': 'hello', 'bar': {'whatever': 123}}\nprint(m.dict(exclude={'foo', 'bar'}))\n#&gt; {'banana': 3.14}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/exporting_models/#dictmodel-and-iteration","title":"<code>dict(model)</code> and iteration","text":"<p>pydantic models can also be converted to dictionaries using <code>dict(model)</code>, and you can also iterate over a model's field using <code>for field_name, value in model:</code>. With this approach the raw field values are returned, so sub-models will not be converted to dictionaries.</p> <p>Example:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nprint(dict(m))\n\"\"\"\n{\n    'banana': 3.14,\n    'foo': 'hello',\n    'bar': BarModel(\n        whatever=123,\n    ),\n}\n\"\"\"\nfor name, value in m:\n    print(f'{name}: {value}')\n    #&gt; banana: 3.14\n    #&gt; foo: hello\n    #&gt; bar: whatever=123\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/exporting_models/#modelcopy","title":"<code>model.copy(...)</code>","text":"<p><code>copy()</code> allows models to be duplicated, which is particularly useful for immutable models.</p> <p>Arguments:</p> <ul> <li><code>include</code>: fields to include in the returned dictionary; see below</li> <li><code>exclude</code>: fields to exclude from the returned dictionary; see below</li> <li><code>update</code>: a dictionary of values to change when creating the copied model</li> <li><code>deep</code>: whether to make a deep copy of the new model; default <code>False</code></li> </ul> <p>Example:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nprint(m.copy(include={'foo', 'bar'}))\n#&gt; foo='hello' bar=BarModel(whatever=123)\nprint(m.copy(exclude={'foo', 'bar'}))\n#&gt; banana=3.14\nprint(m.copy(update={'banana': 0}))\n#&gt; banana=0 foo='hello' bar=BarModel(whatever=123)\nprint(id(m.bar), id(m.copy().bar))\n#&gt; 140329777903408 140329777903408\n# normal copy gives the same object reference for `bar`\nprint(id(m.bar), id(m.copy(deep=True).bar))\n#&gt; 140329777903408 140329777894000\n# deep copy gives a new object reference for `bar`\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/exporting_models/#modeljson","title":"<code>model.json(...)</code>","text":"<p>The <code>.json()</code> method will serialise a model to JSON. (For models with a custom root type, only the value for the <code>__root__</code> key is serialised)</p> <p>Arguments:</p> <ul> <li><code>include</code>: fields to include in the returned dictionary; see below</li> <li><code>exclude</code>: fields to exclude from the returned dictionary; see below</li> <li><code>by_alias</code>: whether field aliases should be used as keys in the returned dictionary; default <code>False</code></li> <li><code>exclude_unset</code>: whether fields which were not set when creating the model and have their default values should   be excluded from the returned dictionary; default <code>False</code>.   Prior to v1.0, <code>exclude_unset</code> was known as <code>skip_defaults</code>; use of <code>skip_defaults</code> is now deprecated</li> <li><code>exclude_defaults</code>: whether fields which are equal to their default values (whether set or otherwise) should   be excluded from the returned dictionary; default <code>False</code></li> <li><code>exclude_none</code>: whether fields which are equal to <code>None</code> should be excluded from the returned dictionary; default   <code>False</code></li> <li><code>encoder</code>: a custom encoder function passed to the <code>default</code> argument of <code>json.dumps()</code>; defaults to a custom   encoder designed to take care of all common types</li> <li><code>**dumps_kwargs</code>: any other keyword arguments are passed to <code>json.dumps()</code>, e.g. <code>indent</code>.</li> </ul> <p>pydantic can serialise many commonly used types to JSON (e.g. <code>datetime</code>, <code>date</code> or <code>UUID</code>) which would normally fail with a simple <code>json.dumps(foobar)</code>.</p> Python 3.7 and above <pre><code>from datetime import datetime\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    foo: datetime\n    bar: BarModel\n\n\nm = FooBarModel(foo=datetime(2032, 6, 1, 12, 13, 14), bar={'whatever': 123})\nprint(m.json())\n#&gt; {\"foo\": \"2032-06-01T12:13:14\", \"bar\": {\"whatever\": 123}}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/exporting_models/#json_encoders","title":"<code>json_encoders</code>","text":"<p>Serialisation can be customised on a model using the <code>json_encoders</code> config property; the keys should be types (or names of types for forward references), and the values should be functions which serialise that type (see the example below):</p> Python 3.7 and above <pre><code>from datetime import datetime, timedelta\nfrom pydantic import BaseModel\nfrom pydantic.json import timedelta_isoformat\n\n\nclass WithCustomEncoders(BaseModel):\n    dt: datetime\n    diff: timedelta\n\n    class Config:\n        json_encoders = {\n            datetime: lambda v: v.timestamp(),\n            timedelta: timedelta_isoformat,\n        }\n\n\nm = WithCustomEncoders(dt=datetime(2032, 6, 1), diff=timedelta(hours=100))\nprint(m.json())\n#&gt; {\"dt\": 1969660800.0, \"diff\": \"P4DT4H0M0.000000S\"}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>By default, <code>timedelta</code> is encoded as a simple float of total seconds. The <code>timedelta_isoformat</code> is provided as an optional alternative which implements ISO 8601 time diff encoding.</p> <p>The <code>json_encoders</code> are also merged during the models inheritance with the child encoders taking precedence over the parent one.</p> Python 3.7 and above <pre><code>from datetime import datetime, timedelta\nfrom pydantic import BaseModel\nfrom pydantic.json import timedelta_isoformat\n\n\nclass BaseClassWithEncoders(BaseModel):\n    dt: datetime\n    diff: timedelta\n\n    class Config:\n        json_encoders = {\n            datetime: lambda v: v.timestamp()\n        }\n\n\nclass ChildClassWithEncoders(BaseClassWithEncoders):\n    class Config:\n        json_encoders = {\n            timedelta: timedelta_isoformat\n        }\n\n\nm = ChildClassWithEncoders(dt=datetime(2032, 6, 1), diff=timedelta(hours=100))\nprint(m.json())\n#&gt; {\"dt\": 1969660800.0, \"diff\": \"P4DT4H0M0.000000S\"}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/exporting_models/#serialising-self-reference-or-other-models","title":"Serialising self-reference or other models","text":"<p>By default, models are serialised as dictionaries. If you want to serialise them differently, you can add <code>models_as_dict=False</code> when calling <code>json()</code> method and add the classes of the model in <code>json_encoders</code>. In case of forward references, you can use a string with the class name instead of the class itself</p> Python 3.7 and abovePython 3.9 and abovePython 3.10 and above <pre><code>from typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Address(BaseModel):\n    city: str\n    country: str\n\n\nclass User(BaseModel):\n    name: str\n    address: Address\n    friends: Optional[List['User']] = None\n\n    class Config:\n        json_encoders = {\n            Address: lambda a: f'{a.city} ({a.country})',\n            'User': lambda u: f'{u.name} in {u.address.city} '\n                              f'({u.address.country[:2].upper()})',\n        }\n\n\nUser.update_forward_refs()\n\nwolfgang = User(\n    name='Wolfgang',\n    address=Address(city='Berlin', country='Deutschland'),\n    friends=[\n        User(name='Pierre', address=Address(city='Paris', country='France')),\n        User(name='John', address=Address(city='London', country='UK')),\n    ],\n)\nprint(wolfgang.json(models_as_dict=False))\n#&gt; {\"name\": \"Wolfgang\", \"address\": \"Berlin (Deutschland)\", \"friends\": [\"Pierre\n#&gt; in Paris (FR)\", \"John in London (UK)\"]}\n</code></pre> <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Address(BaseModel):\n    city: str\n    country: str\n\n\nclass User(BaseModel):\n    name: str\n    address: Address\n    friends: Optional[list['User']] = None\n\n    class Config:\n        json_encoders = {\n            Address: lambda a: f'{a.city} ({a.country})',\n            'User': lambda u: f'{u.name} in {u.address.city} '\n                              f'({u.address.country[:2].upper()})',\n        }\n\n\nUser.update_forward_refs()\n\nwolfgang = User(\n    name='Wolfgang',\n    address=Address(city='Berlin', country='Deutschland'),\n    friends=[\n        User(name='Pierre', address=Address(city='Paris', country='France')),\n        User(name='John', address=Address(city='London', country='UK')),\n    ],\n)\nprint(wolfgang.json(models_as_dict=False))\n#&gt; {\"name\": \"Wolfgang\", \"address\": \"Berlin (Deutschland)\", \"friends\": [\"Pierre\n#&gt; in Paris (FR)\", \"John in London (UK)\"]}\n</code></pre> <pre><code>from pydantic import BaseModel\n\n\nclass Address(BaseModel):\n    city: str\n    country: str\n\n\nclass User(BaseModel):\n    name: str\n    address: Address\n    friends: list['User'] | None = None\n\n    class Config:\n        json_encoders = {\n            Address: lambda a: f'{a.city} ({a.country})',\n            'User': lambda u: f'{u.name} in {u.address.city} '\n                              f'({u.address.country[:2].upper()})',\n        }\n\n\nUser.update_forward_refs()\n\nwolfgang = User(\n    name='Wolfgang',\n    address=Address(city='Berlin', country='Deutschland'),\n    friends=[\n        User(name='Pierre', address=Address(city='Paris', country='France')),\n        User(name='John', address=Address(city='London', country='UK')),\n    ],\n)\nprint(wolfgang.json(models_as_dict=False))\n#&gt; {\"name\": \"Wolfgang\", \"address\": \"Berlin (Deutschland)\", \"friends\": [\"Pierre\n#&gt; in Paris (FR)\", \"John in London (UK)\"]}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/exporting_models/#serialising-subclasses","title":"Serialising subclasses","text":"<p>Note</p> <p>New in version v1.5.</p> <p>Subclasses of common types were not automatically serialised to JSON before v1.5.</p> <p>Subclasses of common types are automatically encoded like their super-classes:</p> Python 3.7 and above <pre><code>from datetime import date, timedelta\nfrom pydantic import BaseModel\nfrom pydantic.validators import int_validator\n\n\nclass DayThisYear(date):\n    \"\"\"\n    Contrived example of a special type of date that\n    takes an int and interprets it as a day in the current year\n    \"\"\"\n\n    @classmethod\n    def __get_validators__(cls):\n        yield int_validator\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, v: int):\n        return date.today().replace(month=1, day=1) + timedelta(days=v)\n\n\nclass FooModel(BaseModel):\n    date: DayThisYear\n\n\nm = FooModel(date=300)\nprint(m.json())\n#&gt; {\"date\": \"2025-10-28\"}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/exporting_models/#custom-json-deserialisation","title":"Custom JSON (de)serialisation","text":"<p>To improve the performance of encoding and decoding JSON, alternative JSON implementations (e.g. ujson) can be used via the <code>json_loads</code> and <code>json_dumps</code> properties of <code>Config</code>.</p> Python 3.7 and above <pre><code>from datetime import datetime\nimport ujson\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: int\n    name = 'John Doe'\n    signup_ts: datetime = None\n\n    class Config:\n        json_loads = ujson.loads\n\n\nuser = User.parse_raw('{\"id\": 123,\"signup_ts\":1234567890,\"name\":\"John Doe\"}')\nprint(user)\n#&gt; id=123 signup_ts=datetime.datetime(2009, 2, 13, 23, 31, 30,\n#&gt; tzinfo=datetime.timezone.utc) name='John Doe'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p><code>ujson</code> generally cannot be used to dump JSON since it doesn't support encoding of objects like datetimes and does not accept a <code>default</code> fallback function argument. To do this, you may use another library like orjson.</p> Python 3.7 and above <pre><code>from datetime import datetime\nimport orjson\nfrom pydantic import BaseModel\n\n\ndef orjson_dumps(v, *, default):\n    # orjson.dumps returns bytes, to match standard json.dumps we need to decode\n    return orjson.dumps(v, default=default).decode()\n\n\nclass User(BaseModel):\n    id: int\n    name = 'John Doe'\n    signup_ts: datetime = None\n\n    class Config:\n        json_loads = orjson.loads\n        json_dumps = orjson_dumps\n\n\nuser = User.parse_raw('{\"id\":123,\"signup_ts\":1234567890,\"name\":\"John Doe\"}')\nprint(user.json())\n#&gt; {\"id\":123,\"signup_ts\":\"2009-02-13T23:31:30+00:00\",\"name\":\"John Doe\"}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note that <code>orjson</code> takes care of <code>datetime</code> encoding natively, making it faster than <code>json.dumps</code> but meaning you cannot always customise the encoding using <code>Config.json_encoders</code>.</p>"},{"location":"usage/exporting_models/#pickledumpsmodel","title":"<code>pickle.dumps(model)</code>","text":"<p>Using the same plumbing as <code>copy()</code>, pydantic models support efficient pickling and unpickling.</p> Python 3.7 and above <pre><code>import pickle\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel):\n    a: str\n    b: int\n\n\nm = FooBarModel(a='hello', b=123)\nprint(m)\n#&gt; a='hello' b=123\ndata = pickle.dumps(m)\nprint(data)\n\"\"\"\nb'\\x80\\x04\\x95\\x8e\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x17exporting_models_pickle\n\\x94\\x8c\\x0bFooBarModel\\x94\\x93\\x94)\\x81\\x94}\\x94(\\x8c\\x08__dict__\\x94}\\x94(\\\nx8c\\x01a\\x94\\x8c\\x05hello\\x94\\x8c\\x01b\\x94K{u\\x8c\\x0e__fields_set__\\x94\\x8f\\x\n94(h\\th\\x07\\x90\\x8c\\x1c__private_attribute_values__\\x94}\\x94ub.'\n\"\"\"\nm2 = pickle.loads(data)\nprint(m2)\n#&gt; a='hello' b=123\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/exporting_models/#advanced-include-and-exclude","title":"Advanced include and exclude","text":"<p>The <code>dict</code>, <code>json</code>, and <code>copy</code> methods support <code>include</code> and <code>exclude</code> arguments which can either be sets or dictionaries. This allows nested selection of which fields to export:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, SecretStr\n\n\nclass User(BaseModel):\n    id: int\n    username: str\n    password: SecretStr\n\n\nclass Transaction(BaseModel):\n    id: str\n    user: User\n    value: int\n\n\nt = Transaction(\n    id='1234567890',\n    user=User(\n        id=42,\n        username='JohnDoe',\n        password='hashedpassword'\n    ),\n    value=9876543210,\n)\n\n# using a set:\nprint(t.dict(exclude={'user', 'value'}))\n#&gt; {'id': '1234567890'}\n\n# using a dict:\nprint(t.dict(exclude={'user': {'username', 'password'}, 'value': True}))\n#&gt; {'id': '1234567890', 'user': {'id': 42}}\n\nprint(t.dict(include={'id': True, 'user': {'id'}}))\n#&gt; {'id': '1234567890', 'user': {'id': 42}}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>The <code>True</code> indicates that we want to exclude or include an entire key, just as if we included it in a set. Of course, the same can be done at any depth level.</p> <p>Special care must be taken when including or excluding fields from a list or tuple of submodels or dictionaries.  In this scenario, <code>dict</code> and related methods expect integer keys for element-wise inclusion or exclusion. To exclude a field from every member of a list or tuple, the dictionary key <code>'__all__'</code> can be used as follows:</p> Python 3.7 and abovePython 3.9 and above <pre><code>import datetime\nfrom typing import List\n\nfrom pydantic import BaseModel, SecretStr\n\n\nclass Country(BaseModel):\n    name: str\n    phone_code: int\n\n\nclass Address(BaseModel):\n    post_code: int\n    country: Country\n\n\nclass CardDetails(BaseModel):\n    number: SecretStr\n    expires: datetime.date\n\n\nclass Hobby(BaseModel):\n    name: str\n    info: str\n\n\nclass User(BaseModel):\n    first_name: str\n    second_name: str\n    address: Address\n    card_details: CardDetails\n    hobbies: List[Hobby]\n\n\nuser = User(\n    first_name='John',\n    second_name='Doe',\n    address=Address(\n        post_code=123456,\n        country=Country(\n            name='USA',\n            phone_code=1\n        )\n    ),\n    card_details=CardDetails(\n        number=4212934504460000,\n        expires=datetime.date(2020, 5, 1)\n    ),\n    hobbies=[\n        Hobby(name='Programming', info='Writing code and stuff'),\n        Hobby(name='Gaming', info='Hell Yeah!!!'),\n    ],\n)\n\nexclude_keys = {\n    'second_name': True,\n    'address': {'post_code': True, 'country': {'phone_code'}},\n    'card_details': True,\n    # You can exclude fields from specific members of a tuple/list by index:\n    'hobbies': {-1: {'info'}},\n}\n\ninclude_keys = {\n    'first_name': True,\n    'address': {'country': {'name'}},\n    'hobbies': {0: True, -1: {'name'}},\n}\n\n# would be the same as user.dict(exclude=exclude_keys) in this case:\nprint(user.dict(include=include_keys))\n\"\"\"\n{\n    'first_name': 'John',\n    'address': {'country': {'name': 'USA'}},\n    'hobbies': [\n        {\n            'name': 'Programming',\n            'info': 'Writing code and stuff',\n        },\n        {'name': 'Gaming'},\n    ],\n}\n\"\"\"\n\n# To exclude a field from all members of a nested list or tuple, use \"__all__\":\nprint(user.dict(exclude={'hobbies': {'__all__': {'info'}}}))\n\"\"\"\n{\n    'first_name': 'John',\n    'second_name': 'Doe',\n    'address': {\n        'post_code': 123456,\n        'country': {'name': 'USA', 'phone_code': 1},\n    },\n    'card_details': {\n        'number': SecretStr('**********'),\n        'expires': datetime.date(2020, 5, 1),\n    },\n    'hobbies': [{'name': 'Programming'}, {'name': 'Gaming'}],\n}\n\"\"\"\n</code></pre> <pre><code>import datetime\n\nfrom pydantic import BaseModel, SecretStr\n\n\nclass Country(BaseModel):\n    name: str\n    phone_code: int\n\n\nclass Address(BaseModel):\n    post_code: int\n    country: Country\n\n\nclass CardDetails(BaseModel):\n    number: SecretStr\n    expires: datetime.date\n\n\nclass Hobby(BaseModel):\n    name: str\n    info: str\n\n\nclass User(BaseModel):\n    first_name: str\n    second_name: str\n    address: Address\n    card_details: CardDetails\n    hobbies: list[Hobby]\n\n\nuser = User(\n    first_name='John',\n    second_name='Doe',\n    address=Address(\n        post_code=123456,\n        country=Country(\n            name='USA',\n            phone_code=1\n        )\n    ),\n    card_details=CardDetails(\n        number=4212934504460000,\n        expires=datetime.date(2020, 5, 1)\n    ),\n    hobbies=[\n        Hobby(name='Programming', info='Writing code and stuff'),\n        Hobby(name='Gaming', info='Hell Yeah!!!'),\n    ],\n)\n\nexclude_keys = {\n    'second_name': True,\n    'address': {'post_code': True, 'country': {'phone_code'}},\n    'card_details': True,\n    # You can exclude fields from specific members of a tuple/list by index:\n    'hobbies': {-1: {'info'}},\n}\n\ninclude_keys = {\n    'first_name': True,\n    'address': {'country': {'name'}},\n    'hobbies': {0: True, -1: {'name'}},\n}\n\n# would be the same as user.dict(exclude=exclude_keys) in this case:\nprint(user.dict(include=include_keys))\n\"\"\"\n{\n    'first_name': 'John',\n    'address': {'country': {'name': 'USA'}},\n    'hobbies': [\n        {\n            'name': 'Programming',\n            'info': 'Writing code and stuff',\n        },\n        {'name': 'Gaming'},\n    ],\n}\n\"\"\"\n\n# To exclude a field from all members of a nested list or tuple, use \"__all__\":\nprint(user.dict(exclude={'hobbies': {'__all__': {'info'}}}))\n\"\"\"\n{\n    'first_name': 'John',\n    'second_name': 'Doe',\n    'address': {\n        'post_code': 123456,\n        'country': {'name': 'USA', 'phone_code': 1},\n    },\n    'card_details': {\n        'number': SecretStr('**********'),\n        'expires': datetime.date(2020, 5, 1),\n    },\n    'hobbies': [{'name': 'Programming'}, {'name': 'Gaming'}],\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>The same holds for the <code>json</code> and <code>copy</code> methods.</p>"},{"location":"usage/exporting_models/#model-and-field-level-include-and-exclude","title":"Model and field level include and exclude","text":"<p>In addition to the explicit arguments <code>exclude</code> and <code>include</code> passed to <code>dict</code>, <code>json</code> and <code>copy</code> methods, we can also pass the <code>include</code>/<code>exclude</code> arguments directly to the <code>Field</code> constructor or the equivalent <code>field</code> entry in the models <code>Config</code> class:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, Field, SecretStr\n\n\nclass User(BaseModel):\n    id: int\n    username: str\n    password: SecretStr = Field(..., exclude=True)\n\n\nclass Transaction(BaseModel):\n    id: str\n    user: User = Field(..., exclude={'username'})\n    value: int\n\n    class Config:\n        fields = {'value': {'exclude': True}}\n\n\nt = Transaction(\n    id='1234567890',\n    user=User(\n        id=42,\n        username='JohnDoe',\n        password='hashedpassword'\n    ),\n    value=9876543210,\n)\n\nprint(t.dict())\n#&gt; {'id': '1234567890', 'user': {'id': 42}}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>In the case where multiple strategies are used, <code>exclude</code>/<code>include</code> fields are merged according to the following rules:</p> <ul> <li>First, model config level settings (via <code>\"fields\"</code> entry) are merged per field with the field constructor settings (i.e. <code>Field(..., exclude=True)</code>), with the field constructor taking priority.</li> <li>The resulting settings are merged per class with the explicit settings on <code>dict</code>, <code>json</code>, <code>copy</code> calls with the explicit settings taking priority.</li> </ul> <p>Note that while merging settings, <code>exclude</code> entries are merged by computing the \"union\" of keys, while <code>include</code> entries are merged by computing the \"intersection\" of keys.</p> <p>The resulting merged exclude settings:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, Field, SecretStr\n\n\nclass User(BaseModel):\n    id: int\n    username: str  # overridden by explicit exclude\n    password: SecretStr = Field(exclude=True)\n\n\nclass Transaction(BaseModel):\n    id: str\n    user: User\n    value: int\n\n\nt = Transaction(\n    id='1234567890',\n    user=User(\n        id=42,\n        username='JohnDoe',\n        password='hashedpassword'\n    ),\n    value=9876543210,\n)\n\nprint(t.dict(exclude={'value': True, 'user': {'username'}}))\n#&gt; {'id': '1234567890', 'user': {'id': 42}}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>are the same as using merged include settings as follows:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, Field, SecretStr\n\n\nclass User(BaseModel):\n    id: int = Field(..., include=True)\n    username: str = Field(..., include=True)  # overridden by explicit include\n    password: SecretStr\n\n\nclass Transaction(BaseModel):\n    id: str\n    user: User\n    value: int\n\n\nt = Transaction(\n    id='1234567890',\n    user=User(\n        id=42,\n        username='JohnDoe',\n        password='hashedpassword'\n    ),\n    value=9876543210,\n)\n\nprint(t.dict(include={'id': True, 'user': {'id'}}))\n#&gt; {'id': '1234567890', 'user': {'id': 42}}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/model_config/","title":"Model Config","text":"<p>Behaviour of pydantic can be controlled via the <code>Config</code> class on a model or a pydantic dataclass.</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    v: str\n\n    class Config:\n        max_anystr_length = 10\n        error_msg_templates = {\n            'value_error.any_str.max_length': 'max_length:{limit_value}',\n        }\n\n\ntry:\n    Model(v='x' * 20)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    v\n      max_length:10 (type=value_error.any_str.max_length; limit_value=10)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Also, you can specify config options as model class kwargs:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, ValidationError, Extra\n\n\nclass Model(BaseModel, extra=Extra.forbid):\n    a: str\n\n\ntry:\n    Model(a='spam', b='oh no')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    b\n      extra fields not permitted (type=value_error.extra)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Similarly, if using the <code>@dataclass</code> decorator:</p> Python 3.7 and above <pre><code>from datetime import datetime\n\nfrom pydantic import ValidationError\nfrom pydantic.dataclasses import dataclass\n\n\nclass MyConfig:\n    max_anystr_length = 10\n    validate_assignment = True\n    error_msg_templates = {\n        'value_error.any_str.max_length': 'max_length:{limit_value}',\n    }\n\n\n@dataclass(config=MyConfig)\nclass User:\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime = None\n\n\nuser = User(id='42', signup_ts='2032-06-21T12:00')\ntry:\n    user.name = 'x' * 20\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      max_length:10 (type=value_error.any_str.max_length; limit_value=10)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/model_config/#options","title":"Options","text":"<code>title</code> the title for the generated JSON Schema <code>anystr_strip_whitespace</code> whether to strip leading and trailing whitespace for str &amp; byte types (default: <code>False</code>) <code>anystr_upper</code> whether to make all characters uppercase for str &amp; byte types (default: <code>False</code>) <code>anystr_lower</code> whether to make all characters lowercase for str &amp; byte types (default: <code>False</code>) <code>min_anystr_length</code> the min length for str &amp; byte types (default: <code>0</code>) <code>max_anystr_length</code> the max length for str &amp; byte types (default: <code>None</code>) <code>validate_all</code> whether to validate field defaults (default: <code>False</code>) <code>extra</code> whether to ignore, allow, or forbid extra attributes during model initialization. Accepts the string values of <code>'ignore'</code>, <code>'allow'</code>, or <code>'forbid'</code>, or values of the <code>Extra</code> enum (default: <code>Extra.ignore</code>). <code>'forbid'</code> will cause validation to fail if extra attributes are included, <code>'ignore'</code> will silently ignore any extra attributes, and <code>'allow'</code> will assign the attributes to the model. <code>allow_mutation</code> whether or not models are faux-immutable, i.e. whether <code>__setattr__</code> is allowed (default: <code>True</code>) <p><code>frozen</code></p> <p>Warning</p> <p>This parameter is in beta</p> setting <code>frozen=True</code> does everything that <code>allow_mutation=False</code> does, and also generates a <code>__hash__()</code> method for the model. This makes instances of the model potentially hashable if all the attributes are hashable. (default: <code>False</code>) <code>use_enum_values</code> whether to populate models with the <code>value</code> property of enums, rather than the raw enum. This may be useful if you want to serialise <code>model.dict()</code> later (default: <code>False</code>) <code>fields</code> a <code>dict</code> containing schema information for each field; this is equivalent to using the <code>Field</code> class, except when a field is already defined through annotation or the Field class, in which case only <code>alias</code>, <code>include</code>, <code>exclude</code>, <code>min_length</code>, <code>max_length</code>, <code>regex</code>, <code>gt</code>, <code>lt</code>, <code>gt</code>, <code>le</code>, <code>multiple_of</code>, <code>max_digits</code>, <code>decimal_places</code>, <code>min_items</code>, <code>max_items</code>, <code>unique_items</code> and allow_mutation can be set (for example you cannot set default of default_factory)  (default: <code>None</code>) <code>validate_assignment</code> whether to perform validation on assignment to attributes (default: <code>False</code>) <code>allow_population_by_field_name</code> whether an aliased field may be populated by its name as given by the model attribute, as well as the alias (default: <code>False</code>) <p>Note</p> <p>The name of this configuration setting was changed in v1.0 from <code>allow_population_by_alias</code> to <code>allow_population_by_field_name</code>.</p> <code>error_msg_templates</code> a <code>dict</code> used to override the default error message templates. Pass in a dictionary with keys matching the error messages you want to override (default: <code>{}</code>) <code>arbitrary_types_allowed</code> whether to allow arbitrary user types for fields (they are validated simply by checking if the value is an instance of the type). If <code>False</code>, <code>RuntimeError</code> will be raised on model declaration (default: <code>False</code>). See an example in Field Types. <code>orm_mode</code> whether to allow usage of ORM mode <code>getter_dict</code> a custom class (which should inherit from <code>GetterDict</code>) to use when decomposing arbitrary classes for validation, for use with <code>orm_mode</code>; see Data binding. <code>alias_generator</code> a callable that takes a field name and returns an alias for it; see the dedicated section <code>keep_untouched</code> a tuple of types (e.g. descriptors) for a model's default values that should not be changed during model creation and will not be included in the model schemas. Note: this means that attributes on the model with defaults of this type, not annotations of this type, will be left alone. <code>schema_extra</code> a <code>dict</code> used to extend/update the generated JSON Schema, or a callable to post-process it; see schema customization <code>json_loads</code> a custom function for decoding JSON; see custom JSON (de)serialisation <code>json_dumps</code> a custom function for encoding JSON; see custom JSON (de)serialisation <code>json_encoders</code> a <code>dict</code> used to customise the way types are encoded to JSON; see JSON Serialisation <code>underscore_attrs_are_private</code> whether to treat any underscore non-class var attrs as private, or leave them as is; see Private model attributes <code>copy_on_model_validation</code> string literal to control how models instances are processed during validation,  with the following means (see #4093 for a full discussion of the changes to this field): <ul> <li><code>'none'</code> - models are not copied on validation, they're simply kept \"untouched\"</li> <li><code>'shallow'</code> - models are shallow copied, this is the default</li> <li><code>'deep'</code> - models are deep copied </li> </ul> <code>smart_union</code> whether pydantic should try to check all types inside <code>Union</code> to prevent undesired coercion; see the dedicated section <code>post_init_call</code> whether stdlib dataclasses <code>__post_init__</code> should be run before (default behaviour with value <code>'before_validation'</code>) or after (value <code>'after_validation'</code>) parsing and validation when they are converted. <code>allow_inf_nan</code> whether to allow infinity (<code>+inf</code> an <code>-inf</code>) and NaN values to float fields, defaults to <code>True</code>, set to <code>False</code> for compatibility with <code>JSON</code>, see #3994 for more details, added in V1.10"},{"location":"usage/model_config/#change-behaviour-globally","title":"Change behaviour globally","text":"<p>If you wish to change the behaviour of pydantic globally, you can create your own custom <code>BaseModel</code> with custom <code>Config</code> since the config is inherited</p> Python 3.7 and above <pre><code>from pydantic import BaseModel as PydanticBaseModel\n\n\nclass BaseModel(PydanticBaseModel):\n    class Config:\n        arbitrary_types_allowed = True\n\n\nclass MyClass:\n    \"\"\"A random class\"\"\"\n\n\nclass Model(BaseModel):\n    x: MyClass\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/model_config/#alias-generator","title":"Alias Generator","text":"<p>If data source field names do not match your code style (e. g. CamelCase fields), you can automatically generate aliases using <code>alias_generator</code>:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel\n\n\ndef to_camel(string: str) -&gt; str:\n    return ''.join(word.capitalize() for word in string.split('_'))\n\n\nclass Voice(BaseModel):\n    name: str\n    language_code: str\n\n    class Config:\n        alias_generator = to_camel\n\n\nvoice = Voice(Name='Filiz', LanguageCode='tr-TR')\nprint(voice.language_code)\n#&gt; tr-TR\nprint(voice.dict(by_alias=True))\n#&gt; {'Name': 'Filiz', 'LanguageCode': 'tr-TR'}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Here camel case refers to \"upper camel case\" aka pascal case e.g. <code>CamelCase</code>. If you'd like instead to use lower camel case e.g. <code>camelCase</code>, instead use the <code>to_lower_camel</code> function.</p>"},{"location":"usage/model_config/#alias-precedence","title":"Alias Precedence","text":"<p>Warning</p> <p>Alias priority logic changed in v1.4 to resolve buggy and unexpected behaviour in previous versions. In some circumstances this may represent a breaking change, see #1178 and the precedence order below for details.</p> <p>In the case where a field's alias may be defined in multiple places, the selected value is determined as follows (in descending order of priority):</p> <ol> <li>Set via <code>Field(..., alias=&lt;alias&gt;)</code>, directly on the model</li> <li>Defined in <code>Config.fields</code>, directly on the model</li> <li>Set via <code>Field(..., alias=&lt;alias&gt;)</code>, on a parent model</li> <li>Defined in <code>Config.fields</code>, on a parent model</li> <li>Generated by <code>alias_generator</code>, regardless of whether it's on the model or a parent</li> </ol> <p>Note</p> <p>This means an <code>alias_generator</code> defined on a child model does not take priority over an alias defined on a field in a parent model.</p> <p>For example:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, Field\n\n\nclass Voice(BaseModel):\n    name: str = Field(None, alias='ActorName')\n    language_code: str = None\n    mood: str = None\n\n\nclass Character(Voice):\n    act: int = 1\n\n    class Config:\n        fields = {'language_code': 'lang'}\n\n        @classmethod\n        def alias_generator(cls, string: str) -&gt; str:\n            # this is the same as `alias_generator = to_camel` above\n            return ''.join(word.capitalize() for word in string.split('_'))\n\n\nprint(Character.schema(by_alias=True))\n\"\"\"\n{\n    'title': 'Character',\n    'type': 'object',\n    'properties': {\n        'ActorName': {'title': 'Actorname', 'type': 'string'},\n        'lang': {'title': 'Lang', 'type': 'string'},\n        'Mood': {'title': 'Mood', 'type': 'string'},\n        'Act': {'title': 'Act', 'default': 1, 'type': 'integer'},\n    },\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/model_config/#smart-union","title":"Smart Union","text":"<p>By default, as explained here, pydantic tries to validate (and coerce if it can) in the order of the <code>Union</code>. So sometimes you may have unexpected coerced data.</p> Python 3.7 and abovePython 3.10 and above <pre><code>from typing import Union\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    pass\n\n\nclass Bar(BaseModel):\n    pass\n\n\nclass Model(BaseModel):\n    x: Union[str, int]\n    y: Union[Foo, Bar]\n\n\nprint(Model(x=1, y=Bar()))\n#&gt; x='1' y=Foo()\n</code></pre> <pre><code>from pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    pass\n\n\nclass Bar(BaseModel):\n    pass\n\n\nclass Model(BaseModel):\n    x: str | int\n    y: Foo | Bar\n\n\nprint(Model(x=1, y=Bar()))\n#&gt; x='1' y=Foo()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>To prevent this, you can enable <code>Config.smart_union</code>. Pydantic will then check all allowed types before even trying to coerce. Know that this is of course slower, especially if your <code>Union</code> is quite big.</p> Python 3.7 and abovePython 3.10 and above <pre><code>from typing import Union\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    pass\n\n\nclass Bar(BaseModel):\n    pass\n\n\nclass Model(BaseModel):\n    x: Union[str, int]\n    y: Union[Foo, Bar]\n\n    class Config:\n        smart_union = True\n\n\nprint(Model(x=1, y=Bar()))\n#&gt; x=1 y=Bar()\n</code></pre> <pre><code>from pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    pass\n\n\nclass Bar(BaseModel):\n    pass\n\n\nclass Model(BaseModel):\n    x: str | int\n    y: Foo | Bar\n\n    class Config:\n        smart_union = True\n\n\nprint(Model(x=1, y=Bar()))\n#&gt; x=1 y=Bar()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Warning</p> <p>Note that this option does not support compound types yet (e.g. differentiate <code>List[int]</code> and <code>List[str]</code>). This option will be improved further once a strict mode is added in pydantic and will probably be the default behaviour in v2!</p> Python 3.7 and abovePython 3.9 and abovePython 3.10 and above <pre><code>from typing import List, Union\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel, smart_union=True):\n    x: Union[List[str], List[int]]\n\n\n# Expected coercion\nprint(Model(x=[1, '2']))\n#&gt; x=['1', '2']\n\n# Unexpected coercion\nprint(Model(x=[1, 2]))\n#&gt; x=['1', '2']\n</code></pre> <pre><code>from typing import Union\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel, smart_union=True):\n    x: Union[list[str], list[int]]\n\n\n# Expected coercion\nprint(Model(x=[1, '2']))\n#&gt; x=['1', '2']\n\n# Unexpected coercion\nprint(Model(x=[1, 2]))\n#&gt; x=['1', '2']\n</code></pre> <pre><code>from pydantic import BaseModel\n\n\nclass Model(BaseModel, smart_union=True):\n    x: list[str] | list[int]\n\n\n# Expected coercion\nprint(Model(x=[1, '2']))\n#&gt; x=['1', '2']\n\n# Unexpected coercion\nprint(Model(x=[1, 2]))\n#&gt; x=['1', '2']\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/models/","title":"Models","text":"<p>The primary means of defining objects in pydantic is via models  (models are simply classes which inherit from <code>BaseModel</code>).</p> <p>You can think of models as similar to types in strictly typed languages, or as the requirements of a single endpoint in an API.</p> <p>Untrusted data can be passed to a model, and after parsing and validation pydantic guarantees that the fields of the resultant model instance will conform to the field types defined on the model.</p> <p>Note</p> <p>pydantic is primarily a parsing library, not a validation library. Validation is a means to an end: building a model which conforms to the types and constraints provided.</p> <p>In other words, pydantic guarantees the types and constraints of the output model, not the input data.</p> <p>This might sound like an esoteric distinction, but it is not. If you're unsure what this means or how it might affect your usage you should read the section about Data Conversion below.</p> <p>Although validation is not the main purpose of pydantic, you can use this library for custom validation.</p>"},{"location":"usage/models/#basic-model-usage","title":"Basic model usage","text":"<p><pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name = 'Jane Doe'\n</code></pre> <code>User</code> here is a model with two fields <code>id</code> which is an integer and is required,  and <code>name</code> which is a string and is not required (it has a default value). The type of <code>name</code> is inferred from the default value, and so a type annotation is not required (however note this warning about field  order when some fields do not have type annotations). <pre><code>user = User(id='123')\nuser_x = User(id='123.45')\n</code></pre> <code>user</code> here is an instance of <code>User</code>. Initialisation of the object will perform all parsing and validation, if no <code>ValidationError</code> is raised, you know the resulting model instance is valid. <pre><code>assert user.id == 123\nassert user_x.id == 123\nassert isinstance(user_x.id, int)  # Note that 123.45 was casted to an int and its value is 123\n</code></pre> More details on the casting in the case of <code>user_x</code> can be found in Data Conversion. Fields of a model can be accessed as normal attributes of the user object. The string '123' has been cast to an int as per the field type <pre><code>assert user.name == 'Jane Doe'\n</code></pre> <code>name</code> wasn't set when user was initialised, so it has the default value <pre><code>assert user.__fields_set__ == {'id'}\n</code></pre> The fields which were supplied when user was initialised. <pre><code>assert user.dict() == dict(user) == {'id': 123, 'name': 'Jane Doe'}\n</code></pre> Either <code>.dict()</code> or <code>dict(user)</code> will provide a dict of fields, but <code>.dict()</code> can take numerous other arguments. <pre><code>user.id = 321\nassert user.id == 321\n</code></pre> This model is mutable so field values can be changed.</p>"},{"location":"usage/models/#model-properties","title":"Model properties","text":"<p>The example above only shows the tip of the iceberg of what models can do.  Models possess the following methods and attributes:</p> <code>dict()</code> returns a dictionary of the model's fields and values;  cf. exporting models <code>json()</code> returns a JSON string representation <code>dict()</code>;  cf. exporting models <code>copy()</code> returns a copy (by default, shallow copy) of the model; cf. exporting models <code>parse_obj()</code> a utility for loading any object into a model with error handling if the object is not a dictionary; cf. helper functions <code>parse_raw()</code> a utility for loading strings of numerous formats; cf. helper functions <code>parse_file()</code> like <code>parse_raw()</code> but for file paths; cf. helper functions <code>from_orm()</code> loads data into a model from an arbitrary class; cf. ORM mode <code>schema()</code> returns a dictionary representing the model as JSON Schema; cf. schema <code>schema_json()</code> returns a JSON string representation of <code>schema()</code>; cf. schema <code>construct()</code> a class method for creating models without running validation;  cf. Creating models without validation <code>__fields_set__</code> Set of names of fields which were set when the model instance was initialised <code>__fields__</code> a dictionary of the model's fields <code>__config__</code> the configuration class for the model, cf. model config"},{"location":"usage/models/#recursive-models","title":"Recursive Models","text":"<p>More complex hierarchical data structures can be defined using models themselves as types in annotations.</p> Python 3.7 and abovePython 3.9 and abovePython 3.10 and above <pre><code>from typing import List, Optional\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    count: int\n    size: Optional[float] = None\n\n\nclass Bar(BaseModel):\n    apple = 'x'\n    banana = 'y'\n\n\nclass Spam(BaseModel):\n    foo: Foo\n    bars: List[Bar]\n\n\nm = Spam(foo={'count': 4}, bars=[{'apple': 'x1'}, {'apple': 'x2'}])\nprint(m)\n#&gt; foo=Foo(count=4, size=None) bars=[Bar(apple='x1', banana='y'),\n#&gt; Bar(apple='x2', banana='y')]\nprint(m.dict())\n\"\"\"\n{\n    'foo': {'count': 4, 'size': None},\n    'bars': [\n        {'apple': 'x1', 'banana': 'y'},\n        {'apple': 'x2', 'banana': 'y'},\n    ],\n}\n\"\"\"\n</code></pre> <pre><code>from typing import Optional\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    count: int\n    size: Optional[float] = None\n\n\nclass Bar(BaseModel):\n    apple = 'x'\n    banana = 'y'\n\n\nclass Spam(BaseModel):\n    foo: Foo\n    bars: list[Bar]\n\n\nm = Spam(foo={'count': 4}, bars=[{'apple': 'x1'}, {'apple': 'x2'}])\nprint(m)\n#&gt; foo=Foo(count=4, size=None) bars=[Bar(apple='x1', banana='y'),\n#&gt; Bar(apple='x2', banana='y')]\nprint(m.dict())\n\"\"\"\n{\n    'foo': {'count': 4, 'size': None},\n    'bars': [\n        {'apple': 'x1', 'banana': 'y'},\n        {'apple': 'x2', 'banana': 'y'},\n    ],\n}\n\"\"\"\n</code></pre> <pre><code>from pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    count: int\n    size: float | None = None\n\n\nclass Bar(BaseModel):\n    apple = 'x'\n    banana = 'y'\n\n\nclass Spam(BaseModel):\n    foo: Foo\n    bars: list[Bar]\n\n\nm = Spam(foo={'count': 4}, bars=[{'apple': 'x1'}, {'apple': 'x2'}])\nprint(m)\n#&gt; foo=Foo(count=4, size=None) bars=[Bar(apple='x1', banana='y'),\n#&gt; Bar(apple='x2', banana='y')]\nprint(m.dict())\n\"\"\"\n{\n    'foo': {'count': 4, 'size': None},\n    'bars': [\n        {'apple': 'x1', 'banana': 'y'},\n        {'apple': 'x2', 'banana': 'y'},\n    ],\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>For self-referencing models, see postponed annotations.</p>"},{"location":"usage/models/#orm-mode-aka-arbitrary-class-instances","title":"ORM Mode (aka Arbitrary Class Instances)","text":"<p>Pydantic models can be created from arbitrary class instances to support models that map to ORM objects.</p> <p>To do this:</p> <ol> <li>The Config property <code>orm_mode</code> must be set to <code>True</code>.</li> <li>The special constructor <code>from_orm</code> must be used to create the model instance.</li> </ol> <p>The example here uses SQLAlchemy, but the same approach should work for any ORM.</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import List\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.dialects.postgresql import ARRAY\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom pydantic import BaseModel, constr\n\nBase = declarative_base()\n\n\nclass CompanyOrm(Base):\n    __tablename__ = 'companies'\n    id = Column(Integer, primary_key=True, nullable=False)\n    public_key = Column(String(20), index=True, nullable=False, unique=True)\n    name = Column(String(63), unique=True)\n    domains = Column(ARRAY(String(255)))\n\n\nclass CompanyModel(BaseModel):\n    id: int\n    public_key: constr(max_length=20)\n    name: constr(max_length=63)\n    domains: List[constr(max_length=255)]\n\n    class Config:\n        orm_mode = True\n\n\nco_orm = CompanyOrm(\n    id=123,\n    public_key='foobar',\n    name='Testing',\n    domains=['example.com', 'foobar.com'],\n)\nprint(co_orm)\n#&gt; &lt;models_orm_mode.CompanyOrm object at 0x7fa11317ab60&gt;\nco_model = CompanyModel.from_orm(co_orm)\nprint(co_model)\n#&gt; id=123 public_key='foobar' name='Testing' domains=['example.com',\n#&gt; 'foobar.com']\n</code></pre> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.dialects.postgresql import ARRAY\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom pydantic import BaseModel, constr\n\nBase = declarative_base()\n\n\nclass CompanyOrm(Base):\n    __tablename__ = 'companies'\n    id = Column(Integer, primary_key=True, nullable=False)\n    public_key = Column(String(20), index=True, nullable=False, unique=True)\n    name = Column(String(63), unique=True)\n    domains = Column(ARRAY(String(255)))\n\n\nclass CompanyModel(BaseModel):\n    id: int\n    public_key: constr(max_length=20)\n    name: constr(max_length=63)\n    domains: list[constr(max_length=255)]\n\n    class Config:\n        orm_mode = True\n\n\nco_orm = CompanyOrm(\n    id=123,\n    public_key='foobar',\n    name='Testing',\n    domains=['example.com', 'foobar.com'],\n)\nprint(co_orm)\n#&gt; &lt;models_orm_mode_3_9.CompanyOrm object at 0x7fa11232e1a0&gt;\nco_model = CompanyModel.from_orm(co_orm)\nprint(co_model)\n#&gt; id=123 public_key='foobar' name='Testing' domains=['example.com',\n#&gt; 'foobar.com']\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/models/#reserved-names","title":"Reserved names","text":"<p>You may want to name a Column after a reserved SQLAlchemy field. In that case, Field aliases will be convenient:</p> Python 3.7 and abovePython 3.9 and above <pre><code>import typing\n\nfrom pydantic import BaseModel, Field\nimport sqlalchemy as sa\nfrom sqlalchemy.ext.declarative import declarative_base\n\n\nclass MyModel(BaseModel):\n    metadata: typing.Dict[str, str] = Field(alias='metadata_')\n\n    class Config:\n        orm_mode = True\n\n\nBase = declarative_base()\n\n\nclass SQLModel(Base):\n    __tablename__ = 'my_table'\n    id = sa.Column('id', sa.Integer, primary_key=True)\n    # 'metadata' is reserved by SQLAlchemy, hence the '_'\n    metadata_ = sa.Column('metadata', sa.JSON)\n\n\nsql_model = SQLModel(metadata_={'key': 'val'}, id=1)\n\npydantic_model = MyModel.from_orm(sql_model)\n\nprint(pydantic_model.dict())\n#&gt; {'metadata': {'key': 'val'}}\nprint(pydantic_model.dict(by_alias=True))\n#&gt; {'metadata_': {'key': 'val'}}\n</code></pre> <pre><code>from pydantic import BaseModel, Field\nimport sqlalchemy as sa\nfrom sqlalchemy.ext.declarative import declarative_base\n\n\nclass MyModel(BaseModel):\n    metadata: dict[str, str] = Field(alias='metadata_')\n\n    class Config:\n        orm_mode = True\n\n\nBase = declarative_base()\n\n\nclass SQLModel(Base):\n    __tablename__ = 'my_table'\n    id = sa.Column('id', sa.Integer, primary_key=True)\n    # 'metadata' is reserved by SQLAlchemy, hence the '_'\n    metadata_ = sa.Column('metadata', sa.JSON)\n\n\nsql_model = SQLModel(metadata_={'key': 'val'}, id=1)\n\npydantic_model = MyModel.from_orm(sql_model)\n\nprint(pydantic_model.dict())\n#&gt; {'metadata': {'key': 'val'}}\nprint(pydantic_model.dict(by_alias=True))\n#&gt; {'metadata_': {'key': 'val'}}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>The example above works because aliases have priority over field names for field population. Accessing <code>SQLModel</code>'s <code>metadata</code> attribute would lead to a <code>ValidationError</code>.</p>"},{"location":"usage/models/#recursive-orm-models","title":"Recursive ORM models","text":"<p>ORM instances will be parsed with <code>from_orm</code> recursively as well as at the top level.</p> <p>Here a vanilla class is used to demonstrate the principle, but any ORM class could be used instead.</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import List\nfrom pydantic import BaseModel\n\n\nclass PetCls:\n    def __init__(self, *, name: str, species: str):\n        self.name = name\n        self.species = species\n\n\nclass PersonCls:\n    def __init__(self, *, name: str, age: float = None, pets: List[PetCls]):\n        self.name = name\n        self.age = age\n        self.pets = pets\n\n\nclass Pet(BaseModel):\n    name: str\n    species: str\n\n    class Config:\n        orm_mode = True\n\n\nclass Person(BaseModel):\n    name: str\n    age: float = None\n    pets: List[Pet]\n\n    class Config:\n        orm_mode = True\n\n\nbones = PetCls(name='Bones', species='dog')\norion = PetCls(name='Orion', species='cat')\nanna = PersonCls(name='Anna', age=20, pets=[bones, orion])\nanna_model = Person.from_orm(anna)\nprint(anna_model)\n#&gt; name='Anna' age=20.0 pets=[Pet(name='Bones', species='dog'),\n#&gt; Pet(name='Orion', species='cat')]\n</code></pre> <pre><code>from pydantic import BaseModel\n\n\nclass PetCls:\n    def __init__(self, *, name: str, species: str):\n        self.name = name\n        self.species = species\n\n\nclass PersonCls:\n    def __init__(self, *, name: str, age: float = None, pets: list[PetCls]):\n        self.name = name\n        self.age = age\n        self.pets = pets\n\n\nclass Pet(BaseModel):\n    name: str\n    species: str\n\n    class Config:\n        orm_mode = True\n\n\nclass Person(BaseModel):\n    name: str\n    age: float = None\n    pets: list[Pet]\n\n    class Config:\n        orm_mode = True\n\n\nbones = PetCls(name='Bones', species='dog')\norion = PetCls(name='Orion', species='cat')\nanna = PersonCls(name='Anna', age=20, pets=[bones, orion])\nanna_model = Person.from_orm(anna)\nprint(anna_model)\n#&gt; name='Anna' age=20.0 pets=[Pet(name='Bones', species='dog'),\n#&gt; Pet(name='Orion', species='cat')]\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/models/#data-binding","title":"Data binding","text":"<p>Arbitrary classes are processed by pydantic using the <code>GetterDict</code> class (see utils.py), which attempts to provide a dictionary-like interface to any class. You can customise how this works by setting your own sub-class of <code>GetterDict</code> as the value of <code>Config.getter_dict</code> (see config).</p> <p>You can also customise class validation using root_validators with <code>pre=True</code>.  In this case your validator function will be passed a <code>GetterDict</code> instance which you may copy and modify.</p> <p>The <code>GetterDict</code> instance will be called for each field with a sentinel as a fallback (if no other default value is set). Returning this sentinel means that the field is missing. Any other value will be interpreted as the value of the field.</p> Python 3.7 and abovePython 3.10 and above <pre><code>from pydantic import BaseModel\nfrom typing import Any, Optional\nfrom pydantic.utils import GetterDict\nfrom xml.etree.ElementTree import fromstring\n\n\nxmlstring = \"\"\"\n&lt;User Id=\"2138\"&gt;\n    &lt;FirstName /&gt;\n    &lt;LoggedIn Value=\"true\" /&gt;\n&lt;/User&gt;\n\"\"\"\n\n\nclass UserGetter(GetterDict):\n\n    def get(self, key: str, default: Any) -&gt; Any:\n\n        # element attributes\n        if key in {'Id', 'Status'}:\n            return self._obj.attrib.get(key, default)\n\n        # element children\n        else:\n            try:\n                return self._obj.find(key).attrib['Value']\n            except (AttributeError, KeyError):\n                return default\n\n\nclass User(BaseModel):\n    Id: int\n    Status: Optional[str]\n    FirstName: Optional[str]\n    LastName: Optional[str]\n    LoggedIn: bool\n\n    class Config:\n        orm_mode = True\n        getter_dict = UserGetter\n\n\nuser = User.from_orm(fromstring(xmlstring))\n</code></pre> <pre><code>from pydantic import BaseModel\nfrom typing import Any\nfrom pydantic.utils import GetterDict\nfrom xml.etree.ElementTree import fromstring\n\n\nxmlstring = \"\"\"\n&lt;User Id=\"2138\"&gt;\n    &lt;FirstName /&gt;\n    &lt;LoggedIn Value=\"true\" /&gt;\n&lt;/User&gt;\n\"\"\"\n\n\nclass UserGetter(GetterDict):\n\n    def get(self, key: str, default: Any) -&gt; Any:\n\n        # element attributes\n        if key in {'Id', 'Status'}:\n            return self._obj.attrib.get(key, default)\n\n        # element children\n        else:\n            try:\n                return self._obj.find(key).attrib['Value']\n            except (AttributeError, KeyError):\n                return default\n\n\nclass User(BaseModel):\n    Id: int\n    Status: str | None\n    FirstName: str | None\n    LastName: str | None\n    LoggedIn: bool\n\n    class Config:\n        orm_mode = True\n        getter_dict = UserGetter\n\n\nuser = User.from_orm(fromstring(xmlstring))\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/models/#error-handling","title":"Error Handling","text":"<p>pydantic will raise <code>ValidationError</code> whenever it finds an error in the data it's validating.</p> <p>Note</p> <p>Validation code should not raise <code>ValidationError</code> itself, but rather raise <code>ValueError</code>, <code>TypeError</code> or <code>AssertionError</code> (or subclasses of <code>ValueError</code> or <code>TypeError</code>) which will be caught and used to populate <code>ValidationError</code>.</p> <p>One exception will be raised regardless of the number of errors found, that <code>ValidationError</code> will contain information about all the errors and how they happened.</p> <p>You can access these errors in several ways:</p> <code>e.errors()</code> method will return list of errors found in the input data. <code>e.json()</code> method will return a JSON representation of <code>errors</code>. <code>str(e)</code> method will return a human readable representation of the errors. <p>Each error object contains:</p> <code>loc</code> the error's location as a list. The first item in the list will be the field where the error occurred, and if the field is a sub-model, subsequent items will be present to indicate the nested location of the error. <code>type</code> a computer-readable identifier of the error type. <code>msg</code> a human readable explanation of the error. <code>ctx</code> an optional object which contains values required to render the error message. <p>As a demonstration:</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import List\nfrom pydantic import BaseModel, ValidationError, conint\n\n\nclass Location(BaseModel):\n    lat = 0.1\n    lng = 10.1\n\n\nclass Model(BaseModel):\n    is_required: float\n    gt_int: conint(gt=42)\n    list_of_ints: List[int] = None\n    a_float: float = None\n    recursive_model: Location = None\n\n\ndata = dict(\n    list_of_ints=['1', 2, 'bad'],\n    a_float='not a float',\n    recursive_model={'lat': 4.2, 'lng': 'New York'},\n    gt_int=21,\n)\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    5 validation errors for Model\n    is_required\n      field required (type=value_error.missing)\n    gt_int\n      ensure this value is greater than 42 (type=value_error.number.not_gt;\n    limit_value=42)\n    list_of_ints -&gt; 2\n      value is not a valid integer (type=type_error.integer)\n    a_float\n      value is not a valid float (type=type_error.float)\n    recursive_model -&gt; lng\n      value is not a valid float (type=type_error.float)\n    \"\"\"\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e.json())\n    \"\"\"\n    [\n      {\n        \"loc\": [\n          \"is_required\"\n        ],\n        \"msg\": \"field required\",\n        \"type\": \"value_error.missing\"\n      },\n      {\n        \"loc\": [\n          \"gt_int\"\n        ],\n        \"msg\": \"ensure this value is greater than 42\",\n        \"type\": \"value_error.number.not_gt\",\n        \"ctx\": {\n          \"limit_value\": 42\n        }\n      },\n      {\n        \"loc\": [\n          \"list_of_ints\",\n          2\n        ],\n        \"msg\": \"value is not a valid integer\",\n        \"type\": \"type_error.integer\"\n      },\n      {\n        \"loc\": [\n          \"a_float\"\n        ],\n        \"msg\": \"value is not a valid float\",\n        \"type\": \"type_error.float\"\n      },\n      {\n        \"loc\": [\n          \"recursive_model\",\n          \"lng\"\n        ],\n        \"msg\": \"value is not a valid float\",\n        \"type\": \"type_error.float\"\n      }\n    ]\n    \"\"\"\n</code></pre> <pre><code>from pydantic import BaseModel, ValidationError, conint\n\n\nclass Location(BaseModel):\n    lat = 0.1\n    lng = 10.1\n\n\nclass Model(BaseModel):\n    is_required: float\n    gt_int: conint(gt=42)\n    list_of_ints: list[int] = None\n    a_float: float = None\n    recursive_model: Location = None\n\n\ndata = dict(\n    list_of_ints=['1', 2, 'bad'],\n    a_float='not a float',\n    recursive_model={'lat': 4.2, 'lng': 'New York'},\n    gt_int=21,\n)\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    5 validation errors for Model\n    is_required\n      field required (type=value_error.missing)\n    gt_int\n      ensure this value is greater than 42 (type=value_error.number.not_gt;\n    limit_value=42)\n    list_of_ints -&gt; 2\n      value is not a valid integer (type=type_error.integer)\n    a_float\n      value is not a valid float (type=type_error.float)\n    recursive_model -&gt; lng\n      value is not a valid float (type=type_error.float)\n    \"\"\"\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e.json())\n    \"\"\"\n    [\n      {\n        \"loc\": [\n          \"is_required\"\n        ],\n        \"msg\": \"field required\",\n        \"type\": \"value_error.missing\"\n      },\n      {\n        \"loc\": [\n          \"gt_int\"\n        ],\n        \"msg\": \"ensure this value is greater than 42\",\n        \"type\": \"value_error.number.not_gt\",\n        \"ctx\": {\n          \"limit_value\": 42\n        }\n      },\n      {\n        \"loc\": [\n          \"list_of_ints\",\n          2\n        ],\n        \"msg\": \"value is not a valid integer\",\n        \"type\": \"type_error.integer\"\n      },\n      {\n        \"loc\": [\n          \"a_float\"\n        ],\n        \"msg\": \"value is not a valid float\",\n        \"type\": \"type_error.float\"\n      },\n      {\n        \"loc\": [\n          \"recursive_model\",\n          \"lng\"\n        ],\n        \"msg\": \"value is not a valid float\",\n        \"type\": \"type_error.float\"\n      }\n    ]\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/models/#custom-errors","title":"Custom Errors","text":"<p>In your custom data types or validators you should use <code>ValueError</code>, <code>TypeError</code> or <code>AssertionError</code> to raise errors.</p> <p>See validators for more details on use of the <code>@validator</code> decorator.</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, ValidationError, validator\n\n\nclass Model(BaseModel):\n    foo: str\n\n    @validator('foo')\n    def value_must_equal_bar(cls, v):\n        if v != 'bar':\n            raise ValueError('value must be \"bar\"')\n\n        return v\n\n\ntry:\n    Model(foo='ber')\nexcept ValidationError as e:\n    print(e.errors())\n    \"\"\"\n    [\n        {\n            'loc': ('foo',),\n            'msg': 'value must be \"bar\"',\n            'type': 'value_error',\n        },\n    ]\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>You can also define your own error classes, which can specify a custom error code, message template, and context:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, PydanticValueError, ValidationError, validator\n\n\nclass NotABarError(PydanticValueError):\n    code = 'not_a_bar'\n    msg_template = 'value is not \"bar\", got \"{wrong_value}\"'\n\n\nclass Model(BaseModel):\n    foo: str\n\n    @validator('foo')\n    def value_must_equal_bar(cls, v):\n        if v != 'bar':\n            raise NotABarError(wrong_value=v)\n        return v\n\n\ntry:\n    Model(foo='ber')\nexcept ValidationError as e:\n    print(e.json())\n    \"\"\"\n    [\n      {\n        \"loc\": [\n          \"foo\"\n        ],\n        \"msg\": \"value is not \\\"bar\\\", got \\\"ber\\\"\",\n        \"type\": \"value_error.not_a_bar\",\n        \"ctx\": {\n          \"wrong_value\": \"ber\"\n        }\n      }\n    ]\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/models/#helper-functions","title":"Helper Functions","text":"<p>Pydantic provides three <code>classmethod</code> helper functions on models for parsing data:</p> <ul> <li><code>parse_obj</code>: this is very similar to the <code>__init__</code> method of the model, except it takes a dict   rather than keyword arguments. If the object passed is not a dict a <code>ValidationError</code> will be raised.</li> <li><code>parse_raw</code>: this takes a str or bytes and parses it as json, then passes the result to <code>parse_obj</code>.   Parsing pickle data is also supported by setting the <code>content_type</code> argument appropriately.</li> <li><code>parse_file</code>: this takes in a file path, reads the file and passes the contents to <code>parse_raw</code>. If <code>content_type</code> is omitted,   it is inferred from the file's extension.</li> </ul> Python 3.7 and above <pre><code>import pickle\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name = 'John Doe'\n    signup_ts: datetime = None\n\n\nm = User.parse_obj({'id': 123, 'name': 'James'})\nprint(m)\n#&gt; id=123 signup_ts=None name='James'\n\ntry:\n    User.parse_obj(['not', 'a', 'dict'])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    __root__\n      User expected dict not list (type=type_error)\n    \"\"\"\n\n# assumes json as no content type passed\nm = User.parse_raw('{\"id\": 123, \"name\": \"James\"}')\nprint(m)\n#&gt; id=123 signup_ts=None name='James'\n\npickle_data = pickle.dumps({\n    'id': 123,\n    'name': 'James',\n    'signup_ts': datetime(2017, 7, 14)\n})\nm = User.parse_raw(\n    pickle_data, content_type='application/pickle', allow_pickle=True\n)\nprint(m)\n#&gt; id=123 signup_ts=datetime.datetime(2017, 7, 14, 0, 0) name='James'\n\npath = Path('data.json')\npath.write_text('{\"id\": 123, \"name\": \"James\"}')\nm = User.parse_file(path)\nprint(m)\n#&gt; id=123 signup_ts=None name='James'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Warning</p> <p>To quote the official <code>pickle</code> docs, \"The pickle module is not secure against erroneous or maliciously constructed data. Never unpickle data received from an untrusted or unauthenticated source.\" </p> <p>Info</p> <p>Because it can result in arbitrary code execution, as a security measure, you need to explicitly pass <code>allow_pickle</code> to the parsing function in order to load <code>pickle</code> data.</p>"},{"location":"usage/models/#creating-models-without-validation","title":"Creating models without validation","text":"<p>pydantic also provides the <code>construct()</code> method which allows models to be created without validation this can be useful when data has already been validated or comes from a trusted source and you want to create a model as efficiently as possible (<code>construct()</code> is generally around 30x faster than creating a model with full validation).</p> <p>Warning</p> <p><code>construct()</code> does not do any validation, meaning it can create models which are invalid. You should only ever use the <code>construct()</code> method with data which has already been validated, or you trust.</p> Python 3.7 and above <pre><code>from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: int\n    age: int\n    name: str = 'John Doe'\n\n\noriginal_user = User(id=123, age=32)\n\nuser_data = original_user.dict()\nprint(user_data)\n#&gt; {'id': 123, 'age': 32, 'name': 'John Doe'}\nfields_set = original_user.__fields_set__\nprint(fields_set)\n#&gt; {'age', 'id'}\n\n# ...\n# pass user_data and fields_set to RPC or save to the database etc.\n# ...\n\n# you can then create a new instance of User without\n# re-running validation which would be unnecessary at this point:\nnew_user = User.construct(_fields_set=fields_set, **user_data)\nprint(repr(new_user))\n#&gt; User(id=123, age=32, name='John Doe')\nprint(new_user.__fields_set__)\n#&gt; {'age', 'id'}\n\n# construct can be dangerous, only use it with validated data!:\nbad_user = User.construct(id='dog')\nprint(repr(bad_user))\n#&gt; User(id='dog', name='John Doe')\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>The <code>_fields_set</code> keyword argument to <code>construct()</code> is optional, but allows you to be more precise about  which fields were originally set and which weren't. If it's omitted <code>__fields_set__</code> will just be the keys of the data provided. </p> <p>For example, in the example above, if <code>_fields_set</code> was not provided,  <code>new_user.__fields_set__</code> would be <code>{'id', 'age', 'name'}</code>.</p>"},{"location":"usage/models/#generic-models","title":"Generic Models","text":"<p>Pydantic supports the creation of generic models to make it easier to reuse a common model structure.</p> <p>In order to declare a generic model, you perform the following steps:</p> <ul> <li>Declare one or more <code>typing.TypeVar</code> instances to use to parameterize your model.</li> <li>Declare a pydantic model that inherits from <code>pydantic.generics.GenericModel</code> and <code>typing.Generic</code>,   where you pass the <code>TypeVar</code> instances as parameters to <code>typing.Generic</code>.</li> <li>Use the <code>TypeVar</code> instances as annotations where you will want to replace them with other types or   pydantic models.</li> </ul> <p>Here is an example using <code>GenericModel</code> to create an easily-reused HTTP response payload wrapper:</p> Python 3.7 and abovePython 3.9 and abovePython 3.10 and above <pre><code>from typing import Generic, TypeVar, Optional, List\n\nfrom pydantic import BaseModel, validator, ValidationError\nfrom pydantic.generics import GenericModel\n\nDataT = TypeVar('DataT')\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass DataModel(BaseModel):\n    numbers: List[int]\n    people: List[str]\n\n\nclass Response(GenericModel, Generic[DataT]):\n    data: Optional[DataT]\n    error: Optional[Error]\n\n    @validator('error', always=True)\n    def check_consistency(cls, v, values):\n        if v is not None and values['data'] is not None:\n            raise ValueError('must not provide both data and error')\n        if v is None and values.get('data') is None:\n            raise ValueError('must provide data or error')\n        return v\n\n\ndata = DataModel(numbers=[1, 2, 3], people=[])\nerror = Error(code=404, message='Not found')\n\nprint(Response[int](data=1))\n#&gt; data=1 error=None\nprint(Response[str](data='value'))\n#&gt; data='value' error=None\nprint(Response[str](data='value').dict())\n#&gt; {'data': 'value', 'error': None}\nprint(Response[DataModel](data=data).dict())\n\"\"\"\n{\n    'data': {'numbers': [1, 2, 3], 'people': []},\n    'error': None,\n}\n\"\"\"\nprint(Response[DataModel](error=error).dict())\n\"\"\"\n{\n    'data': None,\n    'error': {'code': 404, 'message': 'Not found'},\n}\n\"\"\"\ntry:\n    Response[int](data='value')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Response[int]\n    data\n      value is not a valid integer (type=type_error.integer)\n    error\n      must provide data or error (type=value_error)\n    \"\"\"\n</code></pre> <pre><code>from typing import Generic, Optional, TypeVar\n\nfrom pydantic import BaseModel, validator, ValidationError\nfrom pydantic.generics import GenericModel\n\nDataT = TypeVar('DataT')\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass DataModel(BaseModel):\n    numbers: list[int]\n    people: list[str]\n\n\nclass Response(GenericModel, Generic[DataT]):\n    data: Optional[DataT]\n    error: Optional[Error]\n\n    @validator('error', always=True)\n    def check_consistency(cls, v, values):\n        if v is not None and values['data'] is not None:\n            raise ValueError('must not provide both data and error')\n        if v is None and values.get('data') is None:\n            raise ValueError('must provide data or error')\n        return v\n\n\ndata = DataModel(numbers=[1, 2, 3], people=[])\nerror = Error(code=404, message='Not found')\n\nprint(Response[int](data=1))\n#&gt; data=1 error=None\nprint(Response[str](data='value'))\n#&gt; data='value' error=None\nprint(Response[str](data='value').dict())\n#&gt; {'data': 'value', 'error': None}\nprint(Response[DataModel](data=data).dict())\n\"\"\"\n{\n    'data': {'numbers': [1, 2, 3], 'people': []},\n    'error': None,\n}\n\"\"\"\nprint(Response[DataModel](error=error).dict())\n\"\"\"\n{\n    'data': None,\n    'error': {'code': 404, 'message': 'Not found'},\n}\n\"\"\"\ntry:\n    Response[int](data='value')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Response[int]\n    data\n      value is not a valid integer (type=type_error.integer)\n    error\n      must provide data or error (type=value_error)\n    \"\"\"\n</code></pre> <pre><code>from typing import Generic, TypeVar\n\nfrom pydantic import BaseModel, validator, ValidationError\nfrom pydantic.generics import GenericModel\n\nDataT = TypeVar('DataT')\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass DataModel(BaseModel):\n    numbers: list[int]\n    people: list[str]\n\n\nclass Response(GenericModel, Generic[DataT]):\n    data: DataT | None\n    error: Error | None\n\n    @validator('error', always=True)\n    def check_consistency(cls, v, values):\n        if v is not None and values['data'] is not None:\n            raise ValueError('must not provide both data and error')\n        if v is None and values.get('data') is None:\n            raise ValueError('must provide data or error')\n        return v\n\n\ndata = DataModel(numbers=[1, 2, 3], people=[])\nerror = Error(code=404, message='Not found')\n\nprint(Response[int](data=1))\n#&gt; data=1 error=None\nprint(Response[str](data='value'))\n#&gt; data='value' error=None\nprint(Response[str](data='value').dict())\n#&gt; {'data': 'value', 'error': None}\nprint(Response[DataModel](data=data).dict())\n\"\"\"\n{\n    'data': {'numbers': [1, 2, 3], 'people': []},\n    'error': None,\n}\n\"\"\"\nprint(Response[DataModel](error=error).dict())\n\"\"\"\n{\n    'data': None,\n    'error': {'code': 404, 'message': 'Not found'},\n}\n\"\"\"\ntry:\n    Response[int](data='value')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Response[int]\n    data\n      value is not a valid integer (type=type_error.integer)\n    error\n      must provide data or error (type=value_error)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>If you set <code>Config</code> or make use of <code>validator</code> in your generic model definition, it is applied to concrete subclasses in the same way as when inheriting from <code>BaseModel</code>. Any methods defined on your generic class will also be inherited.</p> <p>Pydantic's generics also integrate properly with mypy, so you get all the type checking you would expect mypy to provide if you were to declare the type without using <code>GenericModel</code>.</p> <p>Note</p> <p>Internally, pydantic uses <code>create_model</code> to generate a (cached) concrete <code>BaseModel</code> at runtime, so there is essentially zero overhead introduced by making use of <code>GenericModel</code>.</p> <p>To inherit from a GenericModel without replacing the <code>TypeVar</code> instance, a class must also inherit from  <code>typing.Generic</code>:</p> Python 3.7 and above <pre><code>from typing import TypeVar, Generic\nfrom pydantic.generics import GenericModel\n\nTypeX = TypeVar('TypeX')\n\n\nclass BaseClass(GenericModel, Generic[TypeX]):\n    X: TypeX\n\n\nclass ChildClass(BaseClass[TypeX], Generic[TypeX]):\n    # Inherit from Generic[TypeX]\n    pass\n\n\n# Replace TypeX by int\nprint(ChildClass[int](X=1))\n#&gt; X=1\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>You can also create a generic subclass of a <code>GenericModel</code> that partially or fully replaces the type  parameters in the superclass.</p> Python 3.7 and above <pre><code>from typing import TypeVar, Generic\nfrom pydantic.generics import GenericModel\n\nTypeX = TypeVar('TypeX')\nTypeY = TypeVar('TypeY')\nTypeZ = TypeVar('TypeZ')\n\n\nclass BaseClass(GenericModel, Generic[TypeX, TypeY]):\n    x: TypeX\n    y: TypeY\n\n\nclass ChildClass(BaseClass[int, TypeY], Generic[TypeY, TypeZ]):\n    z: TypeZ\n\n\n# Replace TypeY by str\nprint(ChildClass[str, int](x=1, y='y', z=3))\n#&gt; x=1 y='y' z=3\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>If the name of the concrete subclasses is important, you can also override the default behavior:</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import Generic, TypeVar, Type, Any, Tuple\n\nfrom pydantic.generics import GenericModel\n\nDataT = TypeVar('DataT')\n\n\nclass Response(GenericModel, Generic[DataT]):\n    data: DataT\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...]) -&gt; str:\n        return f'{params[0].__name__.title()}Response'\n\n\nprint(repr(Response[int](data=1)))\n#&gt; IntResponse(data=1)\nprint(repr(Response[str](data='a')))\n#&gt; StrResponse(data='a')\n</code></pre> <pre><code>from typing import Any, Generic, TypeVar\n\nfrom pydantic.generics import GenericModel\n\nDataT = TypeVar('DataT')\n\n\nclass Response(GenericModel, Generic[DataT]):\n    data: DataT\n\n    @classmethod\n    def __concrete_name__(cls: type[Any], params: tuple[type[Any], ...]) -&gt; str:\n        return f'{params[0].__name__.title()}Response'\n\n\nprint(repr(Response[int](data=1)))\n#&gt; IntResponse(data=1)\nprint(repr(Response[str](data='a')))\n#&gt; StrResponse(data='a')\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Using the same TypeVar in nested models allows you to enforce typing relationships at different points in your model:</p> Python 3.7 and above <pre><code>from typing import Generic, TypeVar\n\nfrom pydantic import ValidationError\nfrom pydantic.generics import GenericModel\n\nT = TypeVar('T')\n\n\nclass InnerT(GenericModel, Generic[T]):\n    inner: T\n\n\nclass OuterT(GenericModel, Generic[T]):\n    outer: T\n    nested: InnerT[T]\n\n\nnested = InnerT[int](inner=1)\nprint(OuterT[int](outer=1, nested=nested))\n#&gt; outer=1 nested=InnerT[int](inner=1)\ntry:\n    nested = InnerT[str](inner='a')\n    print(OuterT[int](outer='a', nested=nested))\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for OuterT[int]\n    outer\n      value is not a valid integer (type=type_error.integer)\n    nested -&gt; inner\n      value is not a valid integer (type=type_error.integer)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Pydantic also treats <code>GenericModel</code> similarly to how it treats built-in generic types like <code>List</code> and <code>Dict</code> when it comes to leaving them unparameterized, or using bounded <code>TypeVar</code> instances:    </p> <ul> <li>If you don't specify parameters before instantiating the generic model, they will be treated as <code>Any</code></li> <li>You can parametrize models with one or more bounded parameters to add subclass checks</li> </ul> <p>Also, like <code>List</code> and <code>Dict</code>, any parameters specified using a <code>TypeVar</code> can later be substituted with concrete types.</p> Python 3.7 and above <pre><code>from typing import Generic, TypeVar\n\nfrom pydantic import ValidationError\nfrom pydantic.generics import GenericModel\n\nAT = TypeVar('AT')\nBT = TypeVar('BT')\n\n\nclass Model(GenericModel, Generic[AT, BT]):\n    a: AT\n    b: BT\n\n\nprint(Model(a='a', b='a'))\n#&gt; a='a' b='a'\n\nIntT = TypeVar('IntT', bound=int)\ntypevar_model = Model[int, IntT]\nprint(typevar_model(a=1, b=1))\n#&gt; a=1 b=1\ntry:\n    typevar_model(a='a', b='a')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for Model[int, IntT]\n    a\n      value is not a valid integer (type=type_error.integer)\n    b\n      value is not a valid integer (type=type_error.integer)\n    \"\"\"\n\nconcrete_model = typevar_model[int]\nprint(concrete_model(a=1, b=1))\n#&gt; a=1 b=1\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/models/#dynamic-model-creation","title":"Dynamic model creation","text":"<p>There are some occasions where the shape of a model is not known until runtime. For this pydantic provides the <code>create_model</code> method to allow models to be created on the fly.</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, create_model\n\nDynamicFoobarModel = create_model('DynamicFoobarModel', foo=(str, ...), bar=123)\n\n\nclass StaticFoobarModel(BaseModel):\n    foo: str\n    bar: int = 123\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Here <code>StaticFoobarModel</code> and <code>DynamicFoobarModel</code> are identical.</p> <p>Warning</p> <p>See the note in Required Optional Fields for the distinction between an ellipsis as a field default and annotation-only fields.  See pydantic/pydantic#1047 for more details.</p> <p>Fields are defined by either a tuple of the form <code>(&lt;type&gt;, &lt;default value&gt;)</code> or just a default value. The special key word arguments <code>__config__</code> and <code>__base__</code> can be used to customise the new model. This includes extending a base model with extra fields.</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, create_model\n\n\nclass FooModel(BaseModel):\n    foo: str\n    bar: int = 123\n\n\nBarModel = create_model(\n    'BarModel',\n    apple='russet',\n    banana='yellow',\n    __base__=FooModel,\n)\nprint(BarModel)\n#&gt; &lt;class 'pydantic.main.BarModel'&gt;\nprint(BarModel.__fields__.keys())\n#&gt; dict_keys(['foo', 'bar', 'apple', 'banana'])\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>You can also add validators by passing a dict to the <code>__validators__</code> argument.</p> Python 3.7 and above <pre><code>from pydantic import create_model, ValidationError, validator\n\n\ndef username_alphanumeric(cls, v):\n    assert v.isalnum(), 'must be alphanumeric'\n    return v\n\n\nvalidators = {\n    'username_validator':\n    validator('username')(username_alphanumeric)\n}\n\nUserModel = create_model(\n    'UserModel',\n    username=(str, ...),\n    __validators__=validators\n)\n\nuser = UserModel(username='scolvin')\nprint(user)\n#&gt; username='scolvin'\n\ntry:\n    UserModel(username='scolvi%n')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for UserModel\n    username\n      must be alphanumeric (type=assertion_error)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/models/#model-creation-from-namedtuple-or-typeddict","title":"Model creation from <code>NamedTuple</code> or <code>TypedDict</code>","text":"<p>Sometimes you already use in your application classes that inherit from <code>NamedTuple</code> or <code>TypedDict</code> and you don't want to duplicate all your information to have a <code>BaseModel</code>. For this pydantic provides <code>create_model_from_namedtuple</code> and <code>create_model_from_typeddict</code> methods. Those methods have the exact same keyword arguments as <code>create_model</code>.</p> Python 3.7 and above <pre><code>from typing_extensions import TypedDict\n\nfrom pydantic import ValidationError, create_model_from_typeddict\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nclass Config:\n    extra = 'forbid'\n\n\nUserM = create_model_from_typeddict(User, __config__=Config)\nprint(repr(UserM(name=123, id='3')))\n#&gt; User(name='123', id=3)\n\ntry:\n    UserM(name=123, id='3', other='no')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    other\n      extra fields not permitted (type=value_error.extra)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/models/#custom-root-types","title":"Custom Root Types","text":"<p>Pydantic models can be defined with a custom root type by declaring the <code>__root__</code> field. </p> <p>The root type can be any type supported by pydantic, and is specified by the type hint on the <code>__root__</code> field. The root value can be passed to the model <code>__init__</code> via the <code>__root__</code> keyword argument, or as the first and only argument to <code>parse_obj</code>.</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import List\nimport json\nfrom pydantic import BaseModel\nfrom pydantic.schema import schema\n\n\nclass Pets(BaseModel):\n    __root__: List[str]\n\n\nprint(Pets(__root__=['dog', 'cat']))\n#&gt; __root__=['dog', 'cat']\nprint(Pets(__root__=['dog', 'cat']).json())\n#&gt; [\"dog\", \"cat\"]\nprint(Pets.parse_obj(['dog', 'cat']))\n#&gt; __root__=['dog', 'cat']\nprint(Pets.schema())\n\"\"\"\n{\n    'title': 'Pets',\n    'type': 'array',\n    'items': {'type': 'string'},\n}\n\"\"\"\npets_schema = schema([Pets])\nprint(json.dumps(pets_schema, indent=2))\n\"\"\"\n{\n  \"definitions\": {\n    \"Pets\": {\n      \"title\": \"Pets\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    }\n  }\n}\n\"\"\"\n</code></pre> <pre><code>import json\nfrom pydantic import BaseModel\nfrom pydantic.schema import schema\n\n\nclass Pets(BaseModel):\n    __root__: list[str]\n\n\nprint(Pets(__root__=['dog', 'cat']))\n#&gt; __root__=['dog', 'cat']\nprint(Pets(__root__=['dog', 'cat']).json())\n#&gt; [\"dog\", \"cat\"]\nprint(Pets.parse_obj(['dog', 'cat']))\n#&gt; __root__=['dog', 'cat']\nprint(Pets.schema())\n\"\"\"\n{\n    'title': 'Pets',\n    'type': 'array',\n    'items': {'type': 'string'},\n}\n\"\"\"\npets_schema = schema([Pets])\nprint(json.dumps(pets_schema, indent=2))\n\"\"\"\n{\n  \"definitions\": {\n    \"Pets\": {\n      \"title\": \"Pets\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    }\n  }\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>If you call the <code>parse_obj</code> method for a model with a custom root type with a dict as the first argument, the following logic is used:</p> <ul> <li>If the custom root type is a mapping type (eg., <code>Dict</code> or <code>Mapping</code>),   the argument itself is always validated against the custom root type.</li> <li>For other custom root types, if the dict has precisely one key with the value <code>__root__</code>,   the corresponding value will be validated against the custom root type.</li> <li>Otherwise, the dict itself is validated against the custom root type.    </li> </ul> <p>This is demonstrated in the following example:</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import List, Dict\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Pets(BaseModel):\n    __root__: List[str]\n\n\nprint(Pets.parse_obj(['dog', 'cat']))\n#&gt; __root__=['dog', 'cat']\nprint(Pets.parse_obj({'__root__': ['dog', 'cat']}))  # not recommended\n#&gt; __root__=['dog', 'cat']\n\n\nclass PetsByName(BaseModel):\n    __root__: Dict[str, str]\n\n\nprint(PetsByName.parse_obj({'Otis': 'dog', 'Milo': 'cat'}))\n#&gt; __root__={'Otis': 'dog', 'Milo': 'cat'}\ntry:\n    PetsByName.parse_obj({'__root__': {'Otis': 'dog', 'Milo': 'cat'}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for PetsByName\n    __root__ -&gt; __root__\n      str type expected (type=type_error.str)\n    \"\"\"\n</code></pre> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Pets(BaseModel):\n    __root__: list[str]\n\n\nprint(Pets.parse_obj(['dog', 'cat']))\n#&gt; __root__=['dog', 'cat']\nprint(Pets.parse_obj({'__root__': ['dog', 'cat']}))  # not recommended\n#&gt; __root__=['dog', 'cat']\n\n\nclass PetsByName(BaseModel):\n    __root__: dict[str, str]\n\n\nprint(PetsByName.parse_obj({'Otis': 'dog', 'Milo': 'cat'}))\n#&gt; __root__={'Otis': 'dog', 'Milo': 'cat'}\ntry:\n    PetsByName.parse_obj({'__root__': {'Otis': 'dog', 'Milo': 'cat'}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for PetsByName\n    __root__ -&gt; __root__\n      str type expected (type=type_error.str)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Warning</p> <p>Calling the <code>parse_obj</code> method on a dict with the single key <code>\"__root__\"</code> for non-mapping custom root types is currently supported for backwards compatibility, but is not recommended and may be dropped in a future version.</p> <p>If you want to access items in the <code>__root__</code> field directly or to iterate over the items, you can implement custom <code>__iter__</code> and <code>__getitem__</code> functions, as shown in the following example.</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import List\nfrom pydantic import BaseModel\n\n\nclass Pets(BaseModel):\n    __root__: List[str]\n\n    def __iter__(self):\n        return iter(self.__root__)\n\n    def __getitem__(self, item):\n        return self.__root__[item]\n\n\npets = Pets.parse_obj(['dog', 'cat'])\nprint(pets[0])\n#&gt; dog\nprint([pet for pet in pets])\n#&gt; ['dog', 'cat']\n</code></pre> <pre><code>from pydantic import BaseModel\n\n\nclass Pets(BaseModel):\n    __root__: list[str]\n\n    def __iter__(self):\n        return iter(self.__root__)\n\n    def __getitem__(self, item):\n        return self.__root__[item]\n\n\npets = Pets.parse_obj(['dog', 'cat'])\nprint(pets[0])\n#&gt; dog\nprint([pet for pet in pets])\n#&gt; ['dog', 'cat']\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/models/#faux-immutability","title":"Faux Immutability","text":"<p>Models can be configured to be immutable via <code>allow_mutation = False</code>. When this is set, attempting to change the values of instance attributes will raise errors. See model config for more details on <code>Config</code>.</p> <p>Warning</p> <p>Immutability in Python is never strict. If developers are determined/stupid they can always modify a so-called \"immutable\" object.</p> Python 3.7 and above <pre><code>from pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel):\n    a: str\n    b: dict\n\n    class Config:\n        allow_mutation = False\n\n\nfoobar = FooBarModel(a='hello', b={'apple': 'pear'})\n\ntry:\n    foobar.a = 'different'\nexcept TypeError as e:\n    print(e)\n    #&gt; \"FooBarModel\" is immutable and does not support item assignment\n\nprint(foobar.a)\n#&gt; hello\nprint(foobar.b)\n#&gt; {'apple': 'pear'}\nfoobar.b['apple'] = 'grape'\nprint(foobar.b)\n#&gt; {'apple': 'grape'}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Trying to change <code>a</code> caused an error, and <code>a</code> remains unchanged. However, the dict <code>b</code> is mutable, and the immutability of <code>foobar</code> doesn't stop <code>b</code> from being changed.</p>"},{"location":"usage/models/#abstract-base-classes","title":"Abstract Base Classes","text":"<p>Pydantic models can be used alongside Python's Abstract Base Classes (ABCs).</p> Python 3.7 and above <pre><code>import abc\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel, abc.ABC):\n    a: str\n    b: int\n\n    @abc.abstractmethod\n    def my_abstract_method(self):\n        pass\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/models/#field-ordering","title":"Field Ordering","text":"<p>Field order is important in models for the following reasons:</p> <ul> <li>validation is performed in the order fields are defined; fields validators    can access the values of earlier fields, but not later ones</li> <li>field order is preserved in the model schema</li> <li>field order is preserved in validation errors</li> <li>field order is preserved by <code>.dict()</code> and <code>.json()</code> etc.</li> </ul> <p>As of v1.0 all fields with annotations (whether annotation-only or with a default value) will precede all fields without an annotation. Within their respective groups, fields remain in the order they were defined.</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b = 2\n    c: int = 1\n    d = 0\n    e: float\n\n\nprint(Model.__fields__.keys())\n#&gt; dict_keys(['a', 'c', 'e', 'b', 'd'])\nm = Model(e=2, a=1)\nprint(m.dict())\n#&gt; {'a': 1, 'c': 1, 'e': 2.0, 'b': 2, 'd': 0}\ntry:\n    Model(a='x', b='x', c='x', d='x', e='x')\nexcept ValidationError as e:\n    error_locations = [e['loc'] for e in e.errors()]\n\nprint(error_locations)\n#&gt; [('a',), ('c',), ('e',), ('b',), ('d',)]\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Warning</p> <p>As demonstrated by the example above, combining the use of annotated and non-annotated fields in the same model can result in surprising field orderings. (This is due to limitations of Python)</p> <p>Therefore, we recommend adding type annotations to all fields, even when a default value would determine the type by itself to guarantee field order is preserved.</p>"},{"location":"usage/models/#required-fields","title":"Required fields","text":"<p>To declare a field as required, you may declare it using just an annotation, or you may use an ellipsis (<code>...</code>)  as the value:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    a: int\n    b: int = ...\n    c: int = Field(...)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Where <code>Field</code> refers to the field function.</p> <p>Here <code>a</code>, <code>b</code> and <code>c</code> are all required. However, use of the ellipses in <code>b</code> will not work well with mypy, and as of v1.0 should be avoided in most cases.</p>"},{"location":"usage/models/#required-optional-fields","title":"Required Optional fields","text":"<p>Warning</p> <p>Since version v1.2 annotation only nullable (<code>Optional[...]</code>, <code>Union[None, ...]</code> and <code>Any</code>) fields and nullable fields with an ellipsis (<code>...</code>) as the default value, no longer mean the same thing.</p> <p>In some situations this may cause v1.2 to not be entirely backwards compatible with earlier v1.* releases.</p> <p>If you want to specify a field that can take a <code>None</code> value while still being required, you can use <code>Optional</code> with <code>...</code>:</p> Python 3.7 and abovePython 3.10 and above <pre><code>from typing import Optional\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    a: Optional[int]\n    b: Optional[int] = ...\n    c: Optional[int] = Field(...)\n\n\nprint(Model(b=1, c=2))\n#&gt; a=None b=1 c=2\ntry:\n    Model(a=1, b=2)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    c\n      field required (type=value_error.missing)\n    \"\"\"\n</code></pre> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    a: int | None\n    b: int | None = ...\n    c: int | None = Field(...)\n\n\nprint(Model(b=1, c=2))\n#&gt; a=None b=1 c=2\ntry:\n    Model(a=1, b=2)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    c\n      field required (type=value_error.missing)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>In this model, <code>a</code>, <code>b</code>, and <code>c</code> can take <code>None</code> as a value. But <code>a</code> is optional, while <code>b</code> and <code>c</code> are required. <code>b</code> and <code>c</code> require a value, even if the value is <code>None</code>.</p>"},{"location":"usage/models/#field-with-dynamic-default-value","title":"Field with dynamic default value","text":"<p>When declaring a field with a default value, you may want it to be dynamic (i.e. different for each model). To do this, you may want to use a <code>default_factory</code>.</p> <p>In Beta</p> <p>The <code>default_factory</code> argument is in beta, it has been added to pydantic in v1.5 on a provisional basis. It may change significantly in future releases and its signature or behaviour will not be concrete until v2. Feedback from the community while it's still provisional would be extremely useful; either comment on #866 or create a new issue.</p> <p>Example of usage:</p> Python 3.7 and above <pre><code>from datetime import datetime\nfrom uuid import UUID, uuid4\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    uid: UUID = Field(default_factory=uuid4)\n    updated: datetime = Field(default_factory=datetime.utcnow)\n\n\nm1 = Model()\nm2 = Model()\nprint(f'{m1.uid} != {m2.uid}')\n#&gt; a364dfb8-821e-4e9b-a1a1-8b9729aa20cb != 86c13e98-e29f-4628-90df-eaf8092aa9fe\nprint(f'{m1.updated} != {m2.updated}')\n#&gt; 2025-09-13 02:31:51.011133 != 2025-09-13 02:31:51.011144\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Where <code>Field</code> refers to the field function.</p> <p>Warning</p> <p>The <code>default_factory</code> expects the field type to be set.</p>"},{"location":"usage/models/#automatically-excluded-attributes","title":"Automatically excluded attributes","text":"<p>Class variables which begin with an underscore and attributes annotated with <code>typing.ClassVar</code> will be automatically excluded from the model.</p>"},{"location":"usage/models/#private-model-attributes","title":"Private model attributes","text":"<p>If you need to vary or manipulate internal attributes on instances of the model, you can declare them using <code>PrivateAttr</code>:</p> Python 3.7 and above <pre><code>from datetime import datetime\nfrom random import randint\n\nfrom pydantic import BaseModel, PrivateAttr\n\n\nclass TimeAwareModel(BaseModel):\n    _processed_at: datetime = PrivateAttr(default_factory=datetime.now)\n    _secret_value: str = PrivateAttr()\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        # this could also be done with default_factory\n        self._secret_value = randint(1, 5)\n\n\nm = TimeAwareModel()\nprint(m._processed_at)\n#&gt; 2025-09-13 02:31:51.530077\nprint(m._secret_value)\n#&gt; 5\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Private attribute names must start with underscore to prevent conflicts with model fields: both <code>_attr</code> and <code>__attr__</code>  are supported.</p> <p>If <code>Config.underscore_attrs_are_private</code> is <code>True</code>, any non-ClassVar underscore attribute will be treated as private:</p> Python 3.7 and above <pre><code>from typing import ClassVar\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    _class_var: ClassVar[str] = 'class var value'\n    _private_attr: str = 'private attr value'\n\n    class Config:\n        underscore_attrs_are_private = True\n\n\nprint(Model._class_var)\n#&gt; class var value\nprint(Model._private_attr)\n#&gt; &lt;member '_private_attr' of 'Model' objects&gt;\nprint(Model()._private_attr)\n#&gt; private attr value\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Upon class creation pydantic constructs <code>__slots__</code> filled with private attributes.</p>"},{"location":"usage/models/#parsing-data-into-a-specified-type","title":"Parsing data into a specified type","text":"<p>Pydantic includes a standalone utility function <code>parse_obj_as</code> that can be used to apply the parsing logic used to populate pydantic models in a more ad-hoc way. This function behaves similarly to <code>BaseModel.parse_obj</code>, but works with arbitrary pydantic-compatible types.</p> <p>This is especially useful when you want to parse results into a type that is not a direct subclass of <code>BaseModel</code>. For example: </p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import List\n\nfrom pydantic import BaseModel, parse_obj_as\n\n\nclass Item(BaseModel):\n    id: int\n    name: str\n\n\n# `item_data` could come from an API call, eg., via something like:\n# item_data = requests.get('https://my-api.com/items').json()\nitem_data = [{'id': 1, 'name': 'My Item'}]\n\nitems = parse_obj_as(List[Item], item_data)\nprint(items)\n#&gt; [Item(id=1, name='My Item')]\n</code></pre> <pre><code>from pydantic import BaseModel, parse_obj_as\n\n\nclass Item(BaseModel):\n    id: int\n    name: str\n\n\n# `item_data` could come from an API call, eg., via something like:\n# item_data = requests.get('https://my-api.com/items').json()\nitem_data = [{'id': 1, 'name': 'My Item'}]\n\nitems = parse_obj_as(list[Item], item_data)\nprint(items)\n#&gt; [Item(id=1, name='My Item')]\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>This function is capable of parsing data into any of the types pydantic can handle as fields of a <code>BaseModel</code>.</p> <p>Pydantic also includes two similar standalone functions called <code>parse_file_as</code> and <code>parse_raw_as</code>, which are analogous to <code>BaseModel.parse_file</code> and <code>BaseModel.parse_raw</code>.</p>"},{"location":"usage/models/#data-conversion","title":"Data Conversion","text":"<p>pydantic may cast input data to force it to conform to model field types, and in some cases this may result in a loss of information. For example:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n    b: float\n    c: str\n\n\nprint(Model(a=3.1415, b=' 2.72 ', c=123).dict())\n#&gt; {'a': 3, 'b': 2.72, 'c': '123'}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>This is a deliberate decision of pydantic, and in general it's the most useful approach. See  here for a longer discussion on the subject.</p> <p>Nevertheless, strict type checking is partially supported.</p>"},{"location":"usage/models/#model-signature","title":"Model signature","text":"<p>All pydantic models will have their signature generated based on their fields:</p> Python 3.7 and above <pre><code>import inspect\nfrom pydantic import BaseModel, Field\n\n\nclass FooModel(BaseModel):\n    id: int\n    name: str = None\n    description: str = 'Foo'\n    apple: int = Field(..., alias='pear')\n\n\nprint(inspect.signature(FooModel))\n#&gt; (*, id: int, name: str = None, description: str = 'Foo', pear: int) -&gt; None\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>An accurate signature is useful for introspection purposes and libraries like <code>FastAPI</code> or <code>hypothesis</code>.</p> <p>The generated signature will also respect custom <code>__init__</code> functions:</p> Python 3.7 and above <pre><code>import inspect\n\nfrom pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    id: int\n    info: str = 'Foo'\n\n    def __init__(self, id: int = 1, *, bar: str, **data) -&gt; None:\n        \"\"\"My custom init!\"\"\"\n        super().__init__(id=id, bar=bar, **data)\n\n\nprint(inspect.signature(MyModel))\n#&gt; (id: int = 1, *, bar: str, info: str = 'Foo') -&gt; None\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>To be included in the signature, a field's alias or name must be a valid Python identifier.  pydantic prefers aliases over names, but may use field names if the alias is not a valid Python identifier. </p> <p>If a field's alias and name are both invalid identifiers, a <code>**data</code> argument will be added. In addition, the <code>**data</code> argument will always be present in the signature if <code>Config.extra</code> is <code>Extra.allow</code>.</p> <p>Note</p> <p>Types in the model signature are the same as declared in model annotations,  not necessarily all the types that can actually be provided to that field. This may be fixed one day once #1055 is solved.</p>"},{"location":"usage/models/#structural-pattern-matching","title":"Structural pattern matching","text":"<p>pydantic supports structural pattern matching for models, as introduced by PEP 636 in Python 3.10.</p> Python 3.10 and above <pre><code>from pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    species: str\n\n\na = Pet(name='Bones', species='dog')\n\nmatch a:\n    # match `species` to 'dog', declare and initialize `dog_name`\n    case Pet(species='dog', name=dog_name):\n        print(f'{dog_name} is a dog')\n        #&gt; Bones is a dog\n    # default case\n    case _:\n        print('No dog matched')\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>A match-case statement may seem as if it creates a new model, but don't be fooled; it is just syntactic sugar for getting an attribute and either comparing it or declaring and initializing it.</p>"},{"location":"usage/mypy/","title":"Usage with mypy","text":"<p>pydantic models work with mypy provided you use the annotation-only version of required fields:</p> Python 3.7 and abovePython 3.9 and abovePython 3.10 and above <pre><code>from datetime import datetime\nfrom typing import List, Optional\nfrom pydantic import BaseModel, NoneStr\n\n\nclass Model(BaseModel):\n    age: int\n    first_name = 'John'\n    last_name: NoneStr = None\n    signup_ts: Optional[datetime] = None\n    list_of_ints: List[int]\n\n\nm = Model(age=42, list_of_ints=[1, '2', b'3'])\nprint(m.middle_name)  # not a model field!\nModel()  # will raise a validation error for age and list_of_ints\n</code></pre> <pre><code>from datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, NoneStr\n\n\nclass Model(BaseModel):\n    age: int\n    first_name = 'John'\n    last_name: NoneStr = None\n    signup_ts: Optional[datetime] = None\n    list_of_ints: list[int]\n\n\nm = Model(age=42, list_of_ints=[1, '2', b'3'])\nprint(m.middle_name)  # not a model field!\nModel()  # will raise a validation error for age and list_of_ints\n</code></pre> <pre><code>from datetime import datetime\nfrom pydantic import BaseModel, NoneStr\n\n\nclass Model(BaseModel):\n    age: int\n    first_name = 'John'\n    last_name: NoneStr = None\n    signup_ts: datetime | None = None\n    list_of_ints: list[int]\n\n\nm = Model(age=42, list_of_ints=[1, '2', b'3'])\nprint(m.middle_name)  # not a model field!\nModel()  # will raise a validation error for age and list_of_ints\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>You can run your code through mypy with:</p> <pre><code>mypy \\\n  --ignore-missing-imports \\\n  --follow-imports=skip \\\n  --strict-optional \\\n  pydantic_mypy_test.py\n</code></pre> <p>If you call mypy on the example code above, you should see mypy detect the attribute access error: <pre><code>13: error: \"Model\" has no attribute \"middle_name\"\n</code></pre></p>"},{"location":"usage/mypy/#strict-optional","title":"Strict Optional","text":"<p>For your code to pass with <code>--strict-optional</code>, you need to to use <code>Optional[]</code> or an alias of <code>Optional[]</code> for all fields with <code>None</code> as the default. (This is standard with mypy.)</p> <p>Pydantic provides a few useful optional or union types:</p> <ul> <li><code>NoneStr</code> aka. <code>Optional[str]</code></li> <li><code>NoneBytes</code> aka. <code>Optional[bytes]</code></li> <li><code>StrBytes</code> aka. <code>Union[str, bytes]</code></li> <li><code>NoneStrBytes</code> aka. <code>Optional[StrBytes]</code></li> </ul> <p>If these aren't sufficient you can of course define your own.</p>"},{"location":"usage/mypy/#mypy-plugin","title":"Mypy Plugin","text":"<p>Pydantic ships with a mypy plugin that adds a number of important pydantic-specific features to mypy that improve its ability to type-check your code.</p> <p>See the pydantic mypy plugin docs for more details.</p>"},{"location":"usage/mypy/#other-pydantic-interfaces","title":"Other pydantic interfaces","text":"<p>Pydantic dataclasses and the <code>validate_arguments</code> decorator should also work well with mypy.</p>"},{"location":"usage/postponed_annotations/","title":"Postponed annotations","text":"<p>Note</p> <p>Both postponed annotations via the future import and <code>ForwardRef</code> require Python 3.7+.</p> <p>Postponed annotations (as described in PEP563) \"just work\".</p> Python 3.7 and abovePython 3.9 and above <pre><code>from __future__ import annotations\nfrom typing import Any, List\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: List[int]\n    b: Any\n\n\nprint(Model(a=('1', 2, 3), b='ok'))\n#&gt; a=[1, 2, 3] b='ok'\n</code></pre> <pre><code>from __future__ import annotations\nfrom typing import Any\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: list[int]\n    b: Any\n\n\nprint(Model(a=('1', 2, 3), b='ok'))\n#&gt; a=[1, 2, 3] b='ok'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Internally, pydantic  will call a method similar to <code>typing.get_type_hints</code> to resolve annotations.</p> <p>In cases where the referenced type is not yet defined, <code>ForwardRef</code> can be used (although referencing the type directly or by its string is a simpler solution in the case of self-referencing models).</p> <p>In some cases, a <code>ForwardRef</code> won't be able to be resolved during model creation. For example, this happens whenever a model references itself as a field type. When this happens, you'll need to call <code>update_forward_refs</code> after the model has been created before it can be used:</p> Python 3.7 and above <pre><code>from typing import ForwardRef\nfrom pydantic import BaseModel\n\nFoo = ForwardRef('Foo')\n\n\nclass Foo(BaseModel):\n    a: int = 123\n    b: Foo = None\n\n\nFoo.update_forward_refs()\n\nprint(Foo())\n#&gt; a=123 b=None\nprint(Foo(b={'a': '321'}))\n#&gt; a=123 b=Foo(a=321, b=None)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Warning</p> <p>To resolve strings (type names) into annotations (types), pydantic needs a namespace dict in which to perform the lookup. For this it uses <code>module.__dict__</code>, just like <code>get_type_hints</code>. This means pydantic may not play well with types not defined in the global scope of a module.</p> <p>For example, this works fine:</p> Python 3.7 and above <pre><code>from __future__ import annotations\nfrom pydantic import BaseModel\nfrom pydantic import HttpUrl  # HttpUrl is defined in the module's global scope\n\n\ndef this_works():\n    class Model(BaseModel):\n        a: HttpUrl\n\n    print(Model(a='https://example.com'))\n    #&gt; a=HttpUrl('https://example.com', )\n\n\nthis_works()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>While this will break:</p> Python 3.7 and above <pre><code>from __future__ import annotations\nfrom pydantic import BaseModel\nfrom pydantic.errors import ConfigError\n\n\ndef this_is_broken():\n    from pydantic import HttpUrl  # HttpUrl is defined in function local scope\n\n    class Model(BaseModel):\n        a: HttpUrl\n\n    try:\n        Model(a='https://example.com')\n    except ConfigError as e:\n        print(e)\n        #&gt; field \"a\" not yet prepared so type is still a ForwardRef, you might\n        #&gt; need to call Model.update_forward_refs().\n\n    try:\n        Model.update_forward_refs()\n    except NameError as e:\n        print(e)\n        #&gt; name 'HttpUrl' is not defined\n\n\nthis_is_broken()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Resolving this is beyond the call for pydantic: either remove the future import or declare the types globally.</p>"},{"location":"usage/postponed_annotations/#self-referencing-models","title":"Self-referencing Models","text":"<p>Data structures with self-referencing models are also supported. Self-referencing fields will be automatically resolved after model creation.</p> <p>Within the model, you can refer to the not-yet-constructed model using a string:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: int = 123\n    #: The sibling of `Foo` is referenced by string\n    sibling: 'Foo' = None\n\n\nprint(Foo())\n#&gt; a=123 sibling=None\nprint(Foo(sibling={'a': '321'}))\n#&gt; a=123 sibling=Foo(a=321, sibling=None)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Since Python 3.7, you can also refer it by its type, provided you import <code>annotations</code> (see above for support depending on Python and pydantic versions).</p> Python 3.7 and above <pre><code>from __future__ import annotations\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: int = 123\n    #: The sibling of `Foo` is referenced directly by type\n    sibling: Foo = None\n\n\nprint(Foo())\n#&gt; a=123 sibling=None\nprint(Foo(sibling={'a': '321'}))\n#&gt; a=123 sibling=Foo(a=321, sibling=None)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/rich/","title":"Usage with rich","text":"<p>Pydantic models may be printed with the Rich library which will add additional formatting and color to the output. Here's an example:</p> <p></p> <p>See the Rich documentation on pretty printing for more information.</p>"},{"location":"usage/schema/","title":"Schema","text":"<p>Pydantic allows auto creation of JSON Schemas from models:</p> Python 3.7 and above <pre><code>from enum import Enum\nfrom pydantic import BaseModel, Field\n\n\nclass FooBar(BaseModel):\n    count: int\n    size: float = None\n\n\nclass Gender(str, Enum):\n    male = 'male'\n    female = 'female'\n    other = 'other'\n    not_given = 'not_given'\n\n\nclass MainModel(BaseModel):\n    \"\"\"\n    This is the description of the main model\n    \"\"\"\n\n    foo_bar: FooBar = Field(...)\n    gender: Gender = Field(None, alias='Gender')\n    snap: int = Field(\n        42,\n        title='The Snap',\n        description='this is the value of snap',\n        gt=30,\n        lt=50,\n    )\n\n    class Config:\n        title = 'Main'\n\n\n# this is equivalent to json.dumps(MainModel.schema(), indent=2):\nprint(MainModel.schema_json(indent=2))\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Outputs: <pre><code>{\n  \"title\": \"Main\",\n  \"description\": \"This is the description of the main model\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"foo_bar\": {\n      \"$ref\": \"#/definitions/FooBar\"\n    },\n    \"Gender\": {\n      \"$ref\": \"#/definitions/Gender\"\n    },\n    \"snap\": {\n      \"title\": \"The Snap\",\n      \"description\": \"this is the value of snap\",\n      \"default\": 42,\n      \"exclusiveMinimum\": 30,\n      \"exclusiveMaximum\": 50,\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"foo_bar\"\n  ],\n  \"definitions\": {\n    \"FooBar\": {\n      \"title\": \"FooBar\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"count\": {\n          \"title\": \"Count\",\n          \"type\": \"integer\"\n        },\n        \"size\": {\n          \"title\": \"Size\",\n          \"type\": \"number\"\n        }\n      },\n      \"required\": [\n        \"count\"\n      ]\n    },\n    \"Gender\": {\n      \"title\": \"Gender\",\n      \"description\": \"An enumeration.\",\n      \"enum\": [\n        \"male\",\n        \"female\",\n        \"other\",\n        \"not_given\"\n      ],\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre></p> <p>The generated schemas are compliant with the specifications: JSON Schema Core, JSON Schema Validation and OpenAPI.</p> <p><code>BaseModel.schema</code> will return a dict of the schema, while <code>BaseModel.schema_json</code> will return a JSON string representation of that dict.</p> <p>Sub-models used are added to the <code>definitions</code> JSON attribute and referenced, as per the spec.</p> <p>All sub-models' (and their sub-models') schemas are put directly in a top-level <code>definitions</code> JSON key for easy re-use and reference.</p> <p>\"Sub-models\" with modifications (via the <code>Field</code> class) like a custom title, description or default value, are recursively included instead of referenced.</p> <p>The <code>description</code> for models is taken from either the docstring of the class or the argument <code>description</code> to the <code>Field</code> class.</p> <p>The schema is generated by default using aliases as keys, but it can be generated using model property names instead by calling <code>MainModel.schema/schema_json(by_alias=False)</code>.</p> <p>The format of <code>$ref</code>s (<code>\"#/definitions/FooBar\"</code> above) can be altered by calling <code>schema()</code> or <code>schema_json()</code> with the <code>ref_template</code> keyword argument, e.g. <code>ApplePie.schema(ref_template='/schemas/{model}.json#/')</code>, here <code>{model}</code> will be replaced with the model naming using <code>str.format()</code>.</p>"},{"location":"usage/schema/#getting-schema-of-a-specified-type","title":"Getting schema of a specified type","text":"<p>Pydantic includes two standalone utility functions <code>schema_of</code> and <code>schema_json_of</code> that can be used to apply the schema generation logic used for pydantic models in a more ad-hoc way. These functions behave similarly to <code>BaseModel.schema</code> and <code>BaseModel.schema_json</code>, but work with arbitrary pydantic-compatible types.</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import Literal, Union\n\nfrom typing_extensions import Annotated\n\nfrom pydantic import BaseModel, Field, schema_json_of\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    cat_name: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    dog_name: str\n\n\nPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\nprint(schema_json_of(Pet, title='The Pet Schema', indent=2))\n\"\"\"\n{\n  \"title\": \"The Pet Schema\",\n  \"discriminator\": {\n    \"propertyName\": \"pet_type\",\n    \"mapping\": {\n      \"cat\": \"#/definitions/Cat\",\n      \"dog\": \"#/definitions/Dog\"\n    }\n  },\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/Cat\"\n    },\n    {\n      \"$ref\": \"#/definitions/Dog\"\n    }\n  ],\n  \"definitions\": {\n    \"Cat\": {\n      \"title\": \"Cat\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"pet_type\": {\n          \"title\": \"Pet Type\",\n          \"enum\": [\n            \"cat\"\n          ],\n          \"type\": \"string\"\n        },\n        \"cat_name\": {\n          \"title\": \"Cat Name\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"pet_type\",\n        \"cat_name\"\n      ]\n    },\n    \"Dog\": {\n      \"title\": \"Dog\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"pet_type\": {\n          \"title\": \"Pet Type\",\n          \"enum\": [\n            \"dog\"\n          ],\n          \"type\": \"string\"\n        },\n        \"dog_name\": {\n          \"title\": \"Dog Name\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"pet_type\",\n        \"dog_name\"\n      ]\n    }\n  }\n}\n\"\"\"\n</code></pre> <pre><code>from typing import Literal, Union\n\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, schema_json_of\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    cat_name: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    dog_name: str\n\n\nPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\nprint(schema_json_of(Pet, title='The Pet Schema', indent=2))\n\"\"\"\n{\n  \"title\": \"The Pet Schema\",\n  \"discriminator\": {\n    \"propertyName\": \"pet_type\",\n    \"mapping\": {\n      \"cat\": \"#/definitions/Cat\",\n      \"dog\": \"#/definitions/Dog\"\n    }\n  },\n  \"oneOf\": [\n    {\n      \"$ref\": \"#/definitions/Cat\"\n    },\n    {\n      \"$ref\": \"#/definitions/Dog\"\n    }\n  ],\n  \"definitions\": {\n    \"Cat\": {\n      \"title\": \"Cat\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"pet_type\": {\n          \"title\": \"Pet Type\",\n          \"enum\": [\n            \"cat\"\n          ],\n          \"type\": \"string\"\n        },\n        \"cat_name\": {\n          \"title\": \"Cat Name\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"pet_type\",\n        \"cat_name\"\n      ]\n    },\n    \"Dog\": {\n      \"title\": \"Dog\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"pet_type\": {\n          \"title\": \"Pet Type\",\n          \"enum\": [\n            \"dog\"\n          ],\n          \"type\": \"string\"\n        },\n        \"dog_name\": {\n          \"title\": \"Dog Name\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"pet_type\",\n        \"dog_name\"\n      ]\n    }\n  }\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/schema/#field-customization","title":"Field customization","text":"<p>Optionally, the <code>Field</code> function can be used to provide extra information about the field and validations. It has the following arguments:</p> <ul> <li><code>default</code>: (a positional argument) the default value of the field.     Since the <code>Field</code> replaces the field's default, this first argument can be used to set the default.     Use ellipsis (<code>...</code>) to indicate the field is required.</li> <li><code>default_factory</code>: a zero-argument callable that will be called when a default value is needed for this field.     Among other purposes, this can be used to set dynamic default values.     It is forbidden to set both <code>default</code> and <code>default_factory</code>.</li> <li><code>alias</code>: the public name of the field</li> <li><code>title</code>: if omitted, <code>field_name.title()</code> is used</li> <li><code>description</code>: if omitted and the annotation is a sub-model,     the docstring of the sub-model will be used</li> <li><code>exclude</code>: exclude this field when dumping (<code>.dict</code> and <code>.json</code>) the instance. The exact syntax and configuration options are described in details in the exporting models section.</li> <li><code>include</code>: include (only) this field when dumping (<code>.dict</code> and <code>.json</code>) the instance. The exact syntax and configuration options are described in details in the exporting models section.</li> <li><code>const</code>: this argument must be the same as the field's default value if present.</li> <li><code>gt</code>: for numeric values (<code>int</code>, <code>float</code>, <code>Decimal</code>), adds a validation of \"greater than\" and an annotation   of <code>exclusiveMinimum</code> to the JSON Schema</li> <li><code>ge</code>: for numeric values, this adds a validation of \"greater than or equal\" and an annotation of <code>minimum</code> to the   JSON Schema</li> <li><code>lt</code>: for numeric values, this adds a validation of \"less than\" and an annotation of <code>exclusiveMaximum</code> to the   JSON Schema</li> <li><code>le</code>: for numeric values, this adds a validation of \"less than or equal\" and an annotation of <code>maximum</code> to the   JSON Schema</li> <li><code>multiple_of</code>: for numeric values, this adds a validation of \"a multiple of\" and an annotation of <code>multipleOf</code> to the   JSON Schema</li> <li><code>max_digits</code>: for <code>Decimal</code> values, this adds a validation to have a maximum number of digits within the decimal. It   does not include a zero before the decimal point or trailing decimal zeroes.</li> <li><code>decimal_places</code>: for <code>Decimal</code> values, this adds a validation to have at most a number of decimal places allowed. It   does not include trailing decimal zeroes.</li> <li><code>min_items</code>: for list values, this adds a corresponding validation and an annotation of <code>minItems</code> to the   JSON Schema</li> <li><code>max_items</code>: for list values, this adds a corresponding validation and an annotation of <code>maxItems</code> to the   JSON Schema</li> <li><code>unique_items</code>: for list values, this adds a corresponding validation and an annotation of <code>uniqueItems</code> to the   JSON Schema</li> <li><code>min_length</code>: for string values, this adds a corresponding validation and an annotation of <code>minLength</code> to the   JSON Schema</li> <li><code>max_length</code>: for string values, this adds a corresponding validation and an annotation of <code>maxLength</code> to the   JSON Schema</li> <li><code>allow_mutation</code>: a boolean which defaults to <code>True</code>. When False, the field raises a <code>TypeError</code> if the field is   assigned on an instance.  The model config must set <code>validate_assignment</code> to <code>True</code> for this check to be performed.</li> <li> <p><code>regex</code>: for string values, this adds a Regular Expression validation generated from the passed string and an   annotation of <code>pattern</code> to the JSON Schema</p> <p>Note</p> <p>pydantic validates strings using <code>re.match</code>, which treats regular expressions as implicitly anchored at the beginning. On the contrary, JSON Schema validators treat the <code>pattern</code> keyword as implicitly unanchored, more like what <code>re.search</code> does.</p> <p>For interoperability, depending on your desired behavior, either explicitly anchor your regular expressions with <code>^</code> (e.g. <code>^foo</code> to match any string starting with <code>foo</code>), or explicitly allow an arbitrary prefix with <code>.*?</code> (e.g. <code>.*?foo</code> to match any string containing the substring <code>foo</code>).</p> <p>See #1631 for a discussion of possible changes to pydantic behavior in v2.</p> </li> </ul> <ul> <li><code>repr</code>: a boolean which defaults to <code>True</code>. When False, the field shall be hidden from the object representation.</li> <li><code>**</code> any other keyword arguments (e.g. <code>examples</code>) will be added verbatim to the field's schema</li> </ul> <p>Instead of using <code>Field</code>, the <code>fields</code> property of the Config class can be used to set all of the arguments above except <code>default</code>.</p>"},{"location":"usage/schema/#unenforced-field-constraints","title":"Unenforced Field constraints","text":"<p>If pydantic finds constraints which are not being enforced, an error will be raised. If you want to force the constraint to appear in the schema, even though it's not being checked upon parsing, you can use variadic arguments to <code>Field()</code> with the raw schema attribute name:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, Field, PositiveInt\n\ntry:\n    # this won't work since PositiveInt takes precedence over the\n    # constraints defined in Field meaning they're ignored\n    class Model(BaseModel):\n        foo: PositiveInt = Field(..., lt=10)\nexcept ValueError as e:\n    print(e)\n    \"\"\"\n    On field \"foo\" the following field constraints are set but not enforced:\n    lt.\n    For more details see https://docs.pydantic.dev/usage/schema/#unenforced-\n    field-constraints\n    \"\"\"\n\n\n# but you can set the schema attribute directly:\n# (Note: here exclusiveMaximum will not be enforce)\nclass Model(BaseModel):\n    foo: PositiveInt = Field(..., exclusiveMaximum=10)\n\n\nprint(Model.schema())\n\"\"\"\n{\n    'title': 'Model',\n    'type': 'object',\n    'properties': {\n        'foo': {\n            'title': 'Foo',\n            'exclusiveMaximum': 10,\n            'exclusiveMinimum': 0,\n            'type': 'integer',\n        },\n    },\n    'required': ['foo'],\n}\n\"\"\"\n\n\n# if you find yourself needing this, an alternative is to declare\n# the constraints in Field (or you could use conint())\n# here both constraints will be enforced:\nclass Model(BaseModel):\n    # Here both constraints will be applied and the schema\n    # will be generated correctly\n    foo: int = Field(..., gt=0, lt=10)\n\n\nprint(Model.schema())\n\"\"\"\n{\n    'title': 'Model',\n    'type': 'object',\n    'properties': {\n        'foo': {\n            'title': 'Foo',\n            'exclusiveMinimum': 0,\n            'exclusiveMaximum': 10,\n            'type': 'integer',\n        },\n    },\n    'required': ['foo'],\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/schema/#typingannotated-fields","title":"typing.Annotated Fields","text":"<p>Rather than assigning a <code>Field</code> value, it can be specified in the type hint with <code>typing.Annotated</code>:</p> Python 3.7 and abovePython 3.9 and above <pre><code>from uuid import uuid4\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import Annotated\n\n\nclass Foo(BaseModel):\n    id: Annotated[str, Field(default_factory=lambda: uuid4().hex)]\n    name: Annotated[str, Field(max_length=256)] = 'Bar'\n</code></pre> <pre><code>from uuid import uuid4\n\nfrom pydantic import BaseModel, Field\nfrom typing import Annotated\n\n\nclass Foo(BaseModel):\n    id: Annotated[str, Field(default_factory=lambda: uuid4().hex)]\n    name: Annotated[str, Field(max_length=256)] = 'Bar'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p><code>Field</code> can only be supplied once per field - an error will be raised if used in <code>Annotated</code> and as the assigned value. Defaults can be set outside <code>Annotated</code> as the assigned value or with <code>Field.default_factory</code> inside <code>Annotated</code> - the <code>Field.default</code> argument is not supported inside <code>Annotated</code>.</p> <p>For versions of Python prior to 3.9, <code>typing_extensions.Annotated</code> can be used.</p>"},{"location":"usage/schema/#modifying-schema-in-custom-fields","title":"Modifying schema in custom fields","text":"<p>Custom field types can customise the schema generated for them using the <code>__modify_schema__</code> class method; see Custom Data Types for more details.</p> <p><code>__modify_schema__</code> can also take a <code>field</code> argument which will have type <code>Optional[ModelField]</code>. pydantic will inspect the signature of <code>__modify_schema__</code> to determine whether the <code>field</code> argument should be included.</p> Python 3.7 and abovePython 3.9 and abovePython 3.10 and above <pre><code>from typing import Any, Callable, Dict, Generator, Optional\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.fields import ModelField\n\n\nclass RestrictedAlphabetStr(str):\n    @classmethod\n    def __get_validators__(cls) -&gt; Generator[Callable, None, None]:\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value: str, field: ModelField):\n        alphabet = field.field_info.extra['alphabet']\n        if any(c not in alphabet for c in value):\n            raise ValueError(f'{value!r} is not restricted to {alphabet!r}')\n        return cls(value)\n\n    @classmethod\n    def __modify_schema__(\n        cls, field_schema: Dict[str, Any], field: Optional[ModelField]\n    ):\n        if field:\n            alphabet = field.field_info.extra['alphabet']\n            field_schema['examples'] = [c * 3 for c in alphabet]\n\n\nclass MyModel(BaseModel):\n    value: RestrictedAlphabetStr = Field(alphabet='ABC')\n\n\nprint(MyModel.schema_json(indent=2))\n</code></pre> <pre><code>from typing import Any, Callable, Optional\nfrom collections.abc import Generator\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.fields import ModelField\n\n\nclass RestrictedAlphabetStr(str):\n    @classmethod\n    def __get_validators__(cls) -&gt; Generator[Callable, None, None]:\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value: str, field: ModelField):\n        alphabet = field.field_info.extra['alphabet']\n        if any(c not in alphabet for c in value):\n            raise ValueError(f'{value!r} is not restricted to {alphabet!r}')\n        return cls(value)\n\n    @classmethod\n    def __modify_schema__(\n        cls, field_schema: dict[str, Any], field: Optional[ModelField]\n    ):\n        if field:\n            alphabet = field.field_info.extra['alphabet']\n            field_schema['examples'] = [c * 3 for c in alphabet]\n\n\nclass MyModel(BaseModel):\n    value: RestrictedAlphabetStr = Field(alphabet='ABC')\n\n\nprint(MyModel.schema_json(indent=2))\n</code></pre> <pre><code>from typing import Any\nfrom collections.abc import Callable, Generator\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.fields import ModelField\n\n\nclass RestrictedAlphabetStr(str):\n    @classmethod\n    def __get_validators__(cls) -&gt; Generator[Callable, None, None]:\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value: str, field: ModelField):\n        alphabet = field.field_info.extra['alphabet']\n        if any(c not in alphabet for c in value):\n            raise ValueError(f'{value!r} is not restricted to {alphabet!r}')\n        return cls(value)\n\n    @classmethod\n    def __modify_schema__(\n        cls, field_schema: dict[str, Any], field: ModelField | None\n    ):\n        if field:\n            alphabet = field.field_info.extra['alphabet']\n            field_schema['examples'] = [c * 3 for c in alphabet]\n\n\nclass MyModel(BaseModel):\n    value: RestrictedAlphabetStr = Field(alphabet='ABC')\n\n\nprint(MyModel.schema_json(indent=2))\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Outputs: <pre><code>{\n  \"title\": \"MyModel\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"value\": {\n      \"title\": \"Value\",\n      \"alphabet\": \"ABC\",\n      \"examples\": [\n        \"AAA\",\n        \"BBB\",\n        \"CCC\"\n      ],\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"value\"\n  ]\n}\n</code></pre></p>"},{"location":"usage/schema/#json-schema-types","title":"JSON Schema Types","text":"<p>Types, custom field types, and constraints (like <code>max_length</code>) are mapped to the corresponding spec formats in the following priority order (when there is an equivalent available):</p> <ol> <li>JSON Schema Core</li> <li>JSON Schema Validation</li> <li>OpenAPI Data Types</li> <li>The standard <code>format</code> JSON field is used to define pydantic extensions for more complex <code>string</code> sub-types.</li> </ol> <p>The field schema mapping from Python / pydantic to JSON Schema is done as follows:</p> Python type JSON Schema Type Additional JSON Schema Defined in <code>None</code> <code>null</code>      JSON Schema Core    Same for <code>type(None)</code> or <code>Literal[None]</code> <code>bool</code> <code>boolean</code>      JSON Schema Core    <code>str</code> <code>string</code>      JSON Schema Core    <code>float</code> <code>number</code>      JSON Schema Core    <code>int</code> <code>integer</code>      JSON Schema Validation    <code>dict</code> <code>object</code>      JSON Schema Core    <code>list</code> <code>array</code> <code>{\"items\": {}}</code>      JSON Schema Core    <code>tuple</code> <code>array</code> <code>{\"items\": {}}</code>      JSON Schema Core    <code>set</code> <code>array</code> <code>{\"items\": {}, \"uniqueItems\": true}</code>      JSON Schema Validation    <code>frozenset</code> <code>array</code> <code>{\"items\": {}, \"uniqueItems\": true}</code>      JSON Schema Validation    <code>List[str]</code> <code>array</code> <code>{\"items\": {\"type\": \"string\"}}</code>      JSON Schema Validation    And equivalently for any other sub type, e.g. <code>List[int]</code>. <code>Tuple[str, ...]</code> <code>array</code> <code>{\"items\": {\"type\": \"string\"}}</code>      JSON Schema Validation    And equivalently for any other sub type, e.g. <code>Tuple[int, ...]</code>. <code>Tuple[str, int]</code> <code>array</code> <code>{\"items\": [{\"type\": \"string\"}, {\"type\": \"integer\"}], \"minItems\": 2, \"maxItems\": 2}</code>      JSON Schema Validation    And equivalently for any other set of subtypes. Note: If using schemas for OpenAPI, you shouldn't use this declaration, as it would not be valid in OpenAPI (although it is valid in JSON Schema). <code>Dict[str, int]</code> <code>object</code> <code>{\"additionalProperties\": {\"type\": \"integer\"}}</code>      JSON Schema Validation    And equivalently for any other subfields for dicts. Have in mind that although you can use other types as keys for dicts with Pydantic, only strings are valid keys for JSON, and so, only str is valid as JSON Schema key types. <code>Union[str, int]</code> <code>anyOf</code> <code>{\"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]}</code>      JSON Schema Validation    And equivalently for any other subfields for unions. <code>Enum</code> <code>enum</code> <code>{\"enum\": [...]}</code>      JSON Schema Validation    All the literal values in the enum are included in the definition. <code>SecretStr</code> <code>string</code> <code>{\"writeOnly\": true}</code>      JSON Schema Validation    <code>SecretBytes</code> <code>string</code> <code>{\"writeOnly\": true}</code>      JSON Schema Validation    <code>EmailStr</code> <code>string</code> <code>{\"format\": \"email\"}</code>      JSON Schema Validation    <code>NameEmail</code> <code>string</code> <code>{\"format\": \"name-email\"}</code>      Pydantic standard \"format\" extension    <code>AnyUrl</code> <code>string</code> <code>{\"format\": \"uri\"}</code>      JSON Schema Validation    <code>Pattern</code> <code>string</code> <code>{\"format\": \"regex\"}</code>      JSON Schema Validation    <code>bytes</code> <code>string</code> <code>{\"format\": \"binary\"}</code>      OpenAPI    <code>Decimal</code> <code>number</code>      JSON Schema Core    <code>UUID1</code> <code>string</code> <code>{\"format\": \"uuid1\"}</code>      Pydantic standard \"format\" extension    <code>UUID3</code> <code>string</code> <code>{\"format\": \"uuid3\"}</code>      Pydantic standard \"format\" extension    <code>UUID4</code> <code>string</code> <code>{\"format\": \"uuid4\"}</code>      Pydantic standard \"format\" extension    <code>UUID5</code> <code>string</code> <code>{\"format\": \"uuid5\"}</code>      Pydantic standard \"format\" extension    <code>UUID</code> <code>string</code> <code>{\"format\": \"uuid\"}</code>      Pydantic standard \"format\" extension    Suggested in OpenAPI. <code>FilePath</code> <code>string</code> <code>{\"format\": \"file-path\"}</code>      Pydantic standard \"format\" extension    <code>DirectoryPath</code> <code>string</code> <code>{\"format\": \"directory-path\"}</code>      Pydantic standard \"format\" extension    <code>Path</code> <code>string</code> <code>{\"format\": \"path\"}</code>      Pydantic standard \"format\" extension    <code>datetime</code> <code>string</code> <code>{\"format\": \"date-time\"}</code>      JSON Schema Validation    <code>date</code> <code>string</code> <code>{\"format\": \"date\"}</code>      JSON Schema Validation    <code>time</code> <code>string</code> <code>{\"format\": \"time\"}</code>      JSON Schema Validation    <code>timedelta</code> <code>number</code> <code>{\"format\": \"time-delta\"}</code>      Difference in seconds (a <code>float</code>), with Pydantic standard \"format\" extension    Suggested in JSON Schema repository's issues by maintainer. <code>Json</code> <code>string</code> <code>{\"format\": \"json-string\"}</code>      Pydantic standard \"format\" extension    <code>IPv4Address</code> <code>string</code> <code>{\"format\": \"ipv4\"}</code>      JSON Schema Validation    <code>IPv6Address</code> <code>string</code> <code>{\"format\": \"ipv6\"}</code>      JSON Schema Validation    <code>IPvAnyAddress</code> <code>string</code> <code>{\"format\": \"ipvanyaddress\"}</code>      Pydantic standard \"format\" extension    IPv4 or IPv6 address as used in <code>ipaddress</code> module <code>IPv4Interface</code> <code>string</code> <code>{\"format\": \"ipv4interface\"}</code>      Pydantic standard \"format\" extension    IPv4 interface as used in <code>ipaddress</code> module <code>IPv6Interface</code> <code>string</code> <code>{\"format\": \"ipv6interface\"}</code>      Pydantic standard \"format\" extension    IPv6 interface as used in <code>ipaddress</code> module <code>IPvAnyInterface</code> <code>string</code> <code>{\"format\": \"ipvanyinterface\"}</code>      Pydantic standard \"format\" extension    IPv4 or IPv6 interface as used in <code>ipaddress</code> module <code>IPv4Network</code> <code>string</code> <code>{\"format\": \"ipv4network\"}</code>      Pydantic standard \"format\" extension    IPv4 network as used in <code>ipaddress</code> module <code>IPv6Network</code> <code>string</code> <code>{\"format\": \"ipv6network\"}</code>      Pydantic standard \"format\" extension    IPv6 network as used in <code>ipaddress</code> module <code>IPvAnyNetwork</code> <code>string</code> <code>{\"format\": \"ipvanynetwork\"}</code>      Pydantic standard \"format\" extension    IPv4 or IPv6 network as used in <code>ipaddress</code> module <code>StrictBool</code> <code>boolean</code>      JSON Schema Core    <code>StrictStr</code> <code>string</code>      JSON Schema Core    <code>ConstrainedStr</code> <code>string</code>      JSON Schema Core    If the type has values declared for the constraints, they are included as validations. See the mapping for <code>constr</code> below. <code>constr(regex='^text$', min_length=2, max_length=10)</code> <code>string</code> <code>{\"pattern\": \"^text$\", \"minLength\": 2, \"maxLength\": 10}</code>      JSON Schema Validation    Any argument not passed to the function (not defined) will not be included in the schema. <code>ConstrainedInt</code> <code>integer</code>      JSON Schema Core    If the type has values declared for the constraints, they are included as validations. See the mapping for <code>conint</code> below. <code>conint(gt=1, ge=2, lt=6, le=5, multiple_of=2)</code> <code>integer</code> <code>{\"maximum\": 5, \"exclusiveMaximum\": 6, \"minimum\": 2, \"exclusiveMinimum\": 1, \"multipleOf\": 2}</code> Any argument not passed to the function (not defined) will not be included in the schema. <code>PositiveInt</code> <code>integer</code> <code>{\"exclusiveMinimum\": 0}</code>      JSON Schema Validation    <code>NegativeInt</code> <code>integer</code> <code>{\"exclusiveMaximum\": 0}</code>      JSON Schema Validation    <code>NonNegativeInt</code> <code>integer</code> <code>{\"minimum\": 0}</code>      JSON Schema Validation    <code>NonPositiveInt</code> <code>integer</code> <code>{\"maximum\": 0}</code>      JSON Schema Validation    <code>ConstrainedFloat</code> <code>number</code>      JSON Schema Core    If the type has values declared for the constraints, they are included as validations. See the mapping for <code>confloat</code> below. <code>confloat(gt=1, ge=2, lt=6, le=5, multiple_of=2)</code> <code>number</code> <code>{\"maximum\": 5, \"exclusiveMaximum\": 6, \"minimum\": 2, \"exclusiveMinimum\": 1, \"multipleOf\": 2}</code>      JSON Schema Validation    Any argument not passed to the function (not defined) will not be included in the schema. <code>PositiveFloat</code> <code>number</code> <code>{\"exclusiveMinimum\": 0}</code>      JSON Schema Validation    <code>NegativeFloat</code> <code>number</code> <code>{\"exclusiveMaximum\": 0}</code>      JSON Schema Validation    <code>NonNegativeFloat</code> <code>number</code> <code>{\"minimum\": 0}</code>      JSON Schema Validation    <code>NonPositiveFloat</code> <code>number</code> <code>{\"maximum\": 0}</code>      JSON Schema Validation    <code>ConstrainedDecimal</code> <code>number</code>      JSON Schema Core    If the type has values declared for the constraints, they are included as validations. See the mapping for <code>condecimal</code> below. <code>condecimal(gt=1, ge=2, lt=6, le=5, multiple_of=2)</code> <code>number</code> <code>{\"maximum\": 5, \"exclusiveMaximum\": 6, \"minimum\": 2, \"exclusiveMinimum\": 1, \"multipleOf\": 2}</code>      JSON Schema Validation    Any argument not passed to the function (not defined) will not be included in the schema. <code>BaseModel</code> <code>object</code>      JSON Schema Core    All the properties defined will be defined with standard JSON Schema, including submodels. <code>Color</code> <code>string</code> <code>{\"format\": \"color\"}</code>      Pydantic standard \"format\" extension"},{"location":"usage/schema/#top-level-schema-generation","title":"Top-level schema generation","text":"<p>You can also generate a top-level JSON Schema that only includes a list of models and related sub-models in its <code>definitions</code>:</p> Python 3.7 and above <pre><code>import json\nfrom pydantic import BaseModel\nfrom pydantic.schema import schema\n\n\nclass Foo(BaseModel):\n    a: str = None\n\n\nclass Model(BaseModel):\n    b: Foo\n\n\nclass Bar(BaseModel):\n    c: int\n\n\ntop_level_schema = schema([Model, Bar], title='My Schema')\nprint(json.dumps(top_level_schema, indent=2))\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Outputs: <pre><code>{\n  \"title\": \"My Schema\",\n  \"definitions\": {\n    \"Foo\": {\n      \"title\": \"Foo\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"a\": {\n          \"title\": \"A\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"Model\": {\n      \"title\": \"Model\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"b\": {\n          \"$ref\": \"#/definitions/Foo\"\n        }\n      },\n      \"required\": [\n        \"b\"\n      ]\n    },\n    \"Bar\": {\n      \"title\": \"Bar\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"c\": {\n          \"title\": \"C\",\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"c\"\n      ]\n    }\n  }\n}\n</code></pre></p>"},{"location":"usage/schema/#schema-customization","title":"Schema customization","text":"<p>You can customize the generated <code>$ref</code> JSON location: the definitions are always stored under the key <code>definitions</code>, but a specified prefix can be used for the references.</p> <p>This is useful if you need to extend or modify the JSON Schema default definitions location. E.g. with OpenAPI:</p> Python 3.7 and above <pre><code>import json\nfrom pydantic import BaseModel\nfrom pydantic.schema import schema\n\n\nclass Foo(BaseModel):\n    a: int\n\n\nclass Model(BaseModel):\n    a: Foo\n\n\n# Default location for OpenAPI\ntop_level_schema = schema([Model], ref_prefix='#/components/schemas/')\nprint(json.dumps(top_level_schema, indent=2))\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Outputs: <pre><code>{\n  \"definitions\": {\n    \"Foo\": {\n      \"title\": \"Foo\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"a\": {\n          \"title\": \"A\",\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"a\"\n      ]\n    },\n    \"Model\": {\n      \"title\": \"Model\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"a\": {\n          \"$ref\": \"#/components/schemas/Foo\"\n        }\n      },\n      \"required\": [\n        \"a\"\n      ]\n    }\n  }\n}\n</code></pre></p> <p>It's also possible to extend/override the generated JSON schema in a model.</p> <p>To do it, use the <code>Config</code> sub-class attribute <code>schema_extra</code>.</p> <p>For example, you could add <code>examples</code> to the JSON Schema:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel\n\n\nclass Person(BaseModel):\n    name: str\n    age: int\n\n    class Config:\n        schema_extra = {\n            'examples': [\n                {\n                    'name': 'John Doe',\n                    'age': 25,\n                }\n            ]\n        }\n\n\nprint(Person.schema_json(indent=2))\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Outputs: <pre><code>{\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"title\": \"Name\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"examples\": [\n    {\n      \"name\": \"John Doe\",\n      \"age\": 25\n    }\n  ]\n}\n</code></pre></p> <p>For more fine-grained control, you can alternatively set <code>schema_extra</code> to a callable and post-process the generated schema. The callable can have one or two positional arguments. The first will be the schema dictionary. The second, if accepted, will be the model class. The callable is expected to mutate the schema dictionary in-place; the return value is not used.</p> <p>For example, the <code>title</code> key can be removed from the model's <code>properties</code>:</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import Dict, Any, Type\nfrom pydantic import BaseModel\n\n\nclass Person(BaseModel):\n    name: str\n    age: int\n\n    class Config:\n        @staticmethod\n        def schema_extra(schema: Dict[str, Any], model: Type['Person']) -&gt; None:\n            for prop in schema.get('properties', {}).values():\n                prop.pop('title', None)\n\n\nprint(Person.schema_json(indent=2))\n</code></pre> <pre><code>from typing import Any\nfrom pydantic import BaseModel\n\n\nclass Person(BaseModel):\n    name: str\n    age: int\n\n    class Config:\n        @staticmethod\n        def schema_extra(schema: dict[str, Any], model: type['Person']) -&gt; None:\n            for prop in schema.get('properties', {}).values():\n                prop.pop('title', None)\n\n\nprint(Person.schema_json(indent=2))\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Outputs: <pre><code>{\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ]\n}\n</code></pre></p>"},{"location":"usage/settings/","title":"Settings management","text":"<p>One of pydantic's most useful applications is settings management.</p> <p>If you create a model that inherits from <code>BaseSettings</code>, the model initialiser will attempt to determine the values of any fields not passed as keyword arguments by reading from the environment. (Default values will still be used if the matching environment variable is not set.)</p> <p>This makes it easy to:</p> <ul> <li>Create a clearly-defined, type-hinted application configuration class</li> <li>Automatically read modifications to the configuration from environment variables</li> <li>Manually override specific settings in the initialiser where desired (e.g. in unit tests)</li> </ul> <p>For example:</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import Set\n\nfrom pydantic import (\n    BaseModel,\n    BaseSettings,\n    PyObject,\n    RedisDsn,\n    PostgresDsn,\n    AmqpDsn,\n    Field,\n)\n\n\nclass SubModel(BaseModel):\n    foo = 'bar'\n    apple = 1\n\n\nclass Settings(BaseSettings):\n    auth_key: str\n    api_key: str = Field(..., env='my_api_key')\n\n    redis_dsn: RedisDsn = 'redis://user:pass@localhost:6379/1'\n    pg_dsn: PostgresDsn = 'postgres://user:pass@localhost:5432/foobar'\n    amqp_dsn: AmqpDsn = 'amqp://user:pass@localhost:5672/'\n\n    special_function: PyObject = 'math.cos'\n\n    # to override domains:\n    # export my_prefix_domains='[\"foo.com\", \"bar.com\"]'\n    domains: Set[str] = set()\n\n    # to override more_settings:\n    # export my_prefix_more_settings='{\"foo\": \"x\", \"apple\": 1}'\n    more_settings: SubModel = SubModel()\n\n    class Config:\n        env_prefix = 'my_prefix_'  # defaults to no prefix, i.e. \"\"\n        fields = {\n            'auth_key': {\n                'env': 'my_auth_key',\n            },\n            'redis_dsn': {\n                'env': ['service_redis_dsn', 'redis_url']\n            }\n        }\n\n\nprint(Settings().dict())\n\"\"\"\n{\n    'auth_key': 'xxx',\n    'api_key': 'xxx',\n    'redis_dsn': RedisDsn('redis://user:pass@localhost:6379/1', ),\n    'pg_dsn': PostgresDsn('postgres://user:pass@localhost:5432/foobar', ),\n    'amqp_dsn': AmqpDsn('amqp://user:pass@localhost:5672/', scheme='amqp',\nuser='user', password='pass', host='localhost', host_type='int_domain',\nport='5672', path='/'),\n    'special_function': &lt;built-in function cos&gt;,\n    'domains': set(),\n    'more_settings': {'foo': 'bar', 'apple': 1},\n}\n\"\"\"\n</code></pre> <pre><code>from pydantic import (\n    BaseModel,\n    BaseSettings,\n    PyObject,\n    RedisDsn,\n    PostgresDsn,\n    AmqpDsn,\n    Field,\n)\n\n\nclass SubModel(BaseModel):\n    foo = 'bar'\n    apple = 1\n\n\nclass Settings(BaseSettings):\n    auth_key: str\n    api_key: str = Field(..., env='my_api_key')\n\n    redis_dsn: RedisDsn = 'redis://user:pass@localhost:6379/1'\n    pg_dsn: PostgresDsn = 'postgres://user:pass@localhost:5432/foobar'\n    amqp_dsn: AmqpDsn = 'amqp://user:pass@localhost:5672/'\n\n    special_function: PyObject = 'math.cos'\n\n    # to override domains:\n    # export my_prefix_domains='[\"foo.com\", \"bar.com\"]'\n    domains: set[str] = set()\n\n    # to override more_settings:\n    # export my_prefix_more_settings='{\"foo\": \"x\", \"apple\": 1}'\n    more_settings: SubModel = SubModel()\n\n    class Config:\n        env_prefix = 'my_prefix_'  # defaults to no prefix, i.e. \"\"\n        fields = {\n            'auth_key': {\n                'env': 'my_auth_key',\n            },\n            'redis_dsn': {\n                'env': ['service_redis_dsn', 'redis_url']\n            }\n        }\n\n\nprint(Settings().dict())\n\"\"\"\n{\n    'auth_key': 'xxx',\n    'api_key': 'xxx',\n    'redis_dsn': RedisDsn('redis://user:pass@localhost:6379/1', ),\n    'pg_dsn': PostgresDsn('postgres://user:pass@localhost:5432/foobar', ),\n    'amqp_dsn': AmqpDsn('amqp://user:pass@localhost:5672/', scheme='amqp',\nuser='user', password='pass', host='localhost', host_type='int_domain',\nport='5672', path='/'),\n    'special_function': &lt;built-in function cos&gt;,\n    'domains': set(),\n    'more_settings': {'foo': 'bar', 'apple': 1},\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/settings/#environment-variable-names","title":"Environment variable names","text":"<p>The following rules are used to determine which environment variable(s) are read for a given field:</p> <ul> <li> <p>By default, the environment variable name is built by concatenating the prefix and field name.</p> <ul> <li>For example, to override <code>special_function</code> above, you could use:<pre><code>  export my_prefix_special_function='foo.bar'\n</code></pre> </li> </ul> <ul> <li>Note 1: The default prefix is an empty string.</li> <li>Note 2: Field aliases are ignored when building the environment variable name.</li> </ul> </li> </ul> <ul> <li>Custom environment variable names can be set in two ways:<ul> <li><code>Config.fields['field_name']['env']</code> (see <code>auth_key</code> and <code>redis_dsn</code> above)</li> <li><code>Field(..., env=...)</code> (see <code>api_key</code> above)</li> </ul> </li> <li>When specifying custom environment variable names, either a string or a list of strings may be provided.<ul> <li>When specifying a list of strings, order matters: the first detected value is used.</li> <li>For example, for <code>redis_dsn</code> above, <code>service_redis_dsn</code> would take precedence over <code>redis_url</code>.</li> </ul> </li> </ul> <p>Warning</p> <p>Since v1.0 pydantic does not consider field aliases when finding environment variables to populate settings models, use <code>env</code> instead as described above.</p> <p>To aid the transition from aliases to <code>env</code>, a warning will be raised when aliases are used on settings models without a custom env var name. If you really mean to use aliases, either ignore the warning or set <code>env</code> to suppress it.</p> <p>Case-sensitivity can be turned on through the <code>Config</code>:</p> Python 3.7 and above <pre><code>from pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    redis_host = 'localhost'\n\n    class Config:\n        case_sensitive = True\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>When <code>case_sensitive</code> is <code>True</code>, the environment variable names must match field names (optionally with a prefix), so in this example <code>redis_host</code> could only be modified via <code>export redis_host</code>. If you want to name environment variables all upper-case, you should name attribute all upper-case too. You can still name environment variables anything you like through <code>Field(..., env=...)</code>.</p> <p>In Pydantic v1 <code>case_sensitive</code> is <code>False</code> by default and all variable names are converted to lower-case internally. If you want to define upper-case variable names on nested models like <code>SubModel</code> you have to set <code>case_sensitive=True</code> to disable this behaviour.</p> <p>Note</p> <p>On Windows, Python's <code>os</code> module always treats environment variables as case-insensitive, so the <code>case_sensitive</code> config setting will have no effect - settings will always be updated ignoring case.</p>"},{"location":"usage/settings/#parsing-environment-variable-values","title":"Parsing environment variable values","text":"<p>For most simple field types (such as <code>int</code>, <code>float</code>, <code>str</code>, etc.), the environment variable value is parsed the same way it would be if passed directly to the initialiser (as a string).</p> <p>Complex types like <code>list</code>, <code>set</code>, <code>dict</code>, and sub-models are populated from the environment by treating the environment variable's value as a JSON-encoded string.</p> <p>Another way to populate nested complex variables is to configure your model with the <code>env_nested_delimiter</code> config setting, then use an env variable with a name pointing to the nested module fields. What it does is simply explodes your variable into nested models or dicts. So if you define a variable <code>FOO__BAR__BAZ=123</code> it will convert it into <code>FOO={'BAR': {'BAZ': 123}}</code> If you have multiple variables with the same structure they will be merged.</p> <p>With the following environment variables: <pre><code># your environment\nexport V0=0\nexport SUB_MODEL='{\"v1\": \"json-1\", \"v2\": \"json-2\"}'\nexport SUB_MODEL__V2=nested-2\nexport SUB_MODEL__V3=3\nexport SUB_MODEL__DEEP__V4=v4\n</code></pre></p> <p>You could load a settings module thus:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, BaseSettings\n\n\nclass DeepSubModel(BaseModel):\n    v4: str\n\n\nclass SubModel(BaseModel):\n    v1: str\n    v2: bytes\n    v3: int\n    deep: DeepSubModel\n\n\nclass Settings(BaseSettings):\n    v0: str\n    sub_model: SubModel\n\n    class Config:\n        env_nested_delimiter = '__'\n\n\nprint(Settings().dict())\n\"\"\"\n{\n    'v0': '0',\n    'sub_model': {\n        'v1': 'json-1',\n        'v2': b'nested-2',\n        'v3': 3,\n        'deep': {'v4': 'v4'},\n    },\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p><code>env_nested_delimiter</code> can be configured via the <code>Config</code> class as shown above, or via the <code>_env_nested_delimiter</code> keyword argument on instantiation.</p> <p>JSON is only parsed in top-level fields, if you need to parse JSON in sub-models, you will need to implement validators on those models.</p> <p>Nested environment variables take precedence over the top-level environment variable JSON (e.g. in the example above, <code>SUB_MODEL__V2</code> trumps <code>SUB_MODEL</code>).</p> <p>You may also populate a complex type by providing your own parsing function to the <code>parse_env_var</code> classmethod in the Config object.</p> Python 3.7 and abovePython 3.9 and above <pre><code>import os\nfrom typing import Any, List\n\nfrom pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    numbers: List[int]\n\n    class Config:\n        @classmethod\n        def parse_env_var(cls, field_name: str, raw_val: str) -&gt; Any:\n            if field_name == 'numbers':\n                return [int(x) for x in raw_val.split(',')]\n            return cls.json_loads(raw_val)\n\n\nos.environ['numbers'] = '1,2,3'\nprint(Settings().dict())\n#&gt; {'numbers': [1, 2, 3]}\n</code></pre> <pre><code>import os\nfrom typing import Any\n\nfrom pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    numbers: list[int]\n\n    class Config:\n        @classmethod\n        def parse_env_var(cls, field_name: str, raw_val: str) -&gt; Any:\n            if field_name == 'numbers':\n                return [int(x) for x in raw_val.split(',')]\n            return cls.json_loads(raw_val)\n\n\nos.environ['numbers'] = '1,2,3'\nprint(Settings().dict())\n#&gt; {'numbers': [1, 2, 3]}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/settings/#dotenv-env-support","title":"Dotenv (.env) support","text":"<p>Note</p> <p>dotenv file parsing requires python-dotenv to be installed. This can be done with either <code>pip install python-dotenv</code> or <code>pip install pydantic[dotenv]</code>.</p> <p>Dotenv files (generally named <code>.env</code>) are a common pattern that make it easy to use environment variables in a platform-independent manner.</p> <p>A dotenv file follows the same general principles of all environment variables, and looks something like:</p> <pre><code># ignore comment\nENVIRONMENT=\"production\"\nREDIS_ADDRESS=localhost:6379\nMEANING_OF_LIFE=42\nMY_VAR='Hello world'\n</code></pre> <p>Once you have your <code>.env</code> file filled with variables, pydantic supports loading it in two ways:</p> <p>1. setting <code>env_file</code> (and <code>env_file_encoding</code> if you don't want the default encoding of your OS) on <code>Config</code> in a <code>BaseSettings</code> class:</p> <pre><code>class Settings(BaseSettings):\n    ...\n\n    class Config:\n        env_file = '.env'\n        env_file_encoding = 'utf-8'\n</code></pre> <p>2. instantiating a <code>BaseSettings</code> derived class with the <code>_env_file</code> keyword argument (and the <code>_env_file_encoding</code> if needed):</p> <pre><code>settings = Settings(_env_file='prod.env', _env_file_encoding='utf-8')\n</code></pre> <p>In either case, the value of the passed argument can be any valid path or filename, either absolute or relative to the current working directory. From there, pydantic will handle everything for you by loading in your variables and validating them.</p> <p>Note</p> <p>If a filename is specified for <code>env_file</code>, Pydantic will only check the current working directory and won't check any parent directories for the <code>.env</code> file.</p> <p>Even when using a dotenv file, pydantic will still read environment variables as well as the dotenv file, environment variables will always take priority over values loaded from a dotenv file.</p> <p>Passing a file path via the <code>_env_file</code> keyword argument on instantiation (method 2) will override the value (if any) set on the <code>Config</code> class. If the above snippets were used in conjunction, <code>prod.env</code> would be loaded while <code>.env</code> would be ignored.</p> <p>If you need to load multiple dotenv files, you can pass the file paths as a <code>list</code> or <code>tuple</code>.</p> <p>Later files in the list/tuple will take priority over earlier files.</p> <pre><code>from pydantic import BaseSettings\n\nclass Settings(BaseSettings):\n    ...\n\n    class Config:\n        # `.env.prod` takes priority over `.env`\n        env_file = '.env', '.env.prod'\n</code></pre> <p>You can also use the keyword argument override to tell Pydantic not to load any file at all (even if one is set in the <code>Config</code> class) by passing <code>None</code> as the instantiation keyword argument, e.g. <code>settings = Settings(_env_file=None)</code>.</p> <p>Because python-dotenv is used to parse the file, bash-like semantics such as <code>export</code> can be used which (depending on your OS and environment) may allow your dotenv file to also be used with <code>source</code>, see python-dotenv's documentation for more details.</p>"},{"location":"usage/settings/#secret-support","title":"Secret Support","text":"<p>Placing secret values in files is a common pattern to provide sensitive configuration to an application.</p> <p>A secret file follows the same principal as a dotenv file except it only contains a single value and the file name is used as the key. A secret file will look like the following:</p> <p><code>/var/run/database_password</code>: <pre><code>super_secret_database_password\n</code></pre></p> <p>Once you have your secret files, pydantic supports loading it in two ways:</p> <p>1. setting <code>secrets_dir</code> on <code>Config</code> in a <code>BaseSettings</code> class to the directory where your secret files are stored:</p> <pre><code>class Settings(BaseSettings):\n    ...\n    database_password: str\n\n    class Config:\n        secrets_dir = '/var/run'\n</code></pre> <p>2. instantiating a <code>BaseSettings</code> derived class with the <code>_secrets_dir</code> keyword argument:</p> <pre><code>settings = Settings(_secrets_dir='/var/run')\n</code></pre> <p>In either case, the value of the passed argument can be any valid directory, either absolute or relative to the current working directory. Note that a non existent directory will only generate a warning. From there, pydantic will handle everything for you by loading in your variables and validating them.</p> <p>Even when using a secrets directory, pydantic will still read environment variables from a dotenv file or the environment, a dotenv file and environment variables will always take priority over values loaded from the secrets directory.</p> <p>Passing a file path via the <code>_secrets_dir</code> keyword argument on instantiation (method 2) will override the value (if any) set on the <code>Config</code> class.</p>"},{"location":"usage/settings/#use-case-docker-secrets","title":"Use Case: Docker Secrets","text":"<p>Docker Secrets can be used to provide sensitive configuration to an application running in a Docker container. To use these secrets in a pydantic application the process is simple. More information regarding creating, managing and using secrets in Docker see the official Docker documentation.</p> <p>First, define your Settings <pre><code>class Settings(BaseSettings):\n    my_secret_data: str\n\n    class Config:\n        secrets_dir = '/run/secrets'\n</code></pre></p> <p>Note</p> <p>By default Docker uses <code>/run/secrets</code> as the target mount point. If you want to use a different location, change <code>Config.secrets_dir</code> accordingly.</p> <p>Then, create your secret via the Docker CLI <pre><code>printf \"This is a secret\" | docker secret create my_secret_data -\n</code></pre></p> <p>Last, run your application inside a Docker container and supply your newly created secret <pre><code>docker service create --name pydantic-with-secrets --secret my_secret_data pydantic-app:latest\n</code></pre></p>"},{"location":"usage/settings/#field-value-priority","title":"Field value priority","text":"<p>In the case where a value is specified for the same <code>Settings</code> field in multiple ways, the selected value is determined as follows (in descending order of priority):</p> <ol> <li>Arguments passed to the <code>Settings</code> class initialiser.</li> <li>Environment variables, e.g. <code>my_prefix_special_function</code> as described above.</li> <li>Variables loaded from a dotenv (<code>.env</code>) file.</li> <li>Variables loaded from the secrets directory.</li> <li>The default field values for the <code>Settings</code> model.</li> </ol>"},{"location":"usage/settings/#customise-settings-sources","title":"Customise settings sources","text":"<p>If the default order of priority doesn't match your needs, it's possible to change it by overriding the <code>customise_sources</code> method on the <code>Config</code> class of your <code>Settings</code> .</p> <p><code>customise_sources</code> takes three callables as arguments and returns any number of callables as a tuple. In turn these callables are called to build the inputs to the fields of the settings class.</p> <p>Each callable should take an instance of the settings class as its sole argument and return a <code>dict</code>.</p>"},{"location":"usage/settings/#changing-priority","title":"Changing Priority","text":"<p>The order of the returned callables decides the priority of inputs; first item is the highest priority.</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import Tuple\nfrom pydantic import BaseSettings, PostgresDsn\nfrom pydantic.env_settings import SettingsSourceCallable\n\n\nclass Settings(BaseSettings):\n    database_dsn: PostgresDsn\n\n    class Config:\n        @classmethod\n        def customise_sources(\n            cls,\n            init_settings: SettingsSourceCallable,\n            env_settings: SettingsSourceCallable,\n            file_secret_settings: SettingsSourceCallable,\n        ) -&gt; Tuple[SettingsSourceCallable, ...]:\n            return env_settings, init_settings, file_secret_settings\n\n\nprint(Settings(database_dsn='postgres://postgres@localhost:5432/kwargs_db'))\n#&gt; database_dsn=PostgresDsn('postgres://postgres@localhost:5432/env_db', )\n</code></pre> <pre><code>from pydantic import BaseSettings, PostgresDsn\nfrom pydantic.env_settings import SettingsSourceCallable\n\n\nclass Settings(BaseSettings):\n    database_dsn: PostgresDsn\n\n    class Config:\n        @classmethod\n        def customise_sources(\n            cls,\n            init_settings: SettingsSourceCallable,\n            env_settings: SettingsSourceCallable,\n            file_secret_settings: SettingsSourceCallable,\n        ) -&gt; tuple[SettingsSourceCallable, ...]:\n            return env_settings, init_settings, file_secret_settings\n\n\nprint(Settings(database_dsn='postgres://postgres@localhost:5432/kwargs_db'))\n#&gt; database_dsn=PostgresDsn('postgres://postgres@localhost:5432/env_db', )\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>By flipping <code>env_settings</code> and <code>init_settings</code>, environment variables now have precedence over <code>__init__</code> kwargs.</p>"},{"location":"usage/settings/#adding-sources","title":"Adding sources","text":"<p>As explained earlier, pydantic ships with multiples built-in settings sources. However, you may occasionally need to add your own custom sources, <code>customise_sources</code> makes this very easy:</p> Python 3.7 and abovePython 3.9 and above <pre><code>import json\nfrom pathlib import Path\nfrom typing import Dict, Any\n\nfrom pydantic import BaseSettings\n\n\ndef json_config_settings_source(settings: BaseSettings) -&gt; Dict[str, Any]:\n    \"\"\"\n    A simple settings source that loads variables from a JSON file\n    at the project's root.\n\n    Here we happen to choose to use the `env_file_encoding` from Config\n    when reading `config.json`\n    \"\"\"\n    encoding = settings.__config__.env_file_encoding\n    return json.loads(Path('config.json').read_text(encoding))\n\n\nclass Settings(BaseSettings):\n    foobar: str\n\n    class Config:\n        env_file_encoding = 'utf-8'\n\n        @classmethod\n        def customise_sources(\n            cls,\n            init_settings,\n            env_settings,\n            file_secret_settings,\n        ):\n            return (\n                init_settings,\n                json_config_settings_source,\n                env_settings,\n                file_secret_settings,\n            )\n\n\nprint(Settings())\n#&gt; foobar='spam'\n</code></pre> <pre><code>import json\nfrom pathlib import Path\nfrom typing import Any\n\nfrom pydantic import BaseSettings\n\n\ndef json_config_settings_source(settings: BaseSettings) -&gt; dict[str, Any]:\n    \"\"\"\n    A simple settings source that loads variables from a JSON file\n    at the project's root.\n\n    Here we happen to choose to use the `env_file_encoding` from Config\n    when reading `config.json`\n    \"\"\"\n    encoding = settings.__config__.env_file_encoding\n    return json.loads(Path('config.json').read_text(encoding))\n\n\nclass Settings(BaseSettings):\n    foobar: str\n\n    class Config:\n        env_file_encoding = 'utf-8'\n\n        @classmethod\n        def customise_sources(\n            cls,\n            init_settings,\n            env_settings,\n            file_secret_settings,\n        ):\n            return (\n                init_settings,\n                json_config_settings_source,\n                env_settings,\n                file_secret_settings,\n            )\n\n\nprint(Settings())\n#&gt; foobar='spam'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/settings/#removing-sources","title":"Removing sources","text":"<p>You might also want to disable a source:</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import Tuple\n\nfrom pydantic import BaseSettings\nfrom pydantic.env_settings import SettingsSourceCallable\n\n\nclass Settings(BaseSettings):\n    my_api_key: str\n\n    class Config:\n        @classmethod\n        def customise_sources(\n            cls,\n            init_settings: SettingsSourceCallable,\n            env_settings: SettingsSourceCallable,\n            file_secret_settings: SettingsSourceCallable,\n        ) -&gt; Tuple[SettingsSourceCallable, ...]:\n            # here we choose to ignore arguments from init_settings\n            return env_settings, file_secret_settings\n\n\nprint(Settings(my_api_key='this is ignored'))\n#&gt; my_api_key='xxx'\n</code></pre> <pre><code>from pydantic import BaseSettings\nfrom pydantic.env_settings import SettingsSourceCallable\n\n\nclass Settings(BaseSettings):\n    my_api_key: str\n\n    class Config:\n        @classmethod\n        def customise_sources(\n            cls,\n            init_settings: SettingsSourceCallable,\n            env_settings: SettingsSourceCallable,\n            file_secret_settings: SettingsSourceCallable,\n        ) -&gt; tuple[SettingsSourceCallable, ...]:\n            # here we choose to ignore arguments from init_settings\n            return env_settings, file_secret_settings\n\n\nprint(Settings(my_api_key='this is ignored'))\n#&gt; my_api_key='xxx'\n</code></pre> <p>(This script requires <code>MY_API_KEY</code> env variable to be set, e.g. <code>export MY_API_KEY=xxx</code>)</p>"},{"location":"usage/types/","title":"Field Types","text":"<p>Where possible pydantic uses standard library types to define fields, thus smoothing the learning curve. For many useful applications, however, no standard library type exists, so pydantic implements many commonly used types.</p> <p>If no existing type suits your purpose you can also implement your own pydantic-compatible types with custom properties and validation.</p>"},{"location":"usage/types/#standard-library-types","title":"Standard Library Types","text":"<p>pydantic supports many common types from the Python standard library. If you need stricter processing see Strict Types; if you need to constrain the values allowed (e.g. to require a positive int) see Constrained Types.</p> <code>None</code>, <code>type(None)</code> or <code>Literal[None]</code> (equivalent according to PEP 484) allows only <code>None</code> value <code>bool</code> see Booleans below for details on how bools are validated and what values are permitted <code>int</code> pydantic uses <code>int(v)</code> to coerce types to an <code>int</code>; see this warning on loss of information during data conversion <code>float</code> similarly, <code>float(v)</code> is used to coerce values to floats <code>str</code> strings are accepted as-is, <code>int</code> <code>float</code> and <code>Decimal</code> are coerced using <code>str(v)</code>, <code>bytes</code> and <code>bytearray</code> are converted using <code>v.decode()</code>, enums inheriting from <code>str</code> are converted using <code>v.value</code>, and all other types cause an error <code>bytes</code> <code>bytes</code> are accepted as-is, <code>bytearray</code> is converted using <code>bytes(v)</code>, <code>str</code> are converted using <code>v.encode()</code>, and <code>int</code>, <code>float</code>, and <code>Decimal</code> are coerced using <code>str(v).encode()</code> <code>list</code> allows <code>list</code>, <code>tuple</code>, <code>set</code>, <code>frozenset</code>, <code>deque</code>, or generators and casts to a list; see <code>typing.List</code> below for sub-type constraints <code>tuple</code> allows <code>list</code>, <code>tuple</code>, <code>set</code>, <code>frozenset</code>, <code>deque</code>, or generators and casts to a tuple; see <code>typing.Tuple</code> below for sub-type constraints <code>dict</code> <code>dict(v)</code> is used to attempt to convert a dictionary; see <code>typing.Dict</code> below for sub-type constraints <code>set</code> allows <code>list</code>, <code>tuple</code>, <code>set</code>, <code>frozenset</code>, <code>deque</code>, or generators and casts to a set; see <code>typing.Set</code> below for sub-type constraints <code>frozenset</code> allows <code>list</code>, <code>tuple</code>, <code>set</code>, <code>frozenset</code>, <code>deque</code>, or generators and casts to a frozen set; see <code>typing.FrozenSet</code> below for sub-type constraints <code>deque</code> allows <code>list</code>, <code>tuple</code>, <code>set</code>, <code>frozenset</code>, <code>deque</code>, or generators and casts to a deque; see <code>typing.Deque</code> below for sub-type constraints <code>datetime.date</code> see Datetime Types below for more detail on parsing and validation <code>datetime.time</code> see Datetime Types below for more detail on parsing and validation <code>datetime.datetime</code> see Datetime Types below for more detail on parsing and validation <code>datetime.timedelta</code> see Datetime Types below for more detail on parsing and validation <code>typing.Any</code> allows any value including <code>None</code>, thus an <code>Any</code> field is optional <code>typing.Annotated</code> allows wrapping another type with arbitrary metadata, as per PEP-593. The <code>Annotated</code> hint may contain a single call to the <code>Field</code> function, but otherwise the additional metadata is ignored and the root type is used. <code>typing.TypeVar</code> constrains the values allowed based on <code>constraints</code> or <code>bound</code>, see TypeVar <code>typing.Union</code> see Unions below for more detail on parsing and validation <code>typing.Optional</code> <code>Optional[x]</code> is simply short hand for <code>Union[x, None]</code>; see Unions below for more detail on parsing and validation and Required Fields for details about required fields that can receive <code>None</code> as a value. <code>typing.List</code> see Typing Iterables below for more detail on parsing and validation <code>typing.Tuple</code> see Typing Iterables below for more detail on parsing and validation <code>subclass of typing.NamedTuple</code> Same as <code>tuple</code> but instantiates with the given namedtuple and validates fields since they are annotated. See Annotated Types below for more detail on parsing and validation <code>subclass of collections.namedtuple</code> Same as <code>subclass of typing.NamedTuple</code> but all fields will have type <code>Any</code> since they are not annotated <code>typing.Dict</code> see Typing Iterables below for more detail on parsing and validation <code>subclass of typing.TypedDict</code> Same as <code>dict</code> but pydantic will validate the dictionary since keys are annotated. See Annotated Types below for more detail on parsing and validation <code>typing.Set</code> see Typing Iterables below for more detail on parsing and validation <code>typing.FrozenSet</code> see Typing Iterables below for more detail on parsing and validation <code>typing.Deque</code> see Typing Iterables below for more detail on parsing and validation <code>typing.Sequence</code> see Typing Iterables below for more detail on parsing and validation <code>typing.Iterable</code> this is reserved for iterables that shouldn't be consumed. See Infinite Generators below for more detail on parsing and validation <code>typing.Type</code> see Type below for more detail on parsing and validation <code>typing.Callable</code> see Callable below for more detail on parsing and validation <code>typing.Pattern</code> will cause the input value to be passed to <code>re.compile(v)</code> to create a regex pattern <code>ipaddress.IPv4Address</code> simply uses the type itself for validation by passing the value to <code>IPv4Address(v)</code>; see Pydantic Types for other custom IP address types <code>ipaddress.IPv4Interface</code> simply uses the type itself for validation by passing the value to <code>IPv4Address(v)</code>; see Pydantic Types for other custom IP address types <code>ipaddress.IPv4Network</code> simply uses the type itself for validation by passing the value to <code>IPv4Network(v)</code>; see Pydantic Types for other custom IP address types <code>ipaddress.IPv6Address</code> simply uses the type itself for validation by passing the value to <code>IPv6Address(v)</code>; see Pydantic Types for other custom IP address types <code>ipaddress.IPv6Interface</code> simply uses the type itself for validation by passing the value to <code>IPv6Interface(v)</code>; see Pydantic Types for other custom IP address types <code>ipaddress.IPv6Network</code> simply uses the type itself for validation by passing the value to <code>IPv6Network(v)</code>; see Pydantic Types for other custom IP address types <code>enum.Enum</code> checks that the value is a valid Enum instance <code>subclass of enum.Enum</code> checks that the value is a valid member of the enum; see Enums and Choices for more details <code>enum.IntEnum</code> checks that the value is a valid IntEnum instance <code>subclass of enum.IntEnum</code> checks that the value is a valid member of the integer enum; see Enums and Choices for more details <code>decimal.Decimal</code> pydantic attempts to convert the value to a string, then passes the string to <code>Decimal(v)</code> <code>pathlib.Path</code> simply uses the type itself for validation by passing the value to <code>Path(v)</code>; see Pydantic Types for other more strict path types <code>uuid.UUID</code> strings and bytes (converted to strings) are passed to <code>UUID(v)</code>, with a fallback to <code>UUID(bytes=v)</code> for <code>bytes</code> and <code>bytearray</code>; see Pydantic Types for other stricter UUID types <code>ByteSize</code> converts a bytes string with units to bytes"},{"location":"usage/types/#typing-iterables","title":"Typing Iterables","text":"<p>pydantic uses standard library <code>typing</code> types as defined in PEP 484 to define complex objects.</p> Python 3.7 and abovePython 3.9 and abovePython 3.10 and above <pre><code>from typing import (\n    Deque, Dict, FrozenSet, List, Optional, Sequence, Set, Tuple, Union\n)\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_list: list = None\n    list_of_ints: List[int] = None\n\n    simple_tuple: tuple = None\n    tuple_of_different_types: Tuple[int, float, str, bool] = None\n\n    simple_dict: dict = None\n    dict_str_float: Dict[str, float] = None\n\n    simple_set: set = None\n    set_bytes: Set[bytes] = None\n    frozen_set: FrozenSet[int] = None\n\n    str_or_bytes: Union[str, bytes] = None\n    none_or_str: Optional[str] = None\n\n    sequence_of_ints: Sequence[int] = None\n\n    compound: Dict[Union[str, bytes], List[Set[int]]] = None\n\n    deque: Deque[int] = None\n\n\nprint(Model(simple_list=['1', '2', '3']).simple_list)\n#&gt; ['1', '2', '3']\nprint(Model(list_of_ints=['1', '2', '3']).list_of_ints)\n#&gt; [1, 2, 3]\n\nprint(Model(simple_dict={'a': 1, b'b': 2}).simple_dict)\n#&gt; {'a': 1, b'b': 2}\nprint(Model(dict_str_float={'a': 1, b'b': 2}).dict_str_float)\n#&gt; {'a': 1.0, 'b': 2.0}\n\nprint(Model(simple_tuple=[1, 2, 3, 4]).simple_tuple)\n#&gt; (1, 2, 3, 4)\nprint(Model(tuple_of_different_types=[4, 3, 2, 1]).tuple_of_different_types)\n#&gt; (4, 3.0, '2', True)\n\nprint(Model(sequence_of_ints=[1, 2, 3, 4]).sequence_of_ints)\n#&gt; [1, 2, 3, 4]\nprint(Model(sequence_of_ints=(1, 2, 3, 4)).sequence_of_ints)\n#&gt; (1, 2, 3, 4)\n\nprint(Model(deque=[1, 2, 3]).deque)\n#&gt; deque([1, 2, 3])\n</code></pre> <pre><code>from typing import (\n    Deque, Optional, Union\n)\nfrom collections.abc import Sequence\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_list: list = None\n    list_of_ints: list[int] = None\n\n    simple_tuple: tuple = None\n    tuple_of_different_types: tuple[int, float, str, bool] = None\n\n    simple_dict: dict = None\n    dict_str_float: dict[str, float] = None\n\n    simple_set: set = None\n    set_bytes: set[bytes] = None\n    frozen_set: frozenset[int] = None\n\n    str_or_bytes: Union[str, bytes] = None\n    none_or_str: Optional[str] = None\n\n    sequence_of_ints: Sequence[int] = None\n\n    compound: dict[Union[str, bytes], list[set[int]]] = None\n\n    deque: Deque[int] = None\n\n\nprint(Model(simple_list=['1', '2', '3']).simple_list)\n#&gt; ['1', '2', '3']\nprint(Model(list_of_ints=['1', '2', '3']).list_of_ints)\n#&gt; [1, 2, 3]\n\nprint(Model(simple_dict={'a': 1, b'b': 2}).simple_dict)\n#&gt; {'a': 1, b'b': 2}\nprint(Model(dict_str_float={'a': 1, b'b': 2}).dict_str_float)\n#&gt; {'a': 1.0, 'b': 2.0}\n\nprint(Model(simple_tuple=[1, 2, 3, 4]).simple_tuple)\n#&gt; (1, 2, 3, 4)\nprint(Model(tuple_of_different_types=[4, 3, 2, 1]).tuple_of_different_types)\n#&gt; (4, 3.0, '2', True)\n\nprint(Model(sequence_of_ints=[1, 2, 3, 4]).sequence_of_ints)\n#&gt; [1, 2, 3, 4]\nprint(Model(sequence_of_ints=(1, 2, 3, 4)).sequence_of_ints)\n#&gt; (1, 2, 3, 4)\n\nprint(Model(deque=[1, 2, 3]).deque)\n#&gt; deque([1, 2, 3])\n</code></pre> <pre><code>from typing import (\n    Deque\n)\nfrom collections.abc import Sequence\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_list: list = None\n    list_of_ints: list[int] = None\n\n    simple_tuple: tuple = None\n    tuple_of_different_types: tuple[int, float, str, bool] = None\n\n    simple_dict: dict = None\n    dict_str_float: dict[str, float] = None\n\n    simple_set: set = None\n    set_bytes: set[bytes] = None\n    frozen_set: frozenset[int] = None\n\n    str_or_bytes: str | bytes = None\n    none_or_str: str | None = None\n\n    sequence_of_ints: Sequence[int] = None\n\n    compound: dict[str | bytes, list[set[int]]] = None\n\n    deque: Deque[int] = None\n\n\nprint(Model(simple_list=['1', '2', '3']).simple_list)\n#&gt; ['1', '2', '3']\nprint(Model(list_of_ints=['1', '2', '3']).list_of_ints)\n#&gt; [1, 2, 3]\n\nprint(Model(simple_dict={'a': 1, b'b': 2}).simple_dict)\n#&gt; {'a': 1, b'b': 2}\nprint(Model(dict_str_float={'a': 1, b'b': 2}).dict_str_float)\n#&gt; {'a': 1.0, 'b': 2.0}\n\nprint(Model(simple_tuple=[1, 2, 3, 4]).simple_tuple)\n#&gt; (1, 2, 3, 4)\nprint(Model(tuple_of_different_types=[4, 3, 2, 1]).tuple_of_different_types)\n#&gt; (4, 3.0, '2', True)\n\nprint(Model(sequence_of_ints=[1, 2, 3, 4]).sequence_of_ints)\n#&gt; [1, 2, 3, 4]\nprint(Model(sequence_of_ints=(1, 2, 3, 4)).sequence_of_ints)\n#&gt; (1, 2, 3, 4)\n\nprint(Model(deque=[1, 2, 3]).deque)\n#&gt; deque([1, 2, 3])\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#infinite-generators","title":"Infinite Generators","text":"<p>If you have a generator you can use <code>Sequence</code> as described above. In that case, the generator will be consumed and stored on the model as a list and its values will be validated with the sub-type of <code>Sequence</code> (e.g. <code>int</code> in <code>Sequence[int]</code>).</p> <p>But if you have a generator that you don't want to be consumed, e.g. an infinite generator or a remote data loader, you can define its type with <code>Iterable</code>:</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import Iterable\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    infinite: Iterable[int]\n\n\ndef infinite_ints():\n    i = 0\n    while True:\n        yield i\n        i += 1\n\n\nm = Model(infinite=infinite_ints())\nprint(m)\n#&gt; infinite=&lt;generator object infinite_ints at 0x7fa11227de70&gt;\n\nfor i in m.infinite:\n    print(i)\n    #&gt; 0\n    #&gt; 1\n    #&gt; 2\n    #&gt; 3\n    #&gt; 4\n    #&gt; 5\n    #&gt; 6\n    #&gt; 7\n    #&gt; 8\n    #&gt; 9\n    #&gt; 10\n    if i == 10:\n        break\n</code></pre> <pre><code>from collections.abc import Iterable\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    infinite: Iterable[int]\n\n\ndef infinite_ints():\n    i = 0\n    while True:\n        yield i\n        i += 1\n\n\nm = Model(infinite=infinite_ints())\nprint(m)\n#&gt; infinite=&lt;generator object infinite_ints at 0x7fa11227f760&gt;\n\nfor i in m.infinite:\n    print(i)\n    #&gt; 0\n    #&gt; 1\n    #&gt; 2\n    #&gt; 3\n    #&gt; 4\n    #&gt; 5\n    #&gt; 6\n    #&gt; 7\n    #&gt; 8\n    #&gt; 9\n    #&gt; 10\n    if i == 10:\n        break\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Warning</p> <p><code>Iterable</code> fields only perform a simple check that the argument is iterable and won't be consumed.</p> <p>No validation of their values is performed as it cannot be done without consuming the iterable.</p> <p>Tip</p> <p>If you want to validate the values of an infinite generator you can create a separate model and use it while consuming the generator, reporting the validation errors as appropriate.</p> <p>pydantic can't validate the values automatically for you because it would require consuming the infinite generator.</p>"},{"location":"usage/types/#validating-the-first-value","title":"Validating the first value","text":"<p>You can create a validator to validate the first value in an infinite generator and still not consume it entirely.</p> Python 3.7 and abovePython 3.9 and above <pre><code>import itertools\nfrom typing import Iterable\nfrom pydantic import BaseModel, validator, ValidationError\nfrom pydantic.fields import ModelField\n\n\nclass Model(BaseModel):\n    infinite: Iterable[int]\n\n    @validator('infinite')\n    # You don't need to add the \"ModelField\", but it will help your\n    # editor give you completion and catch errors\n    def infinite_first_int(cls, iterable, field: ModelField):\n        first_value = next(iterable)\n        if field.sub_fields:\n            # The Iterable had a parameter type, in this case it's int\n            # We use it to validate the first value\n            sub_field = field.sub_fields[0]\n            v, error = sub_field.validate(first_value, {}, loc='first_value')\n            if error:\n                raise ValidationError([error], cls)\n        # This creates a new generator that returns the first value and then\n        # the rest of the values from the (already started) iterable\n        return itertools.chain([first_value], iterable)\n\n\ndef infinite_ints():\n    i = 0\n    while True:\n        yield i\n        i += 1\n\n\nm = Model(infinite=infinite_ints())\nprint(m)\n#&gt; infinite=&lt;itertools.chain object at 0x7fa111f276d0&gt;\n\n\ndef infinite_strs():\n    while True:\n        yield from 'allthesingleladies'\n\n\ntry:\n    Model(infinite=infinite_strs())\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    infinite -&gt; first_value\n      value is not a valid integer (type=type_error.integer)\n    \"\"\"\n</code></pre> <pre><code>import itertools\nfrom collections.abc import Iterable\nfrom pydantic import BaseModel, validator, ValidationError\nfrom pydantic.fields import ModelField\n\n\nclass Model(BaseModel):\n    infinite: Iterable[int]\n\n    @validator('infinite')\n    # You don't need to add the \"ModelField\", but it will help your\n    # editor give you completion and catch errors\n    def infinite_first_int(cls, iterable, field: ModelField):\n        first_value = next(iterable)\n        if field.sub_fields:\n            # The Iterable had a parameter type, in this case it's int\n            # We use it to validate the first value\n            sub_field = field.sub_fields[0]\n            v, error = sub_field.validate(first_value, {}, loc='first_value')\n            if error:\n                raise ValidationError([error], cls)\n        # This creates a new generator that returns the first value and then\n        # the rest of the values from the (already started) iterable\n        return itertools.chain([first_value], iterable)\n\n\ndef infinite_ints():\n    i = 0\n    while True:\n        yield i\n        i += 1\n\n\nm = Model(infinite=infinite_ints())\nprint(m)\n#&gt; infinite=&lt;itertools.chain object at 0x7fa111f47fd0&gt;\n\n\ndef infinite_strs():\n    while True:\n        yield from 'allthesingleladies'\n\n\ntry:\n    Model(infinite=infinite_strs())\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    infinite -&gt; first_value\n      value is not a valid integer (type=type_error.integer)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#unions","title":"Unions","text":"<p>The <code>Union</code> type allows a model attribute to accept different types, e.g.:</p> <p>Info</p> <p>You may get unexpected coercion with <code>Union</code>; see below. Know that you can also make the check slower but stricter by using Smart Union</p> Python 3.7 and abovePython 3.10 and above <pre><code>from uuid import UUID\nfrom typing import Union\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: Union[int, str, UUID]\n    name: str\n\n\nuser_01 = User(id=123, name='John Doe')\nprint(user_01)\n#&gt; id=123 name='John Doe'\nprint(user_01.id)\n#&gt; 123\nuser_02 = User(id='1234', name='John Doe')\nprint(user_02)\n#&gt; id=1234 name='John Doe'\nprint(user_02.id)\n#&gt; 1234\nuser_03_uuid = UUID('cf57432e-809e-4353-adbd-9d5c0d733868')\nuser_03 = User(id=user_03_uuid, name='John Doe')\nprint(user_03)\n#&gt; id=275603287559914445491632874575877060712 name='John Doe'\nprint(user_03.id)\n#&gt; 275603287559914445491632874575877060712\nprint(user_03_uuid.int)\n#&gt; 275603287559914445491632874575877060712\n</code></pre> <pre><code>from uuid import UUID\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: int | str | UUID\n    name: str\n\n\nuser_01 = User(id=123, name='John Doe')\nprint(user_01)\n#&gt; id=123 name='John Doe'\nprint(user_01.id)\n#&gt; 123\nuser_02 = User(id='1234', name='John Doe')\nprint(user_02)\n#&gt; id=1234 name='John Doe'\nprint(user_02.id)\n#&gt; 1234\nuser_03_uuid = UUID('cf57432e-809e-4353-adbd-9d5c0d733868')\nuser_03 = User(id=user_03_uuid, name='John Doe')\nprint(user_03)\n#&gt; id=275603287559914445491632874575877060712 name='John Doe'\nprint(user_03.id)\n#&gt; 275603287559914445491632874575877060712\nprint(user_03_uuid.int)\n#&gt; 275603287559914445491632874575877060712\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>However, as can be seen above, pydantic will attempt to 'match' any of the types defined under <code>Union</code> and will use the first one that matches. In the above example the <code>id</code> of <code>user_03</code> was defined as a <code>uuid.UUID</code> class (which is defined under the attribute's <code>Union</code> annotation) but as the <code>uuid.UUID</code> can be marshalled into an <code>int</code> it chose to match against the <code>int</code> type and disregarded the other types.</p> <p>Warning</p> <p><code>typing.Union</code> also ignores order when defined, so <code>Union[int, float] == Union[float, int]</code> which can lead to unexpected behaviour when combined with matching based on the <code>Union</code> type order inside other type definitions, such as <code>List</code> and <code>Dict</code> types (because Python treats these definitions as singletons). For example, <code>Dict[str, Union[int, float]] == Dict[str, Union[float, int]]</code> with the order based on the first time it was defined. Please note that this can also be affected by third party libraries and their internal type definitions and the import orders.</p> <p>As such, it is recommended that, when defining <code>Union</code> annotations, the most specific type is included first and followed by less specific types.</p> <p>In the above example, the <code>UUID</code> class should precede the <code>int</code> and <code>str</code> classes to preclude the unexpected representation as such:</p> Python 3.7 and abovePython 3.10 and above <pre><code>from uuid import UUID\nfrom typing import Union\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: Union[UUID, int, str]\n    name: str\n\n\nuser_03_uuid = UUID('cf57432e-809e-4353-adbd-9d5c0d733868')\nuser_03 = User(id=user_03_uuid, name='John Doe')\nprint(user_03)\n#&gt; id=UUID('cf57432e-809e-4353-adbd-9d5c0d733868') name='John Doe'\nprint(user_03.id)\n#&gt; cf57432e-809e-4353-adbd-9d5c0d733868\nprint(user_03_uuid.int)\n#&gt; 275603287559914445491632874575877060712\n</code></pre> <pre><code>from uuid import UUID\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: UUID | int | str\n    name: str\n\n\nuser_03_uuid = UUID('cf57432e-809e-4353-adbd-9d5c0d733868')\nuser_03 = User(id=user_03_uuid, name='John Doe')\nprint(user_03)\n#&gt; id=UUID('cf57432e-809e-4353-adbd-9d5c0d733868') name='John Doe'\nprint(user_03.id)\n#&gt; cf57432e-809e-4353-adbd-9d5c0d733868\nprint(user_03_uuid.int)\n#&gt; 275603287559914445491632874575877060712\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Tip</p> <p>The type <code>Optional[x]</code> is a shorthand for <code>Union[x, None]</code>.</p> <p><code>Optional[x]</code> can also be used to specify a required field that can take <code>None</code> as a value.</p> <p>See more details in Required Fields.</p>"},{"location":"usage/types/#discriminated-unions-aka-tagged-unions","title":"Discriminated Unions (a.k.a. Tagged Unions)","text":"<p>When <code>Union</code> is used with multiple submodels, you sometimes know exactly which submodel needs to be checked and validated and want to enforce this. To do that you can set the same field - let's call it <code>my_discriminator</code> - in each of the submodels with a discriminated value, which is one (or many) <code>Literal</code> value(s). For your <code>Union</code>, you can set the discriminator in its value: <code>Field(discriminator='my_discriminator')</code>.</p> <p>Setting a discriminated union has many benefits:</p> <ul> <li>validation is faster since it is only attempted against one model</li> <li>only one explicit error is raised in case of failure</li> <li>the generated JSON schema implements the associated OpenAPI specification</li> </ul> Python 3.7 and abovePython 3.10 and above <pre><code>from typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    meows: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    barks: float\n\n\nclass Lizard(BaseModel):\n    pet_type: Literal['reptile', 'lizard']\n    scales: bool\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog, Lizard] = Field(..., discriminator='pet_type')\n    n: int\n\n\nprint(Model(pet={'pet_type': 'dog', 'barks': 3.14}, n=1))\n#&gt; pet=Dog(pet_type='dog', barks=3.14) n=1\ntry:\n    Model(pet={'pet_type': 'dog'}, n=1)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet -&gt; Dog -&gt; barks\n      field required (type=value_error.missing)\n    \"\"\"\n</code></pre> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    meows: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    barks: float\n\n\nclass Lizard(BaseModel):\n    pet_type: Literal['reptile', 'lizard']\n    scales: bool\n\n\nclass Model(BaseModel):\n    pet: Cat | Dog | Lizard = Field(..., discriminator='pet_type')\n    n: int\n\n\nprint(Model(pet={'pet_type': 'dog', 'barks': 3.14}, n=1))\n#&gt; pet=Dog(pet_type='dog', barks=3.14) n=1\ntry:\n    Model(pet={'pet_type': 'dog'}, n=1)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet -&gt; Dog -&gt; barks\n      field required (type=value_error.missing)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Note</p> <p>Using the Annotated Fields syntax can be handy to regroup the <code>Union</code> and <code>discriminator</code> information. See below for an example!</p> <p>Warning</p> <p>Discriminated unions cannot be used with only a single variant, such as <code>Union[Cat]</code>.</p> <p>Python changes <code>Union[T]</code> into <code>T</code> at interpretation time, so it is not possible for <code>pydantic</code> to distinguish fields of <code>Union[T]</code> from <code>T</code>.</p>"},{"location":"usage/types/#nested-discriminated-unions","title":"Nested Discriminated Unions","text":"<p>Only one discriminator can be set for a field but sometimes you want to combine multiple discriminators. In this case you can always create \"intermediate\" models with <code>__root__</code> and add your discriminator.</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import Literal, Union\n\nfrom typing_extensions import Annotated\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['black']\n    black_name: str\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['white']\n    white_name: str\n\n\n# Can also be written with a custom root type\n#\n# class Cat(BaseModel):\n#   __root__: Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\nCat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    name: str\n\n\nPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n\nclass Model(BaseModel):\n    pet: Pet\n    n: int\n\n\nm = Model(pet={'pet_type': 'cat', 'color': 'black', 'black_name': 'felix'}, n=1)\nprint(m)\n#&gt; pet=BlackCat(pet_type='cat', color='black', black_name='felix') n=1\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'red'}, n='1')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet -&gt; Union[BlackCat, WhiteCat]\n      No match for discriminator 'color' and value 'red' (allowed values:\n    'black', 'white')\n    (type=value_error.discriminated_union.invalid_discriminator;\n    discriminator_key=color; discriminator_value=red; allowed_values='black',\n    'white')\n    \"\"\"\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'black'}, n='1')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet -&gt; Union[BlackCat, WhiteCat] -&gt; BlackCat -&gt; black_name\n      field required (type=value_error.missing)\n    \"\"\"\n</code></pre> <pre><code>from typing import Literal, Union\n\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['black']\n    black_name: str\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['white']\n    white_name: str\n\n\n# Can also be written with a custom root type\n#\n# class Cat(BaseModel):\n#   __root__: Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\nCat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    name: str\n\n\nPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n\nclass Model(BaseModel):\n    pet: Pet\n    n: int\n\n\nm = Model(pet={'pet_type': 'cat', 'color': 'black', 'black_name': 'felix'}, n=1)\nprint(m)\n#&gt; pet=BlackCat(pet_type='cat', color='black', black_name='felix') n=1\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'red'}, n='1')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet -&gt; Union[BlackCat, WhiteCat]\n      No match for discriminator 'color' and value 'red' (allowed values:\n    'black', 'white')\n    (type=value_error.discriminated_union.invalid_discriminator;\n    discriminator_key=color; discriminator_value=red; allowed_values='black',\n    'white')\n    \"\"\"\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'black'}, n='1')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet -&gt; Union[BlackCat, WhiteCat] -&gt; BlackCat -&gt; black_name\n      field required (type=value_error.missing)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#enums-and-choices","title":"Enums and Choices","text":"<p>pydantic uses Python's standard <code>enum</code> classes to define choices.</p> Python 3.7 and above <pre><code>from enum import Enum, IntEnum\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass FruitEnum(str, Enum):\n    pear = 'pear'\n    banana = 'banana'\n\n\nclass ToolEnum(IntEnum):\n    spanner = 1\n    wrench = 2\n\n\nclass CookingModel(BaseModel):\n    fruit: FruitEnum = FruitEnum.pear\n    tool: ToolEnum = ToolEnum.spanner\n\n\nprint(CookingModel())\n#&gt; fruit=&lt;FruitEnum.pear: 'pear'&gt; tool=&lt;ToolEnum.spanner: 1&gt;\nprint(CookingModel(tool=2, fruit='banana'))\n#&gt; fruit=&lt;FruitEnum.banana: 'banana'&gt; tool=&lt;ToolEnum.wrench: 2&gt;\ntry:\n    CookingModel(fruit='other')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for CookingModel\n    fruit\n      value is not a valid enumeration member; permitted: 'pear', 'banana'\n    (type=type_error.enum; enum_values=[&lt;FruitEnum.pear: 'pear'&gt;,\n    &lt;FruitEnum.banana: 'banana'&gt;])\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#datetime-types","title":"Datetime Types","text":"<p>Pydantic supports the following datetime types:</p> <ul> <li> <p><code>datetime</code> fields can be:</p> <ul> <li><code>datetime</code>, existing <code>datetime</code> object</li> <li><code>int</code> or <code>float</code>, assumed as Unix time, i.e. seconds (if &gt;= <code>-2e10</code> or &lt;= <code>2e10</code>) or milliseconds (if &lt; <code>-2e10</code>or &gt; <code>2e10</code>) since 1 January 1970</li> <li> <p><code>str</code>, following formats work:</p> <ul> <li><code>YYYY-MM-DD[T]HH:MM[:SS[.ffffff]][Z or [\u00b1]HH[:]MM]</code></li> <li><code>int</code> or <code>float</code> as a string (assumed as Unix time)</li> </ul> </li> </ul> </li> </ul> <ul> <li> <p><code>date</code> fields can be:</p> <ul> <li><code>date</code>, existing <code>date</code> object</li> <li><code>int</code> or <code>float</code>, see <code>datetime</code></li> <li> <p><code>str</code>, following formats work:</p> <ul> <li><code>YYYY-MM-DD</code></li> <li><code>int</code> or <code>float</code>, see <code>datetime</code></li> </ul> </li> </ul> </li> </ul> <ul> <li> <p><code>time</code> fields can be:</p> <ul> <li><code>time</code>, existing <code>time</code> object</li> <li> <p><code>str</code>, following formats work:</p> <ul> <li><code>HH:MM[:SS[.ffffff]][Z or [\u00b1]HH[:]MM]</code></li> </ul> </li> </ul> </li> </ul> <ul> <li> <p><code>timedelta</code> fields can be:</p> <ul> <li><code>timedelta</code>, existing <code>timedelta</code> object</li> <li><code>int</code> or <code>float</code>, assumed as seconds</li> <li> <p><code>str</code>, following formats work:</p> <ul> <li><code>[-][DD ][HH:MM]SS[.ffffff]</code></li> <li><code>[\u00b1]P[DD]DT[HH]H[MM]M[SS]S</code> (ISO 8601 format for timedelta)</li> </ul> </li> </ul> </li> </ul> Python 3.7 and above <pre><code>from datetime import date, datetime, time, timedelta\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    d: date = None\n    dt: datetime = None\n    t: time = None\n    td: timedelta = None\n\n\nm = Model(\n    d=1966280412345.6789,\n    dt='2032-04-23T10:20:30.400+02:30',\n    t=time(4, 8, 16),\n    td='P3DT12H30M5S',\n)\n\nprint(m.dict())\n\"\"\"\n{\n    'd': datetime.date(2032, 4, 22),\n    'dt': datetime.datetime(2032, 4, 23, 10, 20, 30, 400000,\ntzinfo=datetime.timezone(datetime.timedelta(seconds=9000))),\n    't': datetime.time(4, 8, 16),\n    'td': datetime.timedelta(days=3, seconds=45005),\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#booleans","title":"Booleans","text":"<p>Warning</p> <p>The logic for parsing <code>bool</code> fields has changed as of version v1.0.</p> <p>Prior to v1.0, <code>bool</code> parsing never failed, leading to some unexpected results. The new logic is described below.</p> <p>A standard <code>bool</code> field will raise a <code>ValidationError</code> if the value is not one of the following:</p> <ul> <li>A valid boolean (i.e. <code>True</code> or <code>False</code>),</li> <li>The integers <code>0</code> or <code>1</code>,</li> <li>a <code>str</code> which when converted to lower case is one of   <code>'0', 'off', 'f', 'false', 'n', 'no', '1', 'on', 't', 'true', 'y', 'yes'</code></li> <li>a <code>bytes</code> which is valid (per the previous rule) when decoded to <code>str</code></li> </ul> <p>Note</p> <p>If you want stricter boolean logic (e.g. a field which only permits <code>True</code> and <code>False</code>) you can use <code>StrictBool</code>.</p> <p>Here is a script demonstrating some of these behaviors:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass BooleanModel(BaseModel):\n    bool_value: bool\n\n\nprint(BooleanModel(bool_value=False))\n#&gt; bool_value=False\nprint(BooleanModel(bool_value='False'))\n#&gt; bool_value=False\ntry:\n    BooleanModel(bool_value=[])\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for BooleanModel\n    bool_value\n      value could not be parsed to a boolean (type=type_error.bool)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#callable","title":"Callable","text":"<p>Fields can also be of type <code>Callable</code>:</p> Python 3.7 and abovePython 3.10 and above <pre><code>from typing import Callable\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    callback: Callable[[int], int]\n\n\nm = Foo(callback=lambda x: x)\nprint(m)\n#&gt; callback=&lt;function &lt;lambda&gt; at 0x7fa11209d990&gt;\n</code></pre> <pre><code>from collections.abc import Callable\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    callback: Callable[[int], int]\n\n\nm = Foo(callback=lambda x: x)\nprint(m)\n#&gt; callback=&lt;function &lt;lambda&gt; at 0x7fa11209dab0&gt;\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Warning</p> <p>Callable fields only perform a simple check that the argument is callable; no validation of arguments, their types, or the return type is performed.</p>"},{"location":"usage/types/#type","title":"Type","text":"<p>pydantic supports the use of <code>Type[T]</code> to specify that a field may only accept classes (not instances) that are subclasses of <code>T</code>.</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import Type\n\nfrom pydantic import BaseModel\nfrom pydantic import ValidationError\n\n\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n\n\nclass Other:\n    pass\n\n\nclass SimpleModel(BaseModel):\n    just_subclasses: Type[Foo]\n\n\nSimpleModel(just_subclasses=Foo)\nSimpleModel(just_subclasses=Bar)\ntry:\n    SimpleModel(just_subclasses=Other)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for SimpleModel\n    just_subclasses\n      subclass of Foo expected (type=type_error.subclass; expected_class=Foo)\n    \"\"\"\n</code></pre> <pre><code>from pydantic import BaseModel\nfrom pydantic import ValidationError\n\n\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n\n\nclass Other:\n    pass\n\n\nclass SimpleModel(BaseModel):\n    just_subclasses: type[Foo]\n\n\nSimpleModel(just_subclasses=Foo)\nSimpleModel(just_subclasses=Bar)\ntry:\n    SimpleModel(just_subclasses=Other)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for SimpleModel\n    just_subclasses\n      subclass of Foo expected (type=type_error.subclass; expected_class=Foo)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>You may also use <code>Type</code> to specify that any class is allowed.</p> Python 3.7 and above <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Foo:\n    pass\n\n\nclass LenientSimpleModel(BaseModel):\n    any_class_goes: Type\n\n\nLenientSimpleModel(any_class_goes=int)\nLenientSimpleModel(any_class_goes=Foo)\ntry:\n    LenientSimpleModel(any_class_goes=Foo())\nexcept ValidationError as e:\n    print(e)\n\n    \"\"\"\n    1 validation error for LenientSimpleModel\n    any_class_goes\n      a class is expected (type=type_error.class)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#typevar","title":"TypeVar","text":"<p><code>TypeVar</code> is supported either unconstrained, constrained or with a bound.</p> Python 3.7 and above <pre><code>from typing import TypeVar\nfrom pydantic import BaseModel\n\nFoobar = TypeVar('Foobar')\nBoundFloat = TypeVar('BoundFloat', bound=float)\nIntStr = TypeVar('IntStr', int, str)\n\n\nclass Model(BaseModel):\n    a: Foobar  # equivalent of \": Any\"\n    b: BoundFloat  # equivalent of \": float\"\n    c: IntStr  # equivalent of \": Union[int, str]\"\n\n\nprint(Model(a=[1], b=4.2, c='x'))\n#&gt; a=[1] b=4.2 c='x'\n\n# a may be None and is therefore optional\nprint(Model(b=1, c=1))\n#&gt; a=None b=1.0 c=1\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#literal-type","title":"Literal Type","text":"<p>Note</p> <p>This is a new feature of the Python standard library as of Python 3.8; prior to Python 3.8, it requires the typing-extensions package.</p> <p>pydantic supports the use of <code>typing.Literal</code> (or <code>typing_extensions.Literal</code> prior to Python 3.8) as a lightweight way to specify that a field may accept only specific literal values:</p> Python 3.7 and above <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Pie(BaseModel):\n    flavor: Literal['apple', 'pumpkin']\n\n\nPie(flavor='apple')\nPie(flavor='pumpkin')\ntry:\n    Pie(flavor='cherry')\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for Pie\n    flavor\n      unexpected value; permitted: 'apple', 'pumpkin'\n    (type=value_error.const; given=cherry; permitted=('apple', 'pumpkin'))\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>One benefit of this field type is that it can be used to check for equality with one or more specific values without needing to declare custom validators:</p> Python 3.7 and abovePython 3.9 and abovePython 3.10 and above <pre><code>from typing import ClassVar, List, Union\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Cake(BaseModel):\n    kind: Literal['cake']\n    required_utensils: ClassVar[List[str]] = ['fork', 'knife']\n\n\nclass IceCream(BaseModel):\n    kind: Literal['icecream']\n    required_utensils: ClassVar[List[str]] = ['spoon']\n\n\nclass Meal(BaseModel):\n    dessert: Union[Cake, IceCream]\n\n\nprint(type(Meal(dessert={'kind': 'cake'}).dessert).__name__)\n#&gt; Cake\nprint(type(Meal(dessert={'kind': 'icecream'}).dessert).__name__)\n#&gt; IceCream\ntry:\n    Meal(dessert={'kind': 'pie'})\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    2 validation errors for Meal\n    dessert -&gt; kind\n      unexpected value; permitted: 'cake' (type=value_error.const; given=pie;\n    permitted=('cake',))\n    dessert -&gt; kind\n      unexpected value; permitted: 'icecream' (type=value_error.const;\n    given=pie; permitted=('icecream',))\n    \"\"\"\n</code></pre> <pre><code>from typing import ClassVar, Union\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Cake(BaseModel):\n    kind: Literal['cake']\n    required_utensils: ClassVar[list[str]] = ['fork', 'knife']\n\n\nclass IceCream(BaseModel):\n    kind: Literal['icecream']\n    required_utensils: ClassVar[list[str]] = ['spoon']\n\n\nclass Meal(BaseModel):\n    dessert: Union[Cake, IceCream]\n\n\nprint(type(Meal(dessert={'kind': 'cake'}).dessert).__name__)\n#&gt; Cake\nprint(type(Meal(dessert={'kind': 'icecream'}).dessert).__name__)\n#&gt; IceCream\ntry:\n    Meal(dessert={'kind': 'pie'})\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    2 validation errors for Meal\n    dessert -&gt; kind\n      unexpected value; permitted: 'cake' (type=value_error.const; given=pie;\n    permitted=('cake',))\n    dessert -&gt; kind\n      unexpected value; permitted: 'icecream' (type=value_error.const;\n    given=pie; permitted=('icecream',))\n    \"\"\"\n</code></pre> <pre><code>from typing import ClassVar\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Cake(BaseModel):\n    kind: Literal['cake']\n    required_utensils: ClassVar[list[str]] = ['fork', 'knife']\n\n\nclass IceCream(BaseModel):\n    kind: Literal['icecream']\n    required_utensils: ClassVar[list[str]] = ['spoon']\n\n\nclass Meal(BaseModel):\n    dessert: Cake | IceCream\n\n\nprint(type(Meal(dessert={'kind': 'cake'}).dessert).__name__)\n#&gt; Cake\nprint(type(Meal(dessert={'kind': 'icecream'}).dessert).__name__)\n#&gt; IceCream\ntry:\n    Meal(dessert={'kind': 'pie'})\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    2 validation errors for Meal\n    dessert -&gt; kind\n      unexpected value; permitted: 'cake' (type=value_error.const; given=pie;\n    permitted=('cake',))\n    dessert -&gt; kind\n      unexpected value; permitted: 'icecream' (type=value_error.const;\n    given=pie; permitted=('icecream',))\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>With proper ordering in an annotated <code>Union</code>, you can use this to parse types of decreasing specificity:</p> Python 3.7 and abovePython 3.10 and above <pre><code>from typing import Optional, Union\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel\n\n\nclass Dessert(BaseModel):\n    kind: str\n\n\nclass Pie(Dessert):\n    kind: Literal['pie']\n    flavor: Optional[str]\n\n\nclass ApplePie(Pie):\n    flavor: Literal['apple']\n\n\nclass PumpkinPie(Pie):\n    flavor: Literal['pumpkin']\n\n\nclass Meal(BaseModel):\n    dessert: Union[ApplePie, PumpkinPie, Pie, Dessert]\n\n\nprint(type(Meal(dessert={'kind': 'pie', 'flavor': 'apple'}).dessert).__name__)\n#&gt; ApplePie\nprint(type(Meal(dessert={'kind': 'pie', 'flavor': 'pumpkin'}).dessert).__name__)\n#&gt; PumpkinPie\nprint(type(Meal(dessert={'kind': 'pie'}).dessert).__name__)\n#&gt; Pie\nprint(type(Meal(dessert={'kind': 'cake'}).dessert).__name__)\n#&gt; Dessert\n</code></pre> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel\n\n\nclass Dessert(BaseModel):\n    kind: str\n\n\nclass Pie(Dessert):\n    kind: Literal['pie']\n    flavor: str | None\n\n\nclass ApplePie(Pie):\n    flavor: Literal['apple']\n\n\nclass PumpkinPie(Pie):\n    flavor: Literal['pumpkin']\n\n\nclass Meal(BaseModel):\n    dessert: ApplePie | PumpkinPie | Pie | Dessert\n\n\nprint(type(Meal(dessert={'kind': 'pie', 'flavor': 'apple'}).dessert).__name__)\n#&gt; ApplePie\nprint(type(Meal(dessert={'kind': 'pie', 'flavor': 'pumpkin'}).dessert).__name__)\n#&gt; PumpkinPie\nprint(type(Meal(dessert={'kind': 'pie'}).dessert).__name__)\n#&gt; Pie\nprint(type(Meal(dessert={'kind': 'cake'}).dessert).__name__)\n#&gt; Dessert\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#annotated-types","title":"Annotated Types","text":""},{"location":"usage/types/#namedtuple","title":"NamedTuple","text":"Python 3.7 and above <pre><code>from typing import NamedTuple\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Point(NamedTuple):\n    x: int\n    y: int\n\n\nclass Model(BaseModel):\n    p: Point\n\n\nprint(Model(p=('1', '2')))\n#&gt; p=Point(x=1, y=2)\n\ntry:\n    Model(p=('1.3', '2'))\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    p -&gt; x\n      value is not a valid integer (type=type_error.integer)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#typeddict","title":"TypedDict","text":"<p>Note</p> <p>This is a new feature of the Python standard library as of Python 3.8. Prior to Python 3.8, it requires the typing-extensions package. But required and optional fields are properly differentiated only since Python 3.9. We therefore recommend using typing-extensions with Python 3.8 as well.</p> Python 3.7 and above <pre><code>from typing_extensions import TypedDict\n\nfrom pydantic import BaseModel, Extra, ValidationError\n\n\n# `total=False` means keys are non-required\nclass UserIdentity(TypedDict, total=False):\n    name: str\n    surname: str\n\n\nclass User(TypedDict):\n    identity: UserIdentity\n    age: int\n\n\nclass Model(BaseModel):\n    u: User\n\n    class Config:\n        extra = Extra.forbid\n\n\nprint(Model(u={'identity': {'name': 'Smith', 'surname': 'John'}, 'age': '37'}))\n#&gt; u={'identity': {'name': 'Smith', 'surname': 'John'}, 'age': 37}\n\nprint(Model(u={'identity': {'name': None, 'surname': 'John'}, 'age': '37'}))\n#&gt; u={'identity': {'name': None, 'surname': 'John'}, 'age': 37}\n\nprint(Model(u={'identity': {}, 'age': '37'}))\n#&gt; u={'identity': {}, 'age': 37}\n\n\ntry:\n    Model(u={'identity': {'name': ['Smith'], 'surname': 'John'}, 'age': '24'})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    u -&gt; identity -&gt; name\n      str type expected (type=type_error.str)\n    \"\"\"\n\ntry:\n    Model(\n        u={\n            'identity': {'name': 'Smith', 'surname': 'John'},\n            'age': '37',\n            'email': 'john.smith@me.com',\n        }\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    u -&gt; email\n      extra fields not permitted (type=value_error.extra)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#pydantic-types","title":"Pydantic Types","text":"<p>pydantic also provides a variety of other useful types:</p> <code>FilePath</code> like <code>Path</code>, but the path must exist and be a file <code>DirectoryPath</code> like <code>Path</code>, but the path must exist and be a directory <code>PastDate</code> like <code>date</code>, but the date should be in the past <code>FutureDate</code> like <code>date</code>, but the date should be in the future <code>EmailStr</code> requires email-validator to be installed; the input string must be a valid email address, and the output is a simple string <code>NameEmail</code> requires email-validator to be installed; the input string must be either a valid email address or in the format <code>Fred Bloggs &lt;fred.bloggs@example.com&gt;</code>, and the output is a <code>NameEmail</code> object which has two properties: <code>name</code> and <code>email</code>. For <code>Fred Bloggs &lt;fred.bloggs@example.com&gt;</code> the name would be <code>\"Fred Bloggs\"</code>; for <code>fred.bloggs@example.com</code> it would be <code>\"fred.bloggs\"</code>. <code>PyObject</code> expects a string and loads the Python object importable at that dotted path; e.g. if <code>'math.cos'</code> was provided, the resulting field value would be the function <code>cos</code> <code>Color</code> for parsing HTML and CSS colors; see Color Type <code>Json</code> a special type wrapper which loads JSON before parsing; see JSON Type <code>PaymentCardNumber</code> for parsing and validating payment cards; see payment cards <code>AnyUrl</code> any URL; see URLs <code>AnyHttpUrl</code> an HTTP URL; see URLs <code>HttpUrl</code> a stricter HTTP URL; see URLs <code>FileUrl</code> a file path URL; see URLs <code>PostgresDsn</code> a postgres DSN style URL; see URLs <code>CockroachDsn</code> a cockroachdb DSN style URL; see URLs <code>AmqpDsn</code> an <code>AMQP</code> DSN style URL as used by RabbitMQ, StormMQ, ActiveMQ etc.; see URLs <code>RedisDsn</code> a redis DSN style URL; see URLs <code>MongoDsn</code> a MongoDB DSN style URL; see URLs <code>KafkaDsn</code> a kafka DSN style URL; see URLs <code>stricturl</code> a type method for arbitrary URL constraints; see URLs <code>UUID1</code> requires a valid UUID of type 1; see <code>UUID</code> above <code>UUID3</code> requires a valid UUID of type 3; see <code>UUID</code> above <code>UUID4</code> requires a valid UUID of type 4; see <code>UUID</code> above <code>UUID5</code> requires a valid UUID of type 5; see <code>UUID</code> above <code>SecretBytes</code> bytes where the value is kept partially secret; see Secrets <code>SecretStr</code> string where the value is kept partially secret; see Secrets <code>IPvAnyAddress</code> allows either an <code>IPv4Address</code> or an <code>IPv6Address</code> <code>IPvAnyInterface</code> allows either an <code>IPv4Interface</code> or an <code>IPv6Interface</code> <code>IPvAnyNetwork</code> allows either an <code>IPv4Network</code> or an <code>IPv6Network</code> <code>NegativeFloat</code> allows a float which is negative; uses standard <code>float</code> parsing then checks the value is less than 0; see Constrained Types <code>NegativeInt</code> allows an int which is negative; uses standard <code>int</code> parsing then checks the value is less than 0; see Constrained Types <code>PositiveFloat</code> allows a float which is positive; uses standard <code>float</code> parsing then checks the value is greater than 0; see Constrained Types <code>PositiveInt</code> allows an int which is positive; uses standard <code>int</code> parsing then checks the value is greater than 0; see Constrained Types <code>conbytes</code> type method for constraining bytes; see Constrained Types <code>condecimal</code> type method for constraining Decimals; see Constrained Types <code>confloat</code> type method for constraining floats; see Constrained Types <code>conint</code> type method for constraining ints; see Constrained Types <code>condate</code> type method for constraining dates; see Constrained Types <code>conlist</code> type method for constraining lists; see Constrained Types <code>conset</code> type method for constraining sets; see Constrained Types <code>confrozenset</code> type method for constraining frozen sets; see Constrained Types <code>constr</code> type method for constraining strs; see Constrained Types"},{"location":"usage/types/#urls","title":"URLs","text":"<p>For URI/URL validation the following types are available:</p> <ul> <li><code>AnyUrl</code>: any scheme allowed, TLD not required, host required</li> <li><code>AnyHttpUrl</code>: scheme <code>http</code> or <code>https</code>, TLD not required, host required</li> <li><code>HttpUrl</code>: scheme <code>http</code> or <code>https</code>, TLD required, host required, max length 2083</li> <li><code>FileUrl</code>: scheme <code>file</code>, host not required</li> <li><code>PostgresDsn</code>: user info required, TLD not required, host required,   as of V.10 <code>PostgresDsn</code> supports multiple hosts. The following schemes are supported:<ul> <li><code>postgres</code></li> <li><code>postgresql</code></li> <li><code>postgresql+asyncpg</code></li> <li><code>postgresql+pg8000</code></li> <li><code>postgresql+psycopg</code></li> <li><code>postgresql+psycopg2</code></li> <li><code>postgresql+psycopg2cffi</code></li> <li><code>postgresql+py-postgresql</code></li> <li><code>postgresql+pygresql</code></li> </ul> </li> <li><code>CockroachDsn</code>: scheme <code>cockroachdb</code>, user info required, TLD not required, host required. Also, its supported DBAPI dialects:<ul> <li><code>cockroachdb+asyncpg</code></li> <li><code>cockroachdb+psycopg2</code></li> </ul> </li> <li><code>AmqpDsn</code>: schema <code>amqp</code> or <code>amqps</code>, user info not required, TLD not required, host not required</li> <li><code>RedisDsn</code>: scheme <code>redis</code> or <code>rediss</code>, user info not required, tld not required, host not required (CHANGED: user info) (e.g., <code>rediss://:pass@localhost</code>)</li> <li><code>MongoDsn</code> : scheme <code>mongodb</code>, user info not required, database name not required, port   not required from v1.6 onwards), user info may be passed without user part (e.g., <code>mongodb://mongodb0.example.com:27017</code>)</li> <li><code>stricturl</code>: method with the following keyword arguments:     - <code>strip_whitespace: bool = True</code>     - <code>min_length: int = 1</code>     - <code>max_length: int = 2 ** 16</code>     - <code>tld_required: bool = True</code>     - <code>host_required: bool = True</code>     - <code>allowed_schemes: Optional[Set[str]] = None</code></li> </ul> <p>Warning</p> <p>In V1.10.0 and v1.10.1 <code>stricturl</code> also took an optional <code>quote_plus</code> argument and URL components were percent encoded in some cases. This feature was removed in v1.10.2, see  #4470 for explanation and more details.</p> <p>The above types (which all inherit from <code>AnyUrl</code>) will attempt to give descriptive errors when invalid URLs are provided:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\n\nm = MyModel(url='http://www.example.com')\nprint(m.url)\n#&gt; http://www.example.com\n\ntry:\n    MyModel(url='ftp://invalid.url')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for MyModel\n    url\n      URL scheme not permitted (type=value_error.url.scheme;\n    allowed_schemes={'https', 'http'})\n    \"\"\"\n\ntry:\n    MyModel(url='not a url')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for MyModel\n    url\n      invalid or missing URL scheme (type=value_error.url.scheme)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>If you require a custom URI/URL type, it can be created in a similar way to the types defined above.</p>"},{"location":"usage/types/#url-properties","title":"URL Properties","text":"<p>Assuming an input URL of <code>http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit</code>, the above types export the following properties:</p> <ul> <li><code>scheme</code>: always set - the url scheme (<code>http</code> above)</li> <li><code>host</code>: always set - the url host (<code>example.com</code> above)</li> <li> <p><code>host_type</code>: always set - describes the type of host, either:</p> <ul> <li><code>domain</code>: e.g. <code>example.com</code>,</li> <li><code>int_domain</code>: international domain, see below, e.g. <code>exampl\u00a3e.org</code>,</li> <li><code>ipv4</code>: an IP V4 address, e.g. <code>127.0.0.1</code>, or</li> <li><code>ipv6</code>: an IP V6 address, e.g. <code>2001:db8:ff00:42</code></li> </ul> </li> </ul> <ul> <li><code>user</code>: optional - the username if included (<code>samuel</code> above)</li> <li><code>password</code>: optional - the password if included (<code>pass</code> above)</li> <li><code>tld</code>: optional - the top level domain (<code>com</code> above),   Note: this will be wrong for any two-level domain, e.g. \"co.uk\". You'll need to implement your own list of TLDs   if you require full TLD validation</li> <li><code>port</code>: optional - the port (<code>8000</code> above)</li> <li><code>path</code>: optional - the path (<code>/the/path/</code> above)</li> <li><code>query</code>: optional - the URL query (aka GET arguments or \"search string\") (<code>query=here</code> above)</li> <li><code>fragment</code>: optional - the fragment (<code>fragment=is;this=bit</code> above)</li> </ul> <p>If further validation is required, these properties can be used by validators to enforce specific behaviour:</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, HttpUrl, PostgresDsn, ValidationError, validator\n\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\n\nm = MyModel(url='http://www.example.com')\n\n# the repr() method for a url will display all properties of the url\nprint(repr(m.url))\n#&gt; HttpUrl('http://www.example.com', )\nprint(m.url.scheme)\n#&gt; http\nprint(m.url.host)\n#&gt; www.example.com\nprint(m.url.host_type)\n#&gt; domain\nprint(m.url.port)\n#&gt; 80\n\n\nclass MyDatabaseModel(BaseModel):\n    db: PostgresDsn\n\n    @validator('db')\n    def check_db_name(cls, v):\n        assert v.path and len(v.path) &gt; 1, 'database must be provided'\n        return v\n\n\nm = MyDatabaseModel(db='postgres://user:pass@localhost:5432/foobar')\nprint(m.db)\n#&gt; postgres://user:pass@localhost:5432/foobar\n\ntry:\n    MyDatabaseModel(db='postgres://user:pass@localhost:5432')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for MyDatabaseModel\n    db\n      database must be provided (type=assertion_error)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#international-domains","title":"International Domains","text":"<p>\"International domains\" (e.g. a URL where the host or TLD includes non-ascii characters) will be encoded via punycode (see this article for a good description of why this is important):</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, HttpUrl\n\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\n\nm1 = MyModel(url='http://puny\u00a3code.com')\nprint(m1.url)\n#&gt; http://xn--punycode-eja.com\nprint(m1.url.host_type)\n#&gt; int_domain\nm2 = MyModel(url='https://www.\u0430\u0440\u0440\u04cf\u0435.com/')\nprint(m2.url)\n#&gt; https://www.xn--80ak6aa92e.com/\nprint(m2.url.host_type)\n#&gt; int_domain\nm3 = MyModel(url='https://www.example.\u73e0\u5b9d/')\nprint(m3.url)\n#&gt; https://www.example.xn--pbt977c/\nprint(m3.url.host_type)\n#&gt; int_domain\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Warning</p>"},{"location":"usage/types/#underscores-in-hostnames","title":"Underscores in Hostnames","text":"<p>In pydantic underscores are allowed in all parts of a domain except the tld. Technically this might be wrong - in theory the hostname cannot have underscores, but subdomains can.</p> <p>To explain this; consider the following two cases:</p> <ul> <li><code>exam_ple.co.uk</code>: the hostname is <code>exam_ple</code>, which should not be allowed since it contains an underscore</li> <li><code>foo_bar.example.com</code> the hostname is <code>example</code>, which should be allowed since the underscore is in the subdomain</li> </ul> <p>Without having an exhaustive list of TLDs, it would be impossible to differentiate between these two. Therefore underscores are allowed, but you can always do further validation in a validator if desired.</p> <p>Also, Chrome, Firefox, and Safari all currently accept <code>http://exam_ple.com</code> as a URL, so we're in good (or at least big) company.</p>"},{"location":"usage/types/#color-type","title":"Color Type","text":"<p>You can use the <code>Color</code> data type for storing colors as per CSS3 specification. Colors can be defined via:</p> <ul> <li>name (e.g. <code>\"Black\"</code>, <code>\"azure\"</code>)</li> <li>hexadecimal value   (e.g. <code>\"0x000\"</code>, <code>\"#FFFFFF\"</code>, <code>\"7fffd4\"</code>)</li> <li>RGB/RGBA tuples (e.g. <code>(255, 255, 255)</code>, <code>(255, 255, 255, 0.5)</code>)</li> <li>RGB/RGBA strings   (e.g. <code>\"rgb(255, 255, 255)\"</code>, <code>\"rgba(255, 255, 255, 0.5)\"</code>)</li> <li>HSL strings   (e.g. <code>\"hsl(270, 60%, 70%)\"</code>, <code>\"hsl(270, 60%, 70%, .5)\"</code>)</li> </ul> Python 3.7 and above <pre><code>from pydantic import BaseModel, ValidationError\nfrom pydantic.color import Color\n\nc = Color('ff00ff')\nprint(c.as_named())\n#&gt; magenta\nprint(c.as_hex())\n#&gt; #f0f\nc2 = Color('green')\nprint(c2.as_rgb_tuple())\n#&gt; (0, 128, 0)\nprint(c2.original())\n#&gt; green\nprint(repr(Color('hsl(180, 100%, 50%)')))\n#&gt; Color('cyan', rgb=(0, 255, 255))\n\n\nclass Model(BaseModel):\n    color: Color\n\n\nprint(Model(color='purple'))\n#&gt; color=Color('purple', rgb=(128, 0, 128))\ntry:\n    Model(color='hello')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    color\n      value is not a valid color: string not recognised as a valid color\n    (type=value_error.color; reason=string not recognised as a valid color)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p><code>Color</code> has the following methods:</p> <code>original</code> the original string or tuple passed to <code>Color</code> <code>as_named</code> returns a named CSS3 color; fails if the alpha channel is set or no such color exists unless <code>fallback=True</code> is supplied, in which case it falls back to <code>as_hex</code> <code>as_hex</code> returns a string in the format <code>#fff</code> or <code>#ffffff</code>; will contain 4 (or 8) hex values if the alpha channel is set, e.g. <code>#7f33cc26</code> <code>as_rgb</code> returns a string in the format <code>rgb(&lt;red&gt;, &lt;green&gt;, &lt;blue&gt;)</code>, or <code>rgba(&lt;red&gt;, &lt;green&gt;, &lt;blue&gt;, &lt;alpha&gt;)</code> if the alpha channel is set <code>as_rgb_tuple</code> returns a 3- or 4-tuple in RGB(a) format. The <code>alpha</code> keyword argument can be used to define whether the alpha channel should be included; options: <code>True</code> - always include, <code>False</code> - never include, <code>None</code> (default) - include if set <code>as_hsl</code> string in the format <code>hsl(&lt;hue deg&gt;, &lt;saturation %&gt;, &lt;lightness %&gt;)</code> or <code>hsl(&lt;hue deg&gt;, &lt;saturation %&gt;, &lt;lightness %&gt;, &lt;alpha&gt;)</code> if the alpha channel is set <code>as_hsl_tuple</code> returns a 3- or 4-tuple in HSL(a) format. The <code>alpha</code> keyword argument can be used to define whether the alpha channel should be included; options: <code>True</code> - always include, <code>False</code> - never include, <code>None</code> (the default)  - include if set <p>The <code>__str__</code> method for <code>Color</code> returns <code>self.as_named(fallback=True)</code>.</p> <p>Note</p> <p>the <code>as_hsl*</code> refer to hue, saturation, lightness \"HSL\" as used in html and most of the world, not \"HLS\" as used in Python's <code>colorsys</code>.</p>"},{"location":"usage/types/#secret-types","title":"Secret Types","text":"<p>You can use the <code>SecretStr</code> and the <code>SecretBytes</code> data types for storing sensitive information that you do not want to be visible in logging or tracebacks. <code>SecretStr</code> and <code>SecretBytes</code> can be initialized idempotently or by using <code>str</code> or <code>bytes</code> literals respectively. The <code>SecretStr</code> and <code>SecretBytes</code> will be formatted as either <code>'**********'</code> or <code>''</code> on conversion to json.</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, SecretStr, SecretBytes, ValidationError\n\n\nclass SimpleModel(BaseModel):\n    password: SecretStr\n    password_bytes: SecretBytes\n\n\nsm = SimpleModel(password='IAmSensitive', password_bytes=b'IAmSensitiveBytes')\n\n# Standard access methods will not display the secret\nprint(sm)\n#&gt; password=SecretStr('**********') password_bytes=SecretBytes(b'**********')\nprint(sm.password)\n#&gt; **********\nprint(sm.dict())\n\"\"\"\n{\n    'password': SecretStr('**********'),\n    'password_bytes': SecretBytes(b'**********'),\n}\n\"\"\"\nprint(sm.json())\n#&gt; {\"password\": \"**********\", \"password_bytes\": \"**********\"}\n\n# Use get_secret_value method to see the secret's content.\nprint(sm.password.get_secret_value())\n#&gt; IAmSensitive\nprint(sm.password_bytes.get_secret_value())\n#&gt; b'IAmSensitiveBytes'\n\ntry:\n    SimpleModel(password=[1, 2, 3], password_bytes=[1, 2, 3])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for SimpleModel\n    password\n      str type expected (type=type_error.str)\n    password_bytes\n      byte type expected (type=type_error.bytes)\n    \"\"\"\n\n\n# If you want the secret to be dumped as plain-text using the json method,\n# you can use json_encoders in the Config class.\nclass SimpleModelDumpable(BaseModel):\n    password: SecretStr\n    password_bytes: SecretBytes\n\n    class Config:\n        json_encoders = {\n            SecretStr: lambda v: v.get_secret_value() if v else None,\n            SecretBytes: lambda v: v.get_secret_value() if v else None,\n        }\n\n\nsm2 = SimpleModelDumpable(\n    password='IAmSensitive', password_bytes=b'IAmSensitiveBytes'\n)\n\n# Standard access methods will not display the secret\nprint(sm2)\n#&gt; password=SecretStr('**********') password_bytes=SecretBytes(b'**********')\nprint(sm2.password)\n#&gt; **********\nprint(sm2.dict())\n\"\"\"\n{\n    'password': SecretStr('**********'),\n    'password_bytes': SecretBytes(b'**********'),\n}\n\"\"\"\n\n# But the json method will\nprint(sm2.json())\n#&gt; {\"password\": \"IAmSensitive\", \"password_bytes\": \"IAmSensitiveBytes\"}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#json-type","title":"Json Type","text":"<p>You can use <code>Json</code> data type to make pydantic first load a raw JSON string. It can also optionally be used to parse the loaded object into another type base on the type <code>Json</code> is parameterised with:</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import Any, List\n\nfrom pydantic import BaseModel, Json, ValidationError\n\n\nclass AnyJsonModel(BaseModel):\n    json_obj: Json[Any]\n\n\nclass ConstrainedJsonModel(BaseModel):\n    json_obj: Json[List[int]]\n\n\nprint(AnyJsonModel(json_obj='{\"b\": 1}'))\n#&gt; json_obj={'b': 1}\nprint(ConstrainedJsonModel(json_obj='[1, 2, 3]'))\n#&gt; json_obj=[1, 2, 3]\ntry:\n    ConstrainedJsonModel(json_obj=12)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for ConstrainedJsonModel\n    json_obj\n      JSON object must be str, bytes or bytearray (type=type_error.json)\n    \"\"\"\n\ntry:\n    ConstrainedJsonModel(json_obj='[a, b]')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for ConstrainedJsonModel\n    json_obj\n      Invalid JSON (type=value_error.json)\n    \"\"\"\n\ntry:\n    ConstrainedJsonModel(json_obj='[\"a\", \"b\"]')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for ConstrainedJsonModel\n    json_obj -&gt; 0\n      value is not a valid integer (type=type_error.integer)\n    json_obj -&gt; 1\n      value is not a valid integer (type=type_error.integer)\n    \"\"\"\n</code></pre> <pre><code>from typing import Any\n\nfrom pydantic import BaseModel, Json, ValidationError\n\n\nclass AnyJsonModel(BaseModel):\n    json_obj: Json[Any]\n\n\nclass ConstrainedJsonModel(BaseModel):\n    json_obj: Json[list[int]]\n\n\nprint(AnyJsonModel(json_obj='{\"b\": 1}'))\n#&gt; json_obj={'b': 1}\nprint(ConstrainedJsonModel(json_obj='[1, 2, 3]'))\n#&gt; json_obj=[1, 2, 3]\ntry:\n    ConstrainedJsonModel(json_obj=12)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for ConstrainedJsonModel\n    json_obj\n      JSON object must be str, bytes or bytearray (type=type_error.json)\n    \"\"\"\n\ntry:\n    ConstrainedJsonModel(json_obj='[a, b]')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for ConstrainedJsonModel\n    json_obj\n      Invalid JSON (type=value_error.json)\n    \"\"\"\n\ntry:\n    ConstrainedJsonModel(json_obj='[\"a\", \"b\"]')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for ConstrainedJsonModel\n    json_obj -&gt; 0\n      value is not a valid integer (type=type_error.integer)\n    json_obj -&gt; 1\n      value is not a valid integer (type=type_error.integer)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#payment-card-numbers","title":"Payment Card Numbers","text":"<p>The <code>PaymentCardNumber</code> type validates payment cards (such as a debit or credit card).</p> Python 3.7 and above <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\nfrom pydantic.types import PaymentCardBrand, PaymentCardNumber, constr\n\n\nclass Card(BaseModel):\n    name: constr(strip_whitespace=True, min_length=1)\n    number: PaymentCardNumber\n    exp: date\n\n    @property\n    def brand(self) -&gt; PaymentCardBrand:\n        return self.number.brand\n\n    @property\n    def expired(self) -&gt; bool:\n        return self.exp &lt; date.today()\n\n\ncard = Card(\n    name='Georg Wilhelm Friedrich Hegel',\n    number='4000000000000002',\n    exp=date(2023, 9, 30),\n)\n\nassert card.number.brand == PaymentCardBrand.visa\nassert card.number.bin == '400000'\nassert card.number.last4 == '0002'\nassert card.number.masked == '400000******0002'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p><code>PaymentCardBrand</code> can be one of the following based on the BIN:</p> <ul> <li><code>PaymentCardBrand.amex</code></li> <li><code>PaymentCardBrand.mastercard</code></li> <li><code>PaymentCardBrand.visa</code></li> <li><code>PaymentCardBrand.other</code></li> </ul> <p>The actual validation verifies the card number is:</p> <ul> <li>a <code>str</code> of only digits</li> <li>luhn valid</li> <li>the correct length based on the BIN, if Amex, Mastercard or Visa, and between   12 and 19 digits for all other brands</li> </ul>"},{"location":"usage/types/#constrained-types","title":"Constrained Types","text":"<p>The value of numerous common types can be restricted using <code>con*</code> type functions:</p> Python 3.7 and above <pre><code>from decimal import Decimal\n\nfrom pydantic import (\n    BaseModel,\n    NegativeFloat,\n    NegativeInt,\n    PositiveFloat,\n    PositiveInt,\n    NonNegativeFloat,\n    NonNegativeInt,\n    NonPositiveFloat,\n    NonPositiveInt,\n    conbytes,\n    condecimal,\n    confloat,\n    conint,\n    conlist,\n    conset,\n    constr,\n    Field,\n)\n\n\nclass Model(BaseModel):\n    upper_bytes: conbytes(to_upper=True)\n    lower_bytes: conbytes(to_lower=True)\n    short_bytes: conbytes(min_length=2, max_length=10)\n    strip_bytes: conbytes(strip_whitespace=True)\n\n    upper_str: constr(to_upper=True)\n    lower_str: constr(to_lower=True)\n    short_str: constr(min_length=2, max_length=10)\n    regex_str: constr(regex=r'^apple (pie|tart|sandwich)$')\n    strip_str: constr(strip_whitespace=True)\n\n    big_int: conint(gt=1000, lt=1024)\n    mod_int: conint(multiple_of=5)\n    pos_int: PositiveInt\n    neg_int: NegativeInt\n    non_neg_int: NonNegativeInt\n    non_pos_int: NonPositiveInt\n\n    big_float: confloat(gt=1000, lt=1024)\n    unit_interval: confloat(ge=0, le=1)\n    mod_float: confloat(multiple_of=0.5)\n    pos_float: PositiveFloat\n    neg_float: NegativeFloat\n    non_neg_float: NonNegativeFloat\n    non_pos_float: NonPositiveFloat\n\n    short_list: conlist(int, min_items=1, max_items=4)\n    short_set: conset(int, min_items=1, max_items=4)\n\n    decimal_positive: condecimal(gt=0)\n    decimal_negative: condecimal(lt=0)\n    decimal_max_digits_and_places: condecimal(max_digits=2, decimal_places=2)\n    mod_decimal: condecimal(multiple_of=Decimal('0.25'))\n\n    bigger_int: int = Field(..., gt=10000)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Where <code>Field</code> refers to the field function.</p>"},{"location":"usage/types/#arguments-to-conlist","title":"Arguments to <code>conlist</code>","text":"<p>The following arguments are available when using the <code>conlist</code> type function</p> <ul> <li><code>item_type: Type[T]</code>: type of the list items</li> <li><code>min_items: int = None</code>: minimum number of items in the list</li> <li><code>max_items: int = None</code>: maximum number of items in the list</li> <li><code>unique_items: bool = None</code>: enforces list elements to be unique</li> </ul>"},{"location":"usage/types/#arguments-to-conset","title":"Arguments to <code>conset</code>","text":"<p>The following arguments are available when using the <code>conset</code> type function</p> <ul> <li><code>item_type: Type[T]</code>: type of the set items</li> <li><code>min_items: int = None</code>: minimum number of items in the set</li> <li><code>max_items: int = None</code>: maximum number of items in the set</li> </ul>"},{"location":"usage/types/#arguments-to-confrozenset","title":"Arguments to <code>confrozenset</code>","text":"<p>The following arguments are available when using the <code>confrozenset</code> type function</p> <ul> <li><code>item_type: Type[T]</code>: type of the frozenset items</li> <li><code>min_items: int = None</code>: minimum number of items in the frozenset</li> <li><code>max_items: int = None</code>: maximum number of items in the frozenset</li> </ul>"},{"location":"usage/types/#arguments-to-conint","title":"Arguments to <code>conint</code>","text":"<p>The following arguments are available when using the <code>conint</code> type function</p> <ul> <li><code>strict: bool = False</code>: controls type coercion</li> <li><code>gt: int = None</code>: enforces integer to be greater than the set value</li> <li><code>ge: int = None</code>: enforces integer to be greater than or equal to the set value</li> <li><code>lt: int = None</code>: enforces integer to be less than the set value</li> <li><code>le: int = None</code>: enforces integer to be less than or equal to the set value</li> <li><code>multiple_of: int = None</code>: enforces integer to be a multiple of the set value</li> </ul>"},{"location":"usage/types/#arguments-to-confloat","title":"Arguments to <code>confloat</code>","text":"<p>The following arguments are available when using the <code>confloat</code> type function</p> <ul> <li><code>strict: bool = False</code>: controls type coercion</li> <li><code>gt: float = None</code>: enforces float to be greater than the set value</li> <li><code>ge: float = None</code>: enforces float to be greater than or equal to the set value</li> <li><code>lt: float = None</code>: enforces float to be less than the set value</li> <li><code>le: float = None</code>: enforces float to be less than or equal to the set value</li> <li><code>multiple_of: float = None</code>: enforces float to be a multiple of the set value</li> <li><code>allow_inf_nan: bool = True</code>: whether to allows infinity (<code>+inf</code> an <code>-inf</code>) and NaN values, defaults to <code>True</code>,   set to <code>False</code> for compatibility with <code>JSON</code>,   see #3994 for more details, added in V1.10</li> </ul>"},{"location":"usage/types/#arguments-to-condecimal","title":"Arguments to <code>condecimal</code>","text":"<p>The following arguments are available when using the <code>condecimal</code> type function</p> <ul> <li><code>gt: Decimal = None</code>: enforces decimal to be greater than the set value</li> <li><code>ge: Decimal = None</code>: enforces decimal to be greater than or equal to the set value</li> <li><code>lt: Decimal = None</code>: enforces decimal to be less than the set value</li> <li><code>le: Decimal = None</code>: enforces decimal to be less than or equal to the set value</li> <li><code>max_digits: int = None</code>: maximum number of digits within the decimal. it does not include a zero before the decimal point or trailing decimal zeroes</li> <li><code>decimal_places: int = None</code>: max number of decimal places allowed. it does not include trailing decimal zeroes</li> <li><code>multiple_of: Decimal = None</code>: enforces decimal to be a multiple of the set value</li> </ul>"},{"location":"usage/types/#arguments-to-constr","title":"Arguments to <code>constr</code>","text":"<p>The following arguments are available when using the <code>constr</code> type function</p> <ul> <li><code>strip_whitespace: bool = False</code>: removes leading and trailing whitespace</li> <li><code>to_upper: bool = False</code>: turns all characters to uppercase</li> <li><code>to_lower: bool = False</code>: turns all characters to lowercase</li> <li><code>strict: bool = False</code>: controls type coercion</li> <li><code>min_length: int = None</code>: minimum length of the string</li> <li><code>max_length: int = None</code>: maximum length of the string</li> <li><code>curtail_length: int = None</code>: shrinks the string length to the set value when it is longer than the set value</li> <li><code>regex: str = None</code>: regex to validate the string against</li> </ul>"},{"location":"usage/types/#arguments-to-conbytes","title":"Arguments to <code>conbytes</code>","text":"<p>The following arguments are available when using the <code>conbytes</code> type function</p> <ul> <li><code>strip_whitespace: bool = False</code>: removes leading and trailing whitespace</li> <li><code>to_upper: bool = False</code>: turns all characters to uppercase</li> <li><code>to_lower: bool = False</code>: turns all characters to lowercase</li> <li><code>min_length: int = None</code>: minimum length of the byte string</li> <li><code>max_length: int = None</code>: maximum length of the byte string</li> <li><code>strict: bool = False</code>: controls type coercion</li> </ul>"},{"location":"usage/types/#arguments-to-condate","title":"Arguments to <code>condate</code>","text":"<p>The following arguments are available when using the <code>condate</code> type function</p> <ul> <li><code>gt: date = None</code>: enforces date to be greater than the set value</li> <li><code>ge: date = None</code>: enforces date to be greater than or equal to the set value</li> <li><code>lt: date = None</code>: enforces date to be less than the set value</li> <li><code>le: date = None</code>: enforces date to be less than or equal to the set value</li> </ul>"},{"location":"usage/types/#strict-types","title":"Strict Types","text":"<p>You can use the <code>StrictStr</code>, <code>StrictBytes</code>, <code>StrictInt</code>, <code>StrictFloat</code>, and <code>StrictBool</code> types to prevent coercion from compatible types. These types will only pass validation when the validated value is of the respective type or is a subtype of that type. This behavior is also exposed via the <code>strict</code> field of the <code>ConstrainedStr</code>, <code>ConstrainedBytes</code>, <code>ConstrainedFloat</code> and <code>ConstrainedInt</code> classes and can be combined with a multitude of complex validation rules.</p> <p>The following caveats apply:</p> <ul> <li><code>StrictBytes</code> (and the <code>strict</code> option of <code>ConstrainedBytes</code>) will accept both <code>bytes</code>,    and <code>bytearray</code> types.</li> <li><code>StrictInt</code> (and the <code>strict</code> option of <code>ConstrainedInt</code>) will not accept <code>bool</code> types,     even though <code>bool</code> is a subclass of <code>int</code> in Python. Other subclasses will work.</li> <li><code>StrictFloat</code> (and the <code>strict</code> option of <code>ConstrainedFloat</code>) will not accept <code>int</code>.</li> </ul> Python 3.7 and above <pre><code>from pydantic import (\n    BaseModel,\n    StrictBytes,\n    StrictBool,\n    StrictInt,\n    ValidationError,\n    confloat,\n)\n\n\nclass StrictBytesModel(BaseModel):\n    strict_bytes: StrictBytes\n\n\ntry:\n    StrictBytesModel(strict_bytes='hello world')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for StrictBytesModel\n    strict_bytes\n      byte type expected (type=type_error.bytes)\n    \"\"\"\n\n\nclass StrictIntModel(BaseModel):\n    strict_int: StrictInt\n\n\ntry:\n    StrictIntModel(strict_int=3.14159)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for StrictIntModel\n    strict_int\n      value is not a valid integer (type=type_error.integer)\n    \"\"\"\n\n\nclass ConstrainedFloatModel(BaseModel):\n    constrained_float: confloat(strict=True, ge=0.0)\n\n\ntry:\n    ConstrainedFloatModel(constrained_float=3)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for ConstrainedFloatModel\n    constrained_float\n      value is not a valid float (type=type_error.float)\n    \"\"\"\n\ntry:\n    ConstrainedFloatModel(constrained_float=-1.23)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for ConstrainedFloatModel\n    constrained_float\n      ensure this value is greater than or equal to 0.0\n    (type=value_error.number.not_ge; limit_value=0.0)\n    \"\"\"\n\n\nclass StrictBoolModel(BaseModel):\n    strict_bool: StrictBool\n\n\ntry:\n    StrictBoolModel(strict_bool='False')\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for StrictBoolModel\n    strict_bool\n      value is not a valid boolean (type=value_error.strictbool)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#bytesize","title":"ByteSize","text":"<p>You can use the <code>ByteSize</code> data type to convert byte string representation to raw bytes and print out human readable versions of the bytes as well.</p> <p>Info</p> <p>Note that <code>1b</code> will be parsed as \"1 byte\" and not \"1 bit\".</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, ByteSize\n\n\nclass MyModel(BaseModel):\n    size: ByteSize\n\n\nprint(MyModel(size=52000).size)\n#&gt; 52000\nprint(MyModel(size='3000 KiB').size)\n#&gt; 3072000\n\nm = MyModel(size='50 PB')\nprint(m.size.human_readable())\n#&gt; 44.4PiB\nprint(m.size.human_readable(decimal=True))\n#&gt; 50.0PB\n\nprint(m.size.to('TiB'))\n#&gt; 45474.73508864641\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#custom-data-types","title":"Custom Data Types","text":"<p>You can also define your own custom data types. There are several ways to achieve it.</p>"},{"location":"usage/types/#classes-with-__get_validators__","title":"Classes with <code>__get_validators__</code>","text":"<p>You use a custom class with a classmethod <code>__get_validators__</code>. It will be called to get validators to parse and validate the input data.</p> <p>Tip</p> <p>These validators have the same semantics as in Validators, you can declare a parameter <code>config</code>, <code>field</code>, etc.</p> Python 3.7 and above <pre><code>import re\nfrom pydantic import BaseModel\n\n# https://en.wikipedia.org/wiki/Postcodes_in_the_United_Kingdom#Validation\npost_code_regex = re.compile(\n    r'(?:'\n    r'([A-Z]{1,2}[0-9][A-Z0-9]?|ASCN|STHL|TDCU|BBND|[BFS]IQQ|PCRN|TKCA) ?'\n    r'([0-9][A-Z]{2})|'\n    r'(BFPO) ?([0-9]{1,4})|'\n    r'(KY[0-9]|MSR|VG|AI)[ -]?[0-9]{4}|'\n    r'([A-Z]{2}) ?([0-9]{2})|'\n    r'(GE) ?(CX)|'\n    r'(GIR) ?(0A{2})|'\n    r'(SAN) ?(TA1)'\n    r')'\n)\n\n\nclass PostCode(str):\n    \"\"\"\n    Partial UK postcode validation. Note: this is just an example, and is not\n    intended for use in production; in particular this does NOT guarantee\n    a postcode exists, just that it has a valid format.\n    \"\"\"\n\n    @classmethod\n    def __get_validators__(cls):\n        # one or more validators may be yielded which will be called in the\n        # order to validate the input, each validator will receive as an input\n        # the value returned from the previous validator\n        yield cls.validate\n\n    @classmethod\n    def __modify_schema__(cls, field_schema):\n        # __modify_schema__ should mutate the dict it receives in place,\n        # the returned value will be ignored\n        field_schema.update(\n            # simplified regex here for brevity, see the wikipedia link above\n            pattern='^[A-Z]{1,2}[0-9][A-Z0-9]? ?[0-9][A-Z]{2}$',\n            # some example postcodes\n            examples=['SP11 9DG', 'w1j7bu'],\n        )\n\n    @classmethod\n    def validate(cls, v):\n        if not isinstance(v, str):\n            raise TypeError('string required')\n        m = post_code_regex.fullmatch(v.upper())\n        if not m:\n            raise ValueError('invalid postcode format')\n        # you could also return a string here which would mean model.post_code\n        # would be a string, pydantic won't care but you could end up with some\n        # confusion since the value's type won't match the type annotation\n        # exactly\n        return cls(f'{m.group(1)} {m.group(2)}')\n\n    def __repr__(self):\n        return f'PostCode({super().__repr__()})'\n\n\nclass Model(BaseModel):\n    post_code: PostCode\n\n\nmodel = Model(post_code='sw8 5el')\nprint(model)\n#&gt; post_code=PostCode('SW8 5EL')\nprint(model.post_code)\n#&gt; SW8 5EL\nprint(Model.schema())\n\"\"\"\n{\n    'title': 'Model',\n    'type': 'object',\n    'properties': {\n        'post_code': {\n            'title': 'Post Code',\n            'pattern': '^[A-Z]{1,2}[0-9][A-Z0-9]? ?[0-9][A-Z]{2}$',\n            'examples': ['SP11 9DG', 'w1j7bu'],\n            'type': 'string',\n        },\n    },\n    'required': ['post_code'],\n}\n\"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Similar validation could be achieved using <code>constr(regex=...)</code> except the value won't be formatted with a space, the schema would just include the full pattern and the returned value would be a vanilla string.</p> <p>See schema for more details on how the model's schema is generated.</p>"},{"location":"usage/types/#arbitrary-types-allowed","title":"Arbitrary Types Allowed","text":"<p>You can allow arbitrary types using the <code>arbitrary_types_allowed</code> config in the Model Config.</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, ValidationError\n\n\n# This is not a pydantic model, it's an arbitrary class\nclass Pet:\n    def __init__(self, name: str):\n        self.name = name\n\n\nclass Model(BaseModel):\n    pet: Pet\n    owner: str\n\n    class Config:\n        arbitrary_types_allowed = True\n\n\npet = Pet(name='Hedwig')\n# A simple check of instance type is used to validate the data\nmodel = Model(owner='Harry', pet=pet)\nprint(model)\n#&gt; pet=&lt;types_arbitrary_allowed.Pet object at 0x7fa112004460&gt; owner='Harry'\nprint(model.pet)\n#&gt; &lt;types_arbitrary_allowed.Pet object at 0x7fa112004460&gt;\nprint(model.pet.name)\n#&gt; Hedwig\nprint(type(model.pet))\n#&gt; &lt;class 'types_arbitrary_allowed.Pet'&gt;\ntry:\n    # If the value is not an instance of the type, it's invalid\n    Model(owner='Harry', pet='Hedwig')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet\n      instance of Pet expected (type=type_error.arbitrary_type;\n    expected_arbitrary_type=Pet)\n    \"\"\"\n# Nothing in the instance of the arbitrary type is checked\n# Here name probably should have been a str, but it's not validated\npet2 = Pet(name=42)\nmodel2 = Model(owner='Harry', pet=pet2)\nprint(model2)\n#&gt; pet=&lt;types_arbitrary_allowed.Pet object at 0x7fa11212f8b0&gt; owner='Harry'\nprint(model2.pet)\n#&gt; &lt;types_arbitrary_allowed.Pet object at 0x7fa11212f8b0&gt;\nprint(model2.pet.name)\n#&gt; 42\nprint(type(model2.pet))\n#&gt; &lt;class 'types_arbitrary_allowed.Pet'&gt;\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/types/#generic-classes-as-types","title":"Generic Classes as Types","text":"<p>Warning</p> <p>This is an advanced technique that you might not need in the beginning. In most of the cases you will probably be fine with standard pydantic models.</p> <p>You can use Generic Classes as field types and perform custom validation based on the \"type parameters\" (or sub-types) with <code>__get_validators__</code>.</p> <p>If the Generic class that you are using as a sub-type has a classmethod <code>__get_validators__</code> you don't need to use <code>arbitrary_types_allowed</code> for it to work.</p> <p>Because you can declare validators that receive the current <code>field</code>, you can extract the <code>sub_fields</code> (from the generic class type parameters) and validate data with them.</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, ValidationError\nfrom pydantic.fields import ModelField\nfrom typing import TypeVar, Generic\n\nAgedType = TypeVar('AgedType')\nQualityType = TypeVar('QualityType')\n\n\n# This is not a pydantic model, it's an arbitrary generic class\nclass TastingModel(Generic[AgedType, QualityType]):\n    def __init__(self, name: str, aged: AgedType, quality: QualityType):\n        self.name = name\n        self.aged = aged\n        self.quality = quality\n\n    @classmethod\n    def __get_validators__(cls):\n        yield cls.validate\n\n    @classmethod\n    # You don't need to add the \"ModelField\", but it will help your\n    # editor give you completion and catch errors\n    def validate(cls, v, field: ModelField):\n        if not isinstance(v, cls):\n            # The value is not even a TastingModel\n            raise TypeError('Invalid value')\n        if not field.sub_fields:\n            # Generic parameters were not provided so we don't try to validate\n            # them and just return the value as is\n            return v\n        aged_f = field.sub_fields[0]\n        quality_f = field.sub_fields[1]\n        errors = []\n        # Here we don't need the validated value, but we want the errors\n        valid_value, error = aged_f.validate(v.aged, {}, loc='aged')\n        if error:\n            errors.append(error)\n        # Here we don't need the validated value, but we want the errors\n        valid_value, error = quality_f.validate(v.quality, {}, loc='quality')\n        if error:\n            errors.append(error)\n        if errors:\n            raise ValidationError(errors, cls)\n        # Validation passed without errors, return the same instance received\n        return v\n\n\nclass Model(BaseModel):\n    # for wine, \"aged\" is an int with years, \"quality\" is a float\n    wine: TastingModel[int, float]\n    # for cheese, \"aged\" is a bool, \"quality\" is a str\n    cheese: TastingModel[bool, str]\n    # for thing, \"aged\" is a Any, \"quality\" is Any\n    thing: TastingModel\n\n\nmodel = Model(\n    # This wine was aged for 20 years and has a quality of 85.6\n    wine=TastingModel(name='Cabernet Sauvignon', aged=20, quality=85.6),\n    # This cheese is aged (is mature) and has \"Good\" quality\n    cheese=TastingModel(name='Gouda', aged=True, quality='Good'),\n    # This Python thing has aged \"Not much\" and has a quality \"Awesome\"\n    thing=TastingModel(name='Python', aged='Not much', quality='Awesome'),\n)\nprint(model)\n\"\"\"\nwine=&lt;types_generics.TastingModel object at 0x7fa112425ab0&gt;\ncheese=&lt;types_generics.TastingModel object at 0x7fa112425180&gt;\nthing=&lt;types_generics.TastingModel object at 0x7fa112425210&gt;\n\"\"\"\nprint(model.wine.aged)\n#&gt; 20\nprint(model.wine.quality)\n#&gt; 85.6\nprint(model.cheese.aged)\n#&gt; True\nprint(model.cheese.quality)\n#&gt; Good\nprint(model.thing.aged)\n#&gt; Not much\ntry:\n    # If the values of the sub-types are invalid, we get an error\n    Model(\n        # For wine, aged should be an int with the years, and quality a float\n        wine=TastingModel(name='Merlot', aged=True, quality='Kinda good'),\n        # For cheese, aged should be a bool, and quality a str\n        cheese=TastingModel(name='Gouda', aged='yeah', quality=5),\n        # For thing, no type parameters are declared, and we skipped validation\n        # in those cases in the Assessment.validate() function\n        thing=TastingModel(name='Python', aged='Not much', quality='Awesome'),\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    wine -&gt; quality\n      value is not a valid float (type=type_error.float)\n    cheese -&gt; aged\n      value could not be parsed to a boolean (type=type_error.bool)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/validation_decorator/","title":"Validation decorator","text":"<p>The <code>validate_arguments</code> decorator allows the arguments passed to a function to be parsed and validated using the function's annotations before the function is called. While under the hood this uses the same approach of model creation and initialisation; it provides an extremely easy way to apply validation to your code with minimal boilerplate.</p> <p>In Beta</p> <p>The <code>validate_arguments</code> decorator is in beta, it has been added to pydantic in v1.5 on a provisional basis. It may change significantly in future releases and its interface will not be concrete until v2. Feedback from the community while it's still provisional would be extremely useful; either comment on #1205 or create a new issue.</p> <p>Example of usage:</p> Python 3.7 and above <pre><code>from pydantic import validate_arguments, ValidationError\n\n\n@validate_arguments\ndef repeat(s: str, count: int, *, separator: bytes = b'') -&gt; bytes:\n    b = s.encode()\n    return separator.join(b for _ in range(count))\n\n\na = repeat('hello', 3)\nprint(a)\n#&gt; b'hellohellohello'\n\nb = repeat('x', '4', separator=' ')\nprint(b)\n#&gt; b'x x x x'\n\ntry:\n    c = repeat('hello', 'wrong')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for Repeat\n    count\n      value is not a valid integer (type=type_error.integer)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/validation_decorator/#argument-types","title":"Argument Types","text":"<p>Argument types are inferred from type annotations on the function, arguments without a type decorator are considered as <code>Any</code>. Since <code>validate_arguments</code> internally uses a standard <code>BaseModel</code>, all types listed in types can be validated, including pydantic models and custom types. As with the rest of pydantic, types can be coerced by the decorator before they're passed to the actual function:</p> Python 3.7 and abovePython 3.9 and abovePython 3.10 and above <pre><code>import os\nfrom pathlib import Path\nfrom typing import Pattern, Optional\n\nfrom pydantic import validate_arguments, DirectoryPath\n\n\n@validate_arguments\ndef find_file(path: DirectoryPath, regex: Pattern, max=None) -&gt; Optional[Path]:\n    for i, f in enumerate(path.glob('**/*')):\n        if max and i &gt; max:\n            return\n        if f.is_file() and regex.fullmatch(str(f.relative_to(path))):\n            return f\n\n\n# note: this_dir is a string here\nthis_dir = os.path.dirname(__file__)\n\nprint(find_file(this_dir, '^validation.*'))\n#&gt; /home/runner/work/pydantic/pydantic/docs/examples/validation_decorator_parame\n#&gt; ter_types.py\nprint(find_file(this_dir, '^foobar.*', max=3))\n#&gt; None\n</code></pre> <pre><code>import os\nfrom pathlib import Path\nfrom typing import Optional\nfrom re import Pattern\n\nfrom pydantic import validate_arguments, DirectoryPath\n\n\n@validate_arguments\ndef find_file(path: DirectoryPath, regex: Pattern, max=None) -&gt; Optional[Path]:\n    for i, f in enumerate(path.glob('**/*')):\n        if max and i &gt; max:\n            return\n        if f.is_file() and regex.fullmatch(str(f.relative_to(path))):\n            return f\n\n\n# note: this_dir is a string here\nthis_dir = os.path.dirname(__file__)\n\nprint(find_file(this_dir, '^validation.*'))\n#&gt; /home/runner/work/pydantic/pydantic/docs/.tmp_examples/upgraded/validation_de\n#&gt; corator_types_3_9.py\nprint(find_file(this_dir, '^foobar.*', max=3))\n#&gt; None\n</code></pre> <pre><code>import os\nfrom pathlib import Path\nfrom re import Pattern\n\nfrom pydantic import validate_arguments, DirectoryPath\n\n\n@validate_arguments\ndef find_file(path: DirectoryPath, regex: Pattern, max=None) -&gt; Path | None:\n    for i, f in enumerate(path.glob('**/*')):\n        if max and i &gt; max:\n            return\n        if f.is_file() and regex.fullmatch(str(f.relative_to(path))):\n            return f\n\n\n# note: this_dir is a string here\nthis_dir = os.path.dirname(__file__)\n\nprint(find_file(this_dir, '^validation.*'))\n#&gt; /home/runner/work/pydantic/pydantic/docs/.tmp_examples/upgraded/validation_de\n#&gt; corator_types_3_9.py\nprint(find_file(this_dir, '^foobar.*', max=3))\n#&gt; None\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>A few notes:</p> <ul> <li>though they're passed as strings, <code>path</code> and <code>regex</code> are converted to a <code>Path</code> object and regex respectively by the decorator</li> <li><code>max</code> has no type annotation, so will be considered as <code>Any</code> by the decorator</li> </ul> <p>Type coercion like this can be extremely helpful but also confusing or not desired, see below for a discussion of <code>validate_arguments</code>'s limitations in this regard.</p>"},{"location":"usage/validation_decorator/#function-signatures","title":"Function Signatures","text":"<p>The decorator is designed to work with functions using all possible parameter configurations and all possible combinations of these:</p> <ul> <li>positional or keyword arguments with or without defaults</li> <li>variable positional arguments defined via <code>*</code> (often <code>*args</code>)</li> <li>variable keyword arguments defined via <code>**</code> (often <code>**kwargs</code>)</li> <li>keyword only arguments - arguments after <code>*,</code></li> <li>positional only arguments - arguments before <code>, /</code> (new in Python 3.8)</li> </ul> <p>To demonstrate all the above parameter types:</p> Python 3.8 and above <pre><code>from pydantic import validate_arguments\n\n\n@validate_arguments\ndef pos_or_kw(a: int, b: int = 2) -&gt; str:\n    return f'a={a} b={b}'\n\n\nprint(pos_or_kw(1))\n#&gt; a=1 b=2\nprint(pos_or_kw(a=1))\n#&gt; a=1 b=2\nprint(pos_or_kw(1, 3))\n#&gt; a=1 b=3\nprint(pos_or_kw(a=1, b=3))\n#&gt; a=1 b=3\n\n\n@validate_arguments\ndef kw_only(*, a: int, b: int = 2) -&gt; str:\n    return f'a={a} b={b}'\n\n\nprint(kw_only(a=1))\n#&gt; a=1 b=2\nprint(kw_only(a=1, b=3))\n#&gt; a=1 b=3\n\n\n@validate_arguments\ndef pos_only(a: int, b: int = 2, /) -&gt; str:  # python 3.8 only\n    return f'a={a} b={b}'\n\n\nprint(pos_only(1))\n#&gt; a=1 b=2\nprint(pos_only(1, 2))\n#&gt; a=1 b=2\n\n\n@validate_arguments\ndef var_args(*args: int) -&gt; str:\n    return str(args)\n\n\nprint(var_args(1))\n#&gt; (1,)\nprint(var_args(1, 2))\n#&gt; (1, 2)\nprint(var_args(1, 2, 3))\n#&gt; (1, 2, 3)\n\n\n@validate_arguments\ndef var_kwargs(**kwargs: int) -&gt; str:\n    return str(kwargs)\n\n\nprint(var_kwargs(a=1))\n#&gt; {'a': 1}\nprint(var_kwargs(a=1, b=2))\n#&gt; {'a': 1, 'b': 2}\n\n\n@validate_arguments\ndef armageddon(\n    a: int,\n    /,  # python 3.8 only\n    b: int,\n    c: int = None,\n    *d: int,\n    e: int,\n    f: int = None,\n    **g: int,\n) -&gt; str:\n    return f'a={a} b={b} c={c} d={d} e={e} f={f} g={g}'\n\n\nprint(armageddon(1, 2, e=3))\n#&gt; a=1 b=2 c=None d=() e=3 f=None g={}\nprint(armageddon(1, 2, 3, 4, 5, 6, e=8, f=9, g=10, spam=11))\n#&gt; a=1 b=2 c=3 d=(4, 5, 6) e=8 f=9 g={'g': 10, 'spam': 11}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/validation_decorator/#using-field-to-describe-function-arguments","title":"Using Field to describe function arguments","text":"<p>Field can also be used with <code>validate_arguments</code> to provide extra information about the field and validations. In general it should be used in a type hint with Annotated, unless <code>default_factory</code> is specified, in which case it should be used as the default value of the field:</p> Python 3.7 and above <pre><code>from datetime import datetime\nfrom pydantic import validate_arguments, Field, ValidationError\nfrom pydantic.typing import Annotated\n\n\n@validate_arguments\ndef how_many(num: Annotated[int, Field(gt=10)]):\n    return num\n\n\ntry:\n    how_many(1)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for HowMany\n    num\n      ensure this value is greater than 10 (type=value_error.number.not_gt;\n    limit_value=10)\n    \"\"\"\n\n\n@validate_arguments\ndef when(dt: datetime = Field(default_factory=datetime.now)):\n    return dt\n\n\nprint(type(when()))\n#&gt; &lt;class 'datetime.datetime'&gt;\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>The alias can be used with the decorator as normal.</p> Python 3.7 and above <pre><code>from pydantic import Field, validate_arguments\nfrom pydantic.typing import Annotated\n\n\n@validate_arguments\ndef how_many(num: Annotated[int, Field(gt=10, alias='number')]):\n    return num\n\n\nhow_many(number=42)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/validation_decorator/#usage-with-mypy","title":"Usage with mypy","text":"<p>The <code>validate_arguments</code> decorator should work \"out of the box\" with mypy since it's defined to return a function with the same signature as the function it decorates. The only limitation is that since we trick mypy into thinking the function returned by the decorator is the same as the function being decorated; access to the raw function or other attributes will require <code>type: ignore</code>.</p>"},{"location":"usage/validation_decorator/#validate-without-calling-the-function","title":"Validate without calling the function","text":"<p>By default, arguments validation is done by directly calling the decorated function with parameters. But what if you wanted to validate them without actually calling the function? To do that you can call the <code>validate</code> method bound to the decorated function.</p> Python 3.7 and above <pre><code>from pydantic import validate_arguments, ValidationError\n\n\n@validate_arguments\ndef slow_sum(a: int, b: int) -&gt; int:\n    print(f'Called with a={a}, b={b}')\n    #&gt; Called with a=1, b=1\n    return a + b\n\n\nslow_sum(1, 1)\n\nslow_sum.validate(2, 2)\n\ntry:\n    slow_sum.validate(1, 'b')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for SlowSum\n    b\n      value is not a valid integer (type=type_error.integer)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/validation_decorator/#raw-function","title":"Raw function","text":"<p>The raw function which was decorated is accessible, this is useful if in some scenarios you trust your input arguments and want to call the function in the most performant way (see notes on performance below):</p> Python 3.7 and above <pre><code>from pydantic import validate_arguments\n\n\n@validate_arguments\ndef repeat(s: str, count: int, *, separator: bytes = b'') -&gt; bytes:\n    b = s.encode()\n    return separator.join(b for _ in range(count))\n\n\na = repeat('hello', 3)\nprint(a)\n#&gt; b'hellohellohello'\n\nb = repeat.raw_function('good bye', 2, separator=b', ')\nprint(b)\n#&gt; b'good bye, good bye'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/validation_decorator/#async-functions","title":"Async Functions","text":"<p><code>validate_arguments</code> can also be used on async functions:</p> Python 3.7 and above <pre><code>import asyncio\nfrom pydantic import PositiveInt, ValidationError, validate_arguments\n\n\n@validate_arguments\nasync def get_user_email(user_id: PositiveInt):\n    # `conn` is some fictional connection to a database\n    email = await conn.execute('select email from users where id=$1', user_id)\n    if email is None:\n        raise RuntimeError('user not found')\n    else:\n        return email\n\n\nasync def main():\n    email = await get_user_email(123)\n    print(email)\n    #&gt; testing@example.com\n    try:\n        await get_user_email(-4)\n    except ValidationError as exc:\n        print(exc.errors())\n        \"\"\"\n        [\n            {\n                'loc': ('user_id',),\n                'msg': 'ensure this value is greater than 0',\n                'type': 'value_error.number.not_gt',\n                'ctx': {'limit_value': 0},\n            },\n        ]\n        \"\"\"\n\n\nasyncio.run(main())\n</code></pre> <p>(This script requires <code>conn.execute()</code> that will return <code>'testing@example.com'</code>)</p>"},{"location":"usage/validation_decorator/#custom-config","title":"Custom Config","text":"<p>The model behind <code>validate_arguments</code> can be customised using a config setting which is equivalent to setting the <code>Config</code> sub-class in normal models.</p> <p>Warning</p> <p>The <code>fields</code> and <code>alias_generator</code> properties of <code>Config</code> which allow aliases to be configured are not supported yet with <code>@validate_arguments</code>, using them will raise an error.</p> <p>Configuration is set using the <code>config</code> keyword argument to the decorator, it may be either a config class or a dict of properties which are converted to a class later.</p> Python 3.7 and above <pre><code>from pydantic import ValidationError, validate_arguments\n\n\nclass Foobar:\n    def __init__(self, v: str):\n        self.v = v\n\n    def __add__(self, other: 'Foobar') -&gt; str:\n        return f'{self} + {other}'\n\n    def __str__(self) -&gt; str:\n        return f'Foobar({self.v})'\n\n\n@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef add_foobars(a: Foobar, b: Foobar):\n    return a + b\n\n\nc = add_foobars(Foobar('a'), Foobar('b'))\nprint(c)\n#&gt; Foobar(a) + Foobar(b)\n\ntry:\n    add_foobars(1, 2)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for AddFoobars\n    a\n      instance of Foobar expected (type=type_error.arbitrary_type;\n    expected_arbitrary_type=Foobar)\n    b\n      instance of Foobar expected (type=type_error.arbitrary_type;\n    expected_arbitrary_type=Foobar)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/validation_decorator/#limitations","title":"Limitations","text":"<p><code>validate_arguments</code> has been released on a provisional basis without all the bells and whistles, which may be added later, see #1205 for some more discussion of this.</p> <p>In particular:</p>"},{"location":"usage/validation_decorator/#validation-exception","title":"Validation Exception","text":"<p>Currently upon validation failure, a standard pydantic <code>ValidationError</code> is raised, see model error handling.</p> <p>This is helpful since it's <code>str()</code> method provides useful details of the error which occurred and methods like <code>.errors()</code> and <code>.json()</code> can be useful when exposing the errors to end users, however <code>ValidationError</code> inherits from <code>ValueError</code> not <code>TypeError</code> which may be unexpected since Python would raise a <code>TypeError</code> upon invalid or missing arguments. This may be addressed in future by either allow a custom error or raising a different exception by default, or both.</p>"},{"location":"usage/validation_decorator/#coercion-and-strictness","title":"Coercion and Strictness","text":"<p>pydantic currently leans on the side of trying to coerce types rather than raise an error if a type is wrong, see model data conversion and <code>validate_arguments</code> is no different.</p> <p>See #1098 and other issues with the \"strictness\" label for a discussion of this. If pydantic gets a \"strict\" mode in future, <code>validate_arguments</code> will have an option to use this, it may even become the default for the decorator.</p>"},{"location":"usage/validation_decorator/#performance","title":"Performance","text":"<p>We've made a big effort to make pydantic as performant as possible and argument inspect and model creation is only performed once when the function is defined, however there will still be a performance impact to using the <code>validate_arguments</code> decorator compared to calling the raw function.</p> <p>In many situations this will have little or no noticeable effect, however be aware that <code>validate_arguments</code> is not an equivalent or alternative to function definitions in strongly typed languages; it never will be.</p>"},{"location":"usage/validation_decorator/#return-value","title":"Return Value","text":"<p>The return value of the function is not validated against its return type annotation, this may be added as an option in future.</p>"},{"location":"usage/validation_decorator/#config-and-validators","title":"Config and Validators","text":"<p><code>fields</code> and <code>alias_generator</code> on custom <code>Config</code> are not supported, see above.</p> <p>Neither are validators.</p>"},{"location":"usage/validation_decorator/#model-fields-and-reserved-arguments","title":"Model fields and reserved arguments","text":"<p>The following names may not be used by arguments since they can be used internally to store information about the function's signature:</p> <ul> <li><code>v__args</code></li> <li><code>v__kwargs</code></li> <li><code>v__positional_only</code></li> </ul> <p>These names (together with <code>\"args\"</code> and <code>\"kwargs\"</code>) may or may not (depending on the function's signature) appear as fields on the internal pydantic model accessible via <code>.model</code> thus this model isn't especially useful (e.g. for generating a schema) at the moment.</p> <p>This should be fixable in future as the way error are raised is changed.</p>"},{"location":"usage/validators/","title":"Validators","text":"<p>Custom validation and complex relationships between objects can be achieved using the <code>validator</code> decorator.</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, ValidationError, validator\n\n\nclass UserModel(BaseModel):\n    name: str\n    username: str\n    password1: str\n    password2: str\n\n    @validator('name')\n    def name_must_contain_space(cls, v):\n        if ' ' not in v:\n            raise ValueError('must contain a space')\n        return v.title()\n\n    @validator('password2')\n    def passwords_match(cls, v, values, **kwargs):\n        if 'password1' in values and v != values['password1']:\n            raise ValueError('passwords do not match')\n        return v\n\n    @validator('username')\n    def username_alphanumeric(cls, v):\n        assert v.isalnum(), 'must be alphanumeric'\n        return v\n\n\nuser = UserModel(\n    name='samuel colvin',\n    username='scolvin',\n    password1='zxcvbn',\n    password2='zxcvbn',\n)\nprint(user)\n#&gt; name='Samuel Colvin' username='scolvin' password1='zxcvbn' password2='zxcvbn'\n\ntry:\n    UserModel(\n        name='samuel',\n        username='scolvin',\n        password1='zxcvbn',\n        password2='zxcvbn2',\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for UserModel\n    name\n      must contain a space (type=value_error)\n    password2\n      passwords do not match (type=value_error)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>A few things to note on validators:</p> <ul> <li>validators are \"class methods\", so the first argument value they receive is the <code>UserModel</code> class, not an instance   of <code>UserModel</code>.</li> <li>the second argument is always the field value to validate; it can be named as you please</li> <li>you can also add any subset of the following arguments to the signature (the names must match):<ul> <li><code>values</code>: a dict containing the name-to-value mapping of any previously-validated fields</li> <li><code>config</code>: the model config</li> <li><code>field</code>: the field being validated. Type of object is <code>pydantic.fields.ModelField</code>.</li> <li><code>**kwargs</code>: if provided, this will include the arguments above not explicitly listed in the signature</li> </ul> </li> <li>validators should either return the parsed value or raise a <code>ValueError</code>, <code>TypeError</code>, or <code>AssertionError</code>   (<code>assert</code> statements may be used).</li> </ul> <p>Warning</p> <p>If you make use of <code>assert</code> statements, keep in mind that running Python with the <code>-O</code> optimization flag disables <code>assert</code> statements, and validators will stop working.</p> <ul> <li> <p>where validators rely on other values, you should be aware that:</p> <ul> <li>Validation is done in the order fields are defined.   E.g. in the example above, <code>password2</code> has access to <code>password1</code> (and <code>name</code>),   but <code>password1</code> does not have access to <code>password2</code>. See Field Ordering   for more information on how fields are ordered</li> </ul> <ul> <li>If validation fails on another field (or that field is missing) it will not be included in <code>values</code>, hence   <code>if 'password1' in values and ...</code> in this example.</li> </ul> </li> </ul>"},{"location":"usage/validators/#pre-and-per-item-validators","title":"Pre and per-item validators","text":"<p>Validators can do a few more complex things:</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import List\nfrom pydantic import BaseModel, ValidationError, validator\n\n\nclass DemoModel(BaseModel):\n    square_numbers: List[int] = []\n    cube_numbers: List[int] = []\n\n    # '*' is the same as 'cube_numbers', 'square_numbers' here:\n    @validator('*', pre=True)\n    def split_str(cls, v):\n        if isinstance(v, str):\n            return v.split('|')\n        return v\n\n    @validator('cube_numbers', 'square_numbers')\n    def check_sum(cls, v):\n        if sum(v) &gt; 42:\n            raise ValueError('sum of numbers greater than 42')\n        return v\n\n    @validator('square_numbers', each_item=True)\n    def check_squares(cls, v):\n        assert v ** 0.5 % 1 == 0, f'{v} is not a square number'\n        return v\n\n    @validator('cube_numbers', each_item=True)\n    def check_cubes(cls, v):\n        # 64 ** (1 / 3) == 3.9999999999999996 (!)\n        # this is not a good way of checking cubes\n        assert v ** (1 / 3) % 1 == 0, f'{v} is not a cubed number'\n        return v\n\n\nprint(DemoModel(square_numbers=[1, 4, 9]))\n#&gt; square_numbers=[1, 4, 9] cube_numbers=[]\nprint(DemoModel(square_numbers='1|4|16'))\n#&gt; square_numbers=[1, 4, 16] cube_numbers=[]\nprint(DemoModel(square_numbers=[16], cube_numbers=[8, 27]))\n#&gt; square_numbers=[16] cube_numbers=[8, 27]\ntry:\n    DemoModel(square_numbers=[1, 4, 2])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for DemoModel\n    square_numbers -&gt; 2\n      2 is not a square number (type=assertion_error)\n    \"\"\"\n\ntry:\n    DemoModel(cube_numbers=[27, 27])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for DemoModel\n    cube_numbers\n      sum of numbers greater than 42 (type=value_error)\n    \"\"\"\n</code></pre> <pre><code>from pydantic import BaseModel, ValidationError, validator\n\n\nclass DemoModel(BaseModel):\n    square_numbers: list[int] = []\n    cube_numbers: list[int] = []\n\n    # '*' is the same as 'cube_numbers', 'square_numbers' here:\n    @validator('*', pre=True)\n    def split_str(cls, v):\n        if isinstance(v, str):\n            return v.split('|')\n        return v\n\n    @validator('cube_numbers', 'square_numbers')\n    def check_sum(cls, v):\n        if sum(v) &gt; 42:\n            raise ValueError('sum of numbers greater than 42')\n        return v\n\n    @validator('square_numbers', each_item=True)\n    def check_squares(cls, v):\n        assert v ** 0.5 % 1 == 0, f'{v} is not a square number'\n        return v\n\n    @validator('cube_numbers', each_item=True)\n    def check_cubes(cls, v):\n        # 64 ** (1 / 3) == 3.9999999999999996 (!)\n        # this is not a good way of checking cubes\n        assert v ** (1 / 3) % 1 == 0, f'{v} is not a cubed number'\n        return v\n\n\nprint(DemoModel(square_numbers=[1, 4, 9]))\n#&gt; square_numbers=[1, 4, 9] cube_numbers=[]\nprint(DemoModel(square_numbers='1|4|16'))\n#&gt; square_numbers=[1, 4, 16] cube_numbers=[]\nprint(DemoModel(square_numbers=[16], cube_numbers=[8, 27]))\n#&gt; square_numbers=[16] cube_numbers=[8, 27]\ntry:\n    DemoModel(square_numbers=[1, 4, 2])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for DemoModel\n    square_numbers -&gt; 2\n      2 is not a square number (type=assertion_error)\n    \"\"\"\n\ntry:\n    DemoModel(cube_numbers=[27, 27])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for DemoModel\n    cube_numbers\n      sum of numbers greater than 42 (type=value_error)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>A few more things to note:</p> <ul> <li>a single validator can be applied to multiple fields by passing it multiple field names</li> <li>a single validator can also be called on all fields by passing the special value <code>'*'</code></li> <li>the keyword argument <code>pre</code> will cause the validator to be called prior to other validation</li> <li>passing <code>each_item=True</code> will result in the validator being applied to individual values   (e.g. of <code>List</code>, <code>Dict</code>, <code>Set</code>, etc.), rather than the whole object</li> </ul>"},{"location":"usage/validators/#subclass-validators-and-each_item","title":"Subclass Validators and <code>each_item</code>","text":"<p>If using a validator with a subclass that references a <code>List</code> type field on a parent class, using <code>each_item=True</code> will cause the validator not to run; instead, the list must be iterated over programmatically.</p> Python 3.7 and abovePython 3.9 and above <pre><code>from typing import List\nfrom pydantic import BaseModel, ValidationError, validator\n\n\nclass ParentModel(BaseModel):\n    names: List[str]\n\n\nclass ChildModel(ParentModel):\n    @validator('names', each_item=True)\n    def check_names_not_empty(cls, v):\n        assert v != '', 'Empty strings are not allowed.'\n        return v\n\n\n# This will NOT raise a ValidationError because the validator was not called\ntry:\n    child = ChildModel(names=['Alice', 'Bob', 'Eve', ''])\nexcept ValidationError as e:\n    print(e)\nelse:\n    print('No ValidationError caught.')\n    #&gt; No ValidationError caught.\n\n\nclass ChildModel2(ParentModel):\n    @validator('names')\n    def check_names_not_empty(cls, v):\n        for name in v:\n            assert name != '', 'Empty strings are not allowed.'\n        return v\n\n\ntry:\n    child = ChildModel2(names=['Alice', 'Bob', 'Eve', ''])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for ChildModel2\n    names\n      Empty strings are not allowed. (type=assertion_error)\n    \"\"\"\n</code></pre> <pre><code>from pydantic import BaseModel, ValidationError, validator\n\n\nclass ParentModel(BaseModel):\n    names: list[str]\n\n\nclass ChildModel(ParentModel):\n    @validator('names', each_item=True)\n    def check_names_not_empty(cls, v):\n        assert v != '', 'Empty strings are not allowed.'\n        return v\n\n\n# This will NOT raise a ValidationError because the validator was not called\ntry:\n    child = ChildModel(names=['Alice', 'Bob', 'Eve', ''])\nexcept ValidationError as e:\n    print(e)\nelse:\n    print('No ValidationError caught.')\n    #&gt; No ValidationError caught.\n\n\nclass ChildModel2(ParentModel):\n    @validator('names')\n    def check_names_not_empty(cls, v):\n        for name in v:\n            assert name != '', 'Empty strings are not allowed.'\n        return v\n\n\ntry:\n    child = ChildModel2(names=['Alice', 'Bob', 'Eve', ''])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for ChildModel2\n    names\n      Empty strings are not allowed. (type=assertion_error)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"usage/validators/#validate-always","title":"Validate Always","text":"<p>For performance reasons, by default validators are not called for fields when a value is not supplied. However there are situations where it may be useful or required to always call the validator, e.g. to set a dynamic default value.</p> Python 3.7 and above <pre><code>from datetime import datetime\n\nfrom pydantic import BaseModel, validator\n\n\nclass DemoModel(BaseModel):\n    ts: datetime = None\n\n    @validator('ts', pre=True, always=True)\n    def set_ts_now(cls, v):\n        return v or datetime.now()\n\n\nprint(DemoModel())\n#&gt; ts=datetime.datetime(2025, 9, 13, 2, 31, 52, 357782)\nprint(DemoModel(ts='2017-11-08T14:00'))\n#&gt; ts=datetime.datetime(2017, 11, 8, 14, 0)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>You'll often want to use this together with <code>pre</code>, since otherwise with <code>always=True</code> pydantic would try to validate the default <code>None</code> which would cause an error.</p>"},{"location":"usage/validators/#reuse-validators","title":"Reuse validators","text":"<p>Occasionally, you will want to use the same validator on multiple fields/models (e.g. to normalize some input data). The \"naive\" approach would be to write a separate function, then call it from multiple decorators.  Obviously, this entails a lot of repetition and boiler plate code. To circumvent this, the <code>allow_reuse</code> parameter has been added to <code>pydantic.validator</code> in v1.2 (<code>False</code> by default):</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, validator\n\n\ndef normalize(name: str) -&gt; str:\n    return ' '.join((word.capitalize()) for word in name.split(' '))\n\n\nclass Producer(BaseModel):\n    name: str\n\n    # validators\n    _normalize_name = validator('name', allow_reuse=True)(normalize)\n\n\nclass Consumer(BaseModel):\n    name: str\n\n    # validators\n    _normalize_name = validator('name', allow_reuse=True)(normalize)\n\n\njane_doe = Producer(name='JaNe DOE')\njohn_doe = Consumer(name='joHN dOe')\nassert jane_doe.name == 'Jane Doe'\nassert john_doe.name == 'John Doe'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>As it is obvious, repetition has been reduced and the models become again almost declarative.</p> <p>Tip</p> <p>If you have a lot of fields that you want to validate, it usually makes sense to define a help function with which you will avoid setting <code>allow_reuse=True</code> over and over again.</p>"},{"location":"usage/validators/#root-validators","title":"Root Validators","text":"<p>Validation can also be performed on the entire model's data.</p> Python 3.7 and above <pre><code>from pydantic import BaseModel, ValidationError, root_validator\n\n\nclass UserModel(BaseModel):\n    username: str\n    password1: str\n    password2: str\n\n    @root_validator(pre=True)\n    def check_card_number_omitted(cls, values):\n        assert 'card_number' not in values, 'card_number should not be included'\n        return values\n\n    @root_validator\n    def check_passwords_match(cls, values):\n        pw1, pw2 = values.get('password1'), values.get('password2')\n        if pw1 is not None and pw2 is not None and pw1 != pw2:\n            raise ValueError('passwords do not match')\n        return values\n\n\nprint(UserModel(username='scolvin', password1='zxcvbn', password2='zxcvbn'))\n#&gt; username='scolvin' password1='zxcvbn' password2='zxcvbn'\ntry:\n    UserModel(username='scolvin', password1='zxcvbn', password2='zxcvbn2')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for UserModel\n    __root__\n      passwords do not match (type=value_error)\n    \"\"\"\n\ntry:\n    UserModel(\n        username='scolvin',\n        password1='zxcvbn',\n        password2='zxcvbn',\n        card_number='1234',\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for UserModel\n    __root__\n      card_number should not be included (type=assertion_error)\n    \"\"\"\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>As with field validators, root validators can have <code>pre=True</code>, in which case they're called before field validation occurs (and are provided with the raw input data), or <code>pre=False</code> (the default), in which case they're called after field validation.</p> <p>Field validation will not occur if <code>pre=True</code> root validators raise an error. As with field validators, \"post\" (i.e. <code>pre=False</code>) root validators by default will be called even if prior validators fail; this behaviour can be changed by setting the <code>skip_on_failure=True</code> keyword argument to the validator. The <code>values</code> argument will be a dict containing the values which passed field validation and field defaults where applicable.</p>"},{"location":"usage/validators/#field-checks","title":"Field Checks","text":"<p>On class creation, validators are checked to confirm that the fields they specify actually exist on the model.</p> <p>Occasionally however this is undesirable: e.g. if you define a validator to validate fields on inheriting models. In this case you should set <code>check_fields=False</code> on the validator.</p>"},{"location":"usage/validators/#dataclass-validators","title":"Dataclass Validators","text":"<p>Validators also work with pydantic dataclasses.</p> Python 3.7 and above <pre><code>from datetime import datetime\n\nfrom pydantic import validator\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass DemoDataclass:\n    ts: datetime = None\n\n    @validator('ts', pre=True, always=True)\n    def set_ts_now(cls, v):\n        return v or datetime.now()\n\n\nprint(DemoDataclass())\n#&gt; DemoDataclass(ts=datetime.datetime(2025, 9, 13, 2, 31, 52, 365470))\nprint(DemoDataclass(ts='2017-11-08T14:00'))\n#&gt; DemoDataclass(ts=datetime.datetime(2017, 11, 8, 14, 0))\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"}]}